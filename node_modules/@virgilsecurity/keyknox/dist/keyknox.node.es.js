import axios from 'axios';
import { VirgilCrypto } from 'virgil-crypto';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var KeyknoxError = /** @class */ (function (_super) {
    __extends(KeyknoxError, _super);
    function KeyknoxError(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        _this.name = 'KeyknoxError';
        return _this;
    }
    return KeyknoxError;
}(Error));
var KeyknoxClientError = /** @class */ (function (_super) {
    __extends(KeyknoxClientError, _super);
    function KeyknoxClientError(message, status, code) {
        var _this = _super.call(this, message) || this;
        _this.name = 'KeyknoxClientError';
        _this.status = status;
        _this.code = code;
        return _this;
    }
    return KeyknoxClientError;
}(KeyknoxError));
var CloudKeyStorageOutOfSyncError = /** @class */ (function (_super) {
    __extends(CloudKeyStorageOutOfSyncError, _super);
    function CloudKeyStorageOutOfSyncError() {
        var _this = _super.call(this, 'CloudKeyStorage is out of sync') || this;
        _this.name = 'CloudKeyStorageOutOfSyncError';
        return _this;
    }
    return CloudKeyStorageOutOfSyncError;
}(KeyknoxError));
var CloudEntryExistsError = /** @class */ (function (_super) {
    __extends(CloudEntryExistsError, _super);
    function CloudEntryExistsError(cloudEntryName) {
        var _this = _super.call(this, "Cloud entry '" + cloudEntryName + "' already exists") || this;
        _this.name = 'CloudEntryExistsError';
        _this.cloudEntryName = cloudEntryName;
        return _this;
    }
    return CloudEntryExistsError;
}(KeyknoxError));
var CloudEntryDoesntExistError = /** @class */ (function (_super) {
    __extends(CloudEntryDoesntExistError, _super);
    function CloudEntryDoesntExistError(cloudEntryName) {
        var _this = _super.call(this, "Cloud entry '" + cloudEntryName + "' doesn't exist") || this;
        _this.name = 'CloudEntryDoesntExistError';
        _this.cloudEntryName = cloudEntryName;
        return _this;
    }
    return CloudEntryDoesntExistError;
}(KeyknoxError));
var KeyEntryExistsError = /** @class */ (function (_super) {
    __extends(KeyEntryExistsError, _super);
    function KeyEntryExistsError(keyEntryName) {
        var _this = _super.call(this, "Key entry '" + keyEntryName + "' already exists") || this;
        _this.name = 'KeyEntryExistsError';
        _this.keyEntryName = keyEntryName;
        return _this;
    }
    return KeyEntryExistsError;
}(KeyknoxError));
var KeyEntryDoesntExistError = /** @class */ (function (_super) {
    __extends(KeyEntryDoesntExistError, _super);
    function KeyEntryDoesntExistError(keyEntryName) {
        var _this = _super.call(this, "Key entry '" + keyEntryName + "' doesn't exist") || this;
        _this.name = 'KeyEntryDoesntExistError';
        _this.keyEntryName = keyEntryName;
        return _this;
    }
    return KeyEntryDoesntExistError;
}(KeyknoxError));

var DEFAULT_BASE_URL = 'https://api.virgilsecurity.com';
var KeyknoxClient = /** @class */ (function () {
    function KeyknoxClient(apiUrl, axiosInstance) {
        this.axios = axiosInstance || axios.create({ baseURL: apiUrl || DEFAULT_BASE_URL });
        this.axios.interceptors.response.use(undefined, KeyknoxClient.responseErrorHandler);
    }
    KeyknoxClient.prototype.pushValue = function (meta, value, token, previousHash) {
        return __awaiter(this, void 0, void 0, function () {
            var payload, config, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        payload = {
                            meta: meta.toString('base64'),
                            value: value.toString('base64'),
                        };
                        config = {
                            headers: {
                                Authorization: KeyknoxClient.getAuthorizationHeader(token),
                            },
                        };
                        if (previousHash) {
                            config.headers['Virgil-Keyknox-Previous-Hash'] = previousHash.toString('base64');
                        }
                        return [4 /*yield*/, this.axios.put('/keyknox/v1', payload, config)];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, KeyknoxClient.getKeyknoxValue(response)];
                }
            });
        });
    };
    KeyknoxClient.prototype.pullValue = function (token) {
        return __awaiter(this, void 0, void 0, function () {
            var config, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        config = {
                            headers: {
                                Authorization: KeyknoxClient.getAuthorizationHeader(token),
                            },
                        };
                        return [4 /*yield*/, this.axios.get('/keyknox/v1', config)];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, KeyknoxClient.getKeyknoxValue(response)];
                }
            });
        });
    };
    KeyknoxClient.prototype.resetValue = function (token) {
        return __awaiter(this, void 0, void 0, function () {
            var config, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        config = {
                            headers: {
                                Authorization: KeyknoxClient.getAuthorizationHeader(token),
                            },
                        };
                        return [4 /*yield*/, this.axios.post('/keyknox/v1/reset', null, config)];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, KeyknoxClient.getKeyknoxValue(response)];
                }
            });
        });
    };
    KeyknoxClient.getKeyknoxValue = function (response) {
        var data = response.data, headers = response.headers;
        return {
            meta: Buffer.from(data.meta, 'base64'),
            value: Buffer.from(data.value, 'base64'),
            version: data.version,
            keyknoxHash: Buffer.from(headers['virgil-keyknox-hash'], 'base64'),
        };
    };
    KeyknoxClient.getAuthorizationHeader = function (token) {
        return KeyknoxClient.AUTHORIZATION_PREFIX + " " + token;
    };
    KeyknoxClient.responseErrorHandler = function (error) {
        var response = error.response;
        if (response) {
            var data = response.data;
            if (data && data.code && data.message) {
                return Promise.reject(new KeyknoxClientError(data.message, response.status, data.code));
            }
            return Promise.reject(new KeyknoxClientError(error.message, response.status));
        }
        return Promise.reject(new KeyknoxClientError(error.message));
    };
    KeyknoxClient.AUTHORIZATION_PREFIX = 'Virgil';
    return KeyknoxClient;
}());

var KeyknoxCrypto = /** @class */ (function () {
    function KeyknoxCrypto(crypto) {
        this.crypto = crypto || new VirgilCrypto();
    }
    KeyknoxCrypto.prototype.decrypt = function (encryptedKeyknoxValue, privateKey, publicKeys) {
        var value = encryptedKeyknoxValue.value, meta = encryptedKeyknoxValue.meta;
        if (!value.byteLength || !meta.byteLength) {
            if (value.byteLength || meta.byteLength) {
                throw new TypeError("'EncryptedKeyknoxValue' is invalid");
            }
            return encryptedKeyknoxValue;
        }
        var decrypted = this.crypto.decryptThenVerifyDetached(value, meta, privateKey, publicKeys);
        return __assign({}, encryptedKeyknoxValue, { value: decrypted });
    };
    KeyknoxCrypto.prototype.encrypt = function (data, privateKey, publicKeys) {
        return this.crypto.signThenEncryptDetached(data, privateKey, publicKeys);
    };
    return KeyknoxCrypto;
}());

var KeyknoxManager = /** @class */ (function () {
    function KeyknoxManager(accessTokenProvider, privateKey, publicKeys, keyknoxClient, keyknoxCrypto) {
        this.accessTokenProvider = accessTokenProvider;
        this.myPrivateKey = privateKey;
        this.myPublicKeys = publicKeys;
        this.keyknoxClient = keyknoxClient || new KeyknoxClient();
        this.keyknoxCrypto = keyknoxCrypto || new KeyknoxCrypto();
    }
    Object.defineProperty(KeyknoxManager.prototype, "privateKey", {
        get: function () {
            return this.myPrivateKey;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KeyknoxManager.prototype, "publicKeys", {
        get: function () {
            return this.myPublicKeys;
        },
        enumerable: true,
        configurable: true
    });
    KeyknoxManager.prototype.pushValue = function (value, previousHash) {
        return __awaiter(this, void 0, void 0, function () {
            var token, _a, metadata, encryptedData, encryptedKeyknoxValue;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.accessTokenProvider.getToken({ operation: 'put' })];
                    case 1:
                        token = _b.sent();
                        _a = this.keyknoxCrypto.encrypt(value, this.myPrivateKey, this.myPublicKeys), metadata = _a.metadata, encryptedData = _a.encryptedData;
                        return [4 /*yield*/, this.keyknoxClient.pushValue(metadata, encryptedData, token.toString(), previousHash)];
                    case 2:
                        encryptedKeyknoxValue = _b.sent();
                        return [2 /*return*/, this.keyknoxCrypto.decrypt(encryptedKeyknoxValue, this.myPrivateKey, this.myPublicKeys)];
                }
            });
        });
    };
    KeyknoxManager.prototype.pullValue = function () {
        return __awaiter(this, void 0, void 0, function () {
            var token, encryptedKeyknoxValue;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.accessTokenProvider.getToken({ operation: 'get' })];
                    case 1:
                        token = _a.sent();
                        return [4 /*yield*/, this.keyknoxClient.pullValue(token.toString())];
                    case 2:
                        encryptedKeyknoxValue = _a.sent();
                        return [2 /*return*/, this.keyknoxCrypto.decrypt(encryptedKeyknoxValue, this.myPrivateKey, this.myPublicKeys)];
                }
            });
        });
    };
    KeyknoxManager.prototype.resetValue = function () {
        return __awaiter(this, void 0, void 0, function () {
            var token;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.accessTokenProvider.getToken({ operation: 'delete' })];
                    case 1:
                        token = _a.sent();
                        return [2 /*return*/, this.keyknoxClient.resetValue(token.toString())];
                }
            });
        });
    };
    KeyknoxManager.prototype.updateValue = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var value, previousHash, newPrivateKey, newPublicKeys, decryptedKeyknoxValue, _a, metadata, encryptedData, token, encryptedKeyknoxValue;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        value = options.value, previousHash = options.previousHash, newPrivateKey = options.newPrivateKey, newPublicKeys = options.newPublicKeys;
                        if (!newPrivateKey && !newPublicKeys) {
                            return [2 /*return*/, this.pushValue(value, previousHash)];
                        }
                        return [4 /*yield*/, this.pullValue()];
                    case 1:
                        decryptedKeyknoxValue = _b.sent();
                        if (newPrivateKey) {
                            this.myPrivateKey = newPrivateKey;
                        }
                        if (newPublicKeys) {
                            this.myPublicKeys = newPublicKeys;
                        }
                        _a = this.keyknoxCrypto.encrypt(decryptedKeyknoxValue.value, this.myPrivateKey, this.myPublicKeys), metadata = _a.metadata, encryptedData = _a.encryptedData;
                        return [4 /*yield*/, this.accessTokenProvider.getToken({ operation: 'put' })];
                    case 2:
                        token = _b.sent();
                        return [4 /*yield*/, this.keyknoxClient.pushValue(metadata, encryptedData, token.toString(), decryptedKeyknoxValue.keyknoxHash)];
                    case 3:
                        encryptedKeyknoxValue = _b.sent();
                        return [2 /*return*/, this.keyknoxCrypto.decrypt(encryptedKeyknoxValue, this.myPrivateKey, this.myPublicKeys)];
                }
            });
        });
    };
    KeyknoxManager.prototype.updateRecipients = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var newPrivateKey, newPublicKeys, decryptedKeyknoxValue, _a, metadata, encryptedData, token, encryptedKeyknoxValue;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        newPrivateKey = options.newPrivateKey, newPublicKeys = options.newPublicKeys;
                        return [4 /*yield*/, this.pullValue()];
                    case 1:
                        decryptedKeyknoxValue = _b.sent();
                        if (!decryptedKeyknoxValue.meta.byteLength && !decryptedKeyknoxValue.value.byteLength) {
                            return [2 /*return*/, decryptedKeyknoxValue];
                        }
                        if (newPrivateKey) {
                            this.myPrivateKey = newPrivateKey;
                        }
                        if (newPublicKeys) {
                            this.myPublicKeys = newPublicKeys;
                        }
                        _a = this.keyknoxCrypto.encrypt(decryptedKeyknoxValue.value, this.myPrivateKey, this.myPublicKeys), metadata = _a.metadata, encryptedData = _a.encryptedData;
                        return [4 /*yield*/, this.accessTokenProvider.getToken({ operation: 'put' })];
                    case 2:
                        token = _b.sent();
                        return [4 /*yield*/, this.keyknoxClient.pushValue(metadata, encryptedData, token.toString(), decryptedKeyknoxValue.keyknoxHash)];
                    case 3:
                        encryptedKeyknoxValue = _b.sent();
                        return [2 /*return*/, this.keyknoxCrypto.decrypt(encryptedKeyknoxValue, this.myPrivateKey, this.myPublicKeys)];
                }
            });
        });
    };
    return KeyknoxManager;
}());

function serialize(cloudEntries) {
    var entries = {};
    cloudEntries.forEach(function (value, key) {
        entries[key] = {
            data: value.data.toString('base64'),
            meta: value.meta,
            creation_date: Number(value.creationDate),
            name: value.name,
            modification_date: Number(value.modificationDate),
        };
        if (entries[key].meta === null) {
            delete entries[key].meta;
        }
    });
    return Buffer.from(JSON.stringify(entries));
}
function deserialize(data) {
    if (!data.byteLength) {
        return new Map();
    }
    var serializedEntries = JSON.parse(data.toString());
    return Object.keys(serializedEntries).reduce(function (result, key) {
        var serializedEntry = serializedEntries[key];
        result.set(key, {
            name: serializedEntry.name,
            data: Buffer.from(serializedEntry.data, 'base64'),
            creationDate: new Date(serializedEntry.creation_date),
            modificationDate: new Date(serializedEntry.modification_date),
            meta: typeof serializedEntry.meta === 'undefined' ? null : serializedEntry.meta,
        });
        return result;
    }, new Map());
}

var CloudKeyStorage = /** @class */ (function () {
    function CloudKeyStorage(keyknoxManager) {
        this.cache = new Map();
        this.syncWasCalled = false;
        this.keyknoxManager = keyknoxManager;
    }
    CloudKeyStorage.create = function (options) {
        var keyknoxManager = new KeyknoxManager(options.accessTokenProvider, options.privateKey, options.publicKeys);
        return new CloudKeyStorage(keyknoxManager);
    };
    CloudKeyStorage.prototype.storeEntries = function (keyEntries) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.throwUnlessSyncWasCalled();
                        keyEntries.forEach(function (keyEntry) {
                            _this.throwIfCloudEntryExists(keyEntry.name);
                            _this.cache.set(keyEntry.name, CloudKeyStorage.createCloudEntry(keyEntry));
                        });
                        return [4 /*yield*/, this.pushCacheEntries()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, keyEntries.map(function (keyEntry) { return _this.cache.get(keyEntry.name); })];
                }
            });
        });
    };
    CloudKeyStorage.prototype.storeEntry = function (name, data, meta) {
        return __awaiter(this, void 0, void 0, function () {
            var cloudEntry;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.storeEntries([{ name: name, data: data, meta: meta }])];
                    case 1:
                        cloudEntry = (_a.sent())[0];
                        return [2 /*return*/, cloudEntry];
                }
            });
        });
    };
    CloudKeyStorage.prototype.updateEntry = function (name, data, meta) {
        return __awaiter(this, void 0, void 0, function () {
            var cloudEntry;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.throwUnlessSyncWasCalled();
                        this.throwUnlessCloudEntryExists(name);
                        cloudEntry = CloudKeyStorage.createCloudEntry({ name: name, data: data, meta: meta }, this.cache.get(name).creationDate);
                        this.cache.set(name, cloudEntry);
                        return [4 /*yield*/, this.pushCacheEntries()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, cloudEntry];
                }
            });
        });
    };
    CloudKeyStorage.prototype.retrieveEntry = function (name) {
        this.throwUnlessSyncWasCalled();
        this.throwUnlessCloudEntryExists(name);
        return this.cache.get(name);
    };
    CloudKeyStorage.prototype.retrieveAllEntries = function () {
        this.throwUnlessSyncWasCalled();
        return Array.from(this.cache.values());
    };
    CloudKeyStorage.prototype.existsEntry = function (name) {
        this.throwUnlessSyncWasCalled();
        return this.cache.has(name);
    };
    CloudKeyStorage.prototype.deleteEntry = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.deleteEntries([name])];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    CloudKeyStorage.prototype.deleteEntries = function (names) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.throwUnlessSyncWasCalled();
                        names.forEach(function (name) {
                            _this.throwUnlessCloudEntryExists(name);
                            _this.cache.delete(name);
                        });
                        return [4 /*yield*/, this.pushCacheEntries()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    CloudKeyStorage.prototype.deleteAllEntries = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.cache.clear();
                        _a = this;
                        return [4 /*yield*/, this.keyknoxManager.resetValue()];
                    case 1:
                        _a.decryptedKeyknoxValue = _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    CloudKeyStorage.prototype.updateRecipients = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var newPrivateKey, newPublicKeys, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.throwUnlessSyncWasCalled();
                        newPrivateKey = options.newPrivateKey, newPublicKeys = options.newPublicKeys;
                        _a = this;
                        return [4 /*yield*/, this.keyknoxManager.updateRecipients({
                                newPrivateKey: newPrivateKey,
                                newPublicKeys: newPublicKeys,
                            })];
                    case 1:
                        _a.decryptedKeyknoxValue = _b.sent();
                        this.cache = deserialize(this.decryptedKeyknoxValue.value);
                        return [2 /*return*/];
                }
            });
        });
    };
    CloudKeyStorage.prototype.retrieveCloudEntries = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this;
                        return [4 /*yield*/, this.keyknoxManager.pullValue()];
                    case 1:
                        _a.decryptedKeyknoxValue = _b.sent();
                        this.cache = deserialize(this.decryptedKeyknoxValue.value);
                        this.syncWasCalled = true;
                        return [2 /*return*/];
                }
            });
        });
    };
    CloudKeyStorage.prototype.throwUnlessSyncWasCalled = function () {
        if (!this.syncWasCalled) {
            throw new CloudKeyStorageOutOfSyncError();
        }
    };
    CloudKeyStorage.prototype.throwUnlessCloudEntryExists = function (entryName) {
        if (!this.cache.has(entryName)) {
            throw new CloudEntryDoesntExistError(entryName);
        }
    };
    CloudKeyStorage.prototype.throwIfCloudEntryExists = function (entryName) {
        if (this.cache.has(entryName)) {
            throw new CloudEntryExistsError(entryName);
        }
    };
    CloudKeyStorage.prototype.pushCacheEntries = function () {
        return __awaiter(this, void 0, void 0, function () {
            var value, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        value = serialize(this.cache);
                        _a = this;
                        return [4 /*yield*/, this.keyknoxManager.pushValue(value, this.decryptedKeyknoxValue.keyknoxHash)];
                    case 1:
                        _a.decryptedKeyknoxValue = _b.sent();
                        this.cache = deserialize(this.decryptedKeyknoxValue.value);
                        return [2 /*return*/];
                }
            });
        });
    };
    CloudKeyStorage.createCloudEntry = function (keyEntry, creationDate) {
        var now = new Date();
        return {
            name: keyEntry.name,
            data: keyEntry.data,
            meta: typeof keyEntry.meta === 'undefined' ? null : keyEntry.meta,
            creationDate: creationDate || now,
            modificationDate: now,
        };
    };
    return CloudKeyStorage;
}());

var KeyEntryStorageWrapper = /** @class */ (function () {
    function KeyEntryStorageWrapper(identity, keyEntryStorage) {
        var _this = this;
        this.formatKeyEntry = function (keyEntry) {
            return __assign({}, keyEntry, { name: keyEntry.name.replace(_this.prefix, '') });
        };
        this.prefix = "_VIRGIL_IDENTITY=" + identity + ".";
        this.prefixRegExp = new RegExp("^" + this.prefix);
        this.keyEntryStorage = keyEntryStorage;
    }
    KeyEntryStorageWrapper.prototype.save = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var keyEntry;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.keyEntryStorage.save(__assign({}, params, { name: this.getKeyEntryName(params.name) }))];
                    case 1:
                        keyEntry = _a.sent();
                        return [2 /*return*/, this.formatKeyEntry(keyEntry)];
                }
            });
        });
    };
    KeyEntryStorageWrapper.prototype.load = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            var keyEntry;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.keyEntryStorage.load(this.getKeyEntryName(name))];
                    case 1:
                        keyEntry = _a.sent();
                        if (keyEntry === null) {
                            return [2 /*return*/, null];
                        }
                        return [2 /*return*/, this.formatKeyEntry(keyEntry)];
                }
            });
        });
    };
    KeyEntryStorageWrapper.prototype.exists = function (name) {
        return this.keyEntryStorage.exists(this.getKeyEntryName(name));
    };
    KeyEntryStorageWrapper.prototype.remove = function (name) {
        return this.keyEntryStorage.remove(this.getKeyEntryName(name));
    };
    KeyEntryStorageWrapper.prototype.list = function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyEntries;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getAllKeyEntries()];
                    case 1:
                        keyEntries = _a.sent();
                        return [2 /*return*/, keyEntries.map(this.formatKeyEntry)];
                }
            });
        });
    };
    KeyEntryStorageWrapper.prototype.update = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var keyEntry;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.keyEntryStorage.update(__assign({}, params, { name: this.getKeyEntryName(params.name) }))];
                    case 1:
                        keyEntry = _a.sent();
                        return [2 /*return*/, this.formatKeyEntry(keyEntry)];
                }
            });
        });
    };
    KeyEntryStorageWrapper.prototype.clear = function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyEntries, _i, keyEntries_1, keyEntry;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getAllKeyEntries()];
                    case 1:
                        keyEntries = _a.sent();
                        _i = 0, keyEntries_1 = keyEntries;
                        _a.label = 2;
                    case 2:
                        if (!(_i < keyEntries_1.length)) return [3 /*break*/, 5];
                        keyEntry = keyEntries_1[_i];
                        return [4 /*yield*/, this.keyEntryStorage.remove(keyEntry.name)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        _i++;
                        return [3 /*break*/, 2];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    KeyEntryStorageWrapper.prototype.getKeyEntryName = function (name) {
        return "" + this.prefix + name;
    };
    KeyEntryStorageWrapper.prototype.getAllKeyEntries = function () {
        return __awaiter(this, void 0, void 0, function () {
            var keyEntries;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.keyEntryStorage.list()];
                    case 1:
                        keyEntries = _a.sent();
                        return [2 /*return*/, keyEntries.filter(function (keyEntry) { return _this.prefixRegExp.test(keyEntry.name); })];
                }
            });
        });
    };
    return KeyEntryStorageWrapper;
}());

var creationDateKey = 'k_cda';
var modificationDateKey = 'k_mda';
function createKeyEntry(cloudEntry) {
    var _a;
    return {
        name: cloudEntry.name,
        value: cloudEntry.data,
        meta: __assign({}, cloudEntry.meta, (_a = {}, _a[creationDateKey] = cloudEntry.creationDate.toISOString(), _a[modificationDateKey] = cloudEntry.modificationDate.toISOString(), _a)),
    };
}
function extractDate(keyEntry) {
    if (!keyEntry.meta) {
        throw new TypeError("Invalid 'IKeyEntry'");
    }
    var creationDate = new Date(keyEntry.meta[creationDateKey]);
    var modificationDate = new Date(keyEntry.meta[modificationDateKey]);
    return { creationDate: creationDate, modificationDate: modificationDate };
}

var SyncKeyStorage = /** @class */ (function () {
    function SyncKeyStorage(identity, cloudKeyStorage, keyEntryStorage) {
        this.cloudKeyStorage = cloudKeyStorage;
        this.keyEntryStorageWrapper = new KeyEntryStorageWrapper(identity, keyEntryStorage);
    }
    SyncKeyStorage.create = function (options) {
        var identity = options.identity, accessTokenProvider = options.accessTokenProvider, privateKey = options.privateKey, publicKeys = options.publicKeys;
        var cloudKeyStorage = CloudKeyStorage.create({ accessTokenProvider: accessTokenProvider, privateKey: privateKey, publicKeys: publicKeys });
        return new SyncKeyStorage(identity, cloudKeyStorage, options.keyEntryStorage);
    };
    SyncKeyStorage.prototype.storeEntries = function (keyEntries) {
        return __awaiter(this, void 0, void 0, function () {
            var checkRequests, cloudEntries, storeRequests;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        checkRequests = keyEntries.map(function (keyEntry) { return _this.throwIfKeyEntryExists(keyEntry.name); });
                        return [4 /*yield*/, Promise.all(checkRequests)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.cloudKeyStorage.storeEntries(keyEntries)];
                    case 2:
                        cloudEntries = _a.sent();
                        storeRequests = cloudEntries.map(function (cloudEntry) { return __awaiter(_this, void 0, void 0, function () {
                            var keyEntry;
                            return __generator(this, function (_a) {
                                keyEntry = createKeyEntry(cloudEntry);
                                return [2 /*return*/, this.keyEntryStorageWrapper.save(keyEntry)];
                            });
                        }); });
                        return [2 /*return*/, Promise.all(storeRequests)];
                }
            });
        });
    };
    SyncKeyStorage.prototype.storeEntry = function (name, data, meta) {
        return __awaiter(this, void 0, void 0, function () {
            var keyEntry;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.storeEntries([{ name: name, data: data, meta: meta }])];
                    case 1:
                        keyEntry = (_a.sent())[0];
                        return [2 /*return*/, keyEntry];
                }
            });
        });
    };
    SyncKeyStorage.prototype.updateEntry = function (name, data, meta) {
        return __awaiter(this, void 0, void 0, function () {
            var cloudEntry, keyEntry;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.throwUnlessKeyEntryExists(name)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.cloudKeyStorage.updateEntry(name, data, meta)];
                    case 2:
                        cloudEntry = _a.sent();
                        keyEntry = createKeyEntry(cloudEntry);
                        return [4 /*yield*/, this.keyEntryStorageWrapper.update(keyEntry)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    SyncKeyStorage.prototype.retrieveEntry = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.throwUnlessKeyEntryExists(name)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.keyEntryStorageWrapper.load(name)];
                }
            });
        });
    };
    SyncKeyStorage.prototype.retrieveAllEntries = function () {
        return this.keyEntryStorageWrapper.list();
    };
    SyncKeyStorage.prototype.existsEntry = function (name) {
        return this.keyEntryStorageWrapper.exists(name);
    };
    SyncKeyStorage.prototype.deleteEntry = function (name) {
        return this.deleteEntries([name]);
    };
    SyncKeyStorage.prototype.deleteEntries = function (names) {
        return __awaiter(this, void 0, void 0, function () {
            var deleteRequests;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.cloudKeyStorage.deleteEntries(names)];
                    case 1:
                        _a.sent();
                        deleteRequests = names.map(function (name) { return _this.keyEntryStorageWrapper.remove(name); });
                        return [4 /*yield*/, Promise.all(deleteRequests)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    SyncKeyStorage.prototype.deleteAllEntries = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.cloudKeyStorage.deleteAllEntries()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.keyEntryStorageWrapper.clear()];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    SyncKeyStorage.prototype.updateRecipients = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var newPrivateKey, newPublicKeys;
            return __generator(this, function (_a) {
                newPrivateKey = options.newPrivateKey, newPublicKeys = options.newPublicKeys;
                return [2 /*return*/, this.cloudKeyStorage.updateRecipients({ newPrivateKey: newPrivateKey, newPublicKeys: newPublicKeys })];
            });
        });
    };
    SyncKeyStorage.prototype.sync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var cloudEntries, cloudEntriesMap, keyEntries, keyEntriesMap, storeNames, updateNames, deleteNames;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.cloudKeyStorage.retrieveCloudEntries()];
                    case 1:
                        _a.sent();
                        cloudEntries = this.cloudKeyStorage.retrieveAllEntries();
                        cloudEntriesMap = cloudEntries.reduce(function (result, cloudEntry) {
                            result[cloudEntry.name] = cloudEntry;
                            return result;
                        }, {});
                        return [4 /*yield*/, this.keyEntryStorageWrapper.list()];
                    case 2:
                        keyEntries = _a.sent();
                        keyEntriesMap = keyEntries.reduce(function (result, keyEntry) {
                            result[keyEntry.name] = keyEntry;
                            return result;
                        }, {});
                        storeNames = [];
                        updateNames = [];
                        deleteNames = [];
                        cloudEntries.forEach(function (cloudEntry) {
                            var keyEntry = keyEntriesMap[cloudEntry.name];
                            if (keyEntry) {
                                var modificationDate = extractDate(keyEntry).modificationDate;
                                if (cloudEntry.modificationDate > modificationDate) {
                                    return updateNames.push(cloudEntry.name);
                                }
                            }
                            else {
                                storeNames.push(cloudEntry.name);
                            }
                        });
                        keyEntries.forEach(function (keyEntry) {
                            if (!cloudEntriesMap[keyEntry.name]) {
                                deleteNames.push(keyEntry.name);
                            }
                        });
                        return [2 /*return*/, this.syncKeyStorage(storeNames, updateNames, deleteNames)];
                }
            });
        });
    };
    SyncKeyStorage.prototype.throwUnlessKeyEntryExists = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            var exists;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.keyEntryStorageWrapper.exists(name)];
                    case 1:
                        exists = _a.sent();
                        if (!exists) {
                            throw new KeyEntryDoesntExistError(name);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    SyncKeyStorage.prototype.throwIfKeyEntryExists = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            var exists;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.keyEntryStorageWrapper.exists(name)];
                    case 1:
                        exists = _a.sent();
                        if (exists) {
                            throw new KeyEntryExistsError(name);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    SyncKeyStorage.prototype.syncKeyStorage = function (storeNames, updateNames, deleteNames) {
        return __awaiter(this, void 0, void 0, function () {
            var deleteRequests, updateRequests, storeRequests;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        deleteRequests = deleteNames.map(function (name) { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.keyEntryStorageWrapper.remove(name)];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                        updateRequests = updateNames.map(function (name) { return __awaiter(_this, void 0, void 0, function () {
                            var cloudEntry, keyEntry;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        cloudEntry = this.cloudKeyStorage.retrieveEntry(name);
                                        keyEntry = createKeyEntry(cloudEntry);
                                        return [4 /*yield*/, this.keyEntryStorageWrapper.update(keyEntry)];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                        storeRequests = storeNames.map(function (name) { return __awaiter(_this, void 0, void 0, function () {
                            var cloudEntry, keyEntry;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        cloudEntry = this.cloudKeyStorage.retrieveEntry(name);
                                        keyEntry = createKeyEntry(cloudEntry);
                                        return [4 /*yield*/, this.keyEntryStorageWrapper.save(keyEntry)];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                        return [4 /*yield*/, Promise.all(deleteRequests.concat(updateRequests, storeRequests))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return SyncKeyStorage;
}());

var buffer = Buffer;

export { buffer as Buffer, KeyknoxClient, KeyknoxCrypto, CloudKeyStorage, KeyknoxManager, SyncKeyStorage, KeyknoxError, KeyknoxClientError, CloudKeyStorageOutOfSyncError, CloudEntryExistsError, CloudEntryDoesntExistError, KeyEntryExistsError, KeyEntryDoesntExistError };
