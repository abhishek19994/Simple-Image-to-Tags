import * as lib from '../virgil_crypto_node.node';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/**
 * Custom Error class.
 * @hidden
 */
var VirgilCryptoError = /** @class */ (function (_super) {
    __extends(VirgilCryptoError, _super);
    function VirgilCryptoError(message, name) {
        if (name === void 0) { name = 'VirgilCryptoError'; }
        var _this = _super.call(this) || this;
        Object.setPrototypeOf(_this, VirgilCryptoError.prototype);
        _this.message = message;
        _this.name = name;
        return _this;
    }
    VirgilCryptoError.prototype.toString = function () {
        return this.name + ": " + this.message + ".";
    };
    return VirgilCryptoError;
}(Error));
/**
 * An error that is thrown when digital signature validation fails
 * during {@link IVirgilCrypto.decryptThenVerify} method execution.
 */
var IntegrityCheckFailedError = /** @class */ (function (_super) {
    __extends(IntegrityCheckFailedError, _super);
    function IntegrityCheckFailedError(message) {
        return _super.call(this, message, 'IntegrityCheckFailedError') || this;
    }
    return IntegrityCheckFailedError;
}(VirgilCryptoError));
/**
 * An error that is thrown when weak key material is passed to the
 * {@link IVirgilCrypto.generateKeysFromKeyMaterial} method.
 * The key material is considered weak if it's less than 32 bytes.
 */
var WeakKeyMaterialError = /** @class */ (function (_super) {
    __extends(WeakKeyMaterialError, _super);
    function WeakKeyMaterialError(message) {
        return _super.call(this, message, 'WeakKeyMaterialError') || this;
    }
    return WeakKeyMaterialError;
}(VirgilCryptoError));

/**
 * Hash algorithms supported by Virgil Crypto.
 */
var HashAlgorithm;
(function (HashAlgorithm) {
    HashAlgorithm["MD5"] = "MD5";
    HashAlgorithm["SHA1"] = "SHA1";
    HashAlgorithm["SHA224"] = "SHA224";
    HashAlgorithm["SHA256"] = "SHA256";
    HashAlgorithm["SHA384"] = "SHA384";
    HashAlgorithm["SHA512"] = "SHA512";
})(HashAlgorithm || (HashAlgorithm = {}));

/**
 * Key algorithms supported by Virgil Crypto.
 */
var KeyPairType;
(function (KeyPairType) {
    /** Ed25519 */
    KeyPairType["Default"] = "FAST_EC_ED25519";
    /** RSA 2048 bit */
    KeyPairType["RSA_2048"] = "RSA_2048";
    /** RSA 3072 bit */
    KeyPairType["RSA_3072"] = "RSA_3072";
    /** RSA 4096 bit */
    KeyPairType["RSA_4096"] = "RSA_4096";
    /** RSA 8192 bit */
    KeyPairType["RSA_8192"] = "RSA_8192";
    /** 256-bits NIST curve */
    KeyPairType["EC_SECP256R1"] = "EC_SECP256R1";
    /** 384-bits NIST curve */
    KeyPairType["EC_SECP384R1"] = "EC_SECP384R1";
    /** 521-bits NIST curve */
    KeyPairType["EC_SECP521R1"] = "EC_SECP521R1";
    /** 256-bits Brainpool curve */
    KeyPairType["EC_BP256R1"] = "EC_BP256R1";
    /** 384-bits Brainpool curve */
    KeyPairType["EC_BP384R1"] = "EC_BP384R1";
    /** 512-bits Brainpool curve */
    KeyPairType["EC_BP512R1"] = "EC_BP512R1";
    /** 256-bits "Koblitz" curve */
    KeyPairType["EC_SECP256K1"] = "EC_SECP256K1";
    /** Curve25519 as ECP deprecated format. */
    KeyPairType["EC_CURVE25519"] = "EC_CURVE25519";
    /** Curve25519 */
    KeyPairType["FAST_EC_X25519"] = "FAST_EC_X25519";
    /** Ed25519 */
    KeyPairType["FAST_EC_ED25519"] = "FAST_EC_ED25519";
})(KeyPairType || (KeyPairType = {}));

var apply = Function.prototype.apply;
var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;
/**
 * Creates a wrapper object for the native library `lib`.
 *
 * @hidden
 *
 * @param {any} lib - Native VirgilCrypto library (browser or Node.js).
 * @returns {NativeTypeWrapper} The wrapper object.
 */
function createNativeTypeWrapper(lib$$1) {
    var utils = createUtils(lib$$1);
    return {
        createSafeInstanceMethods: createSafeInstanceMethods,
        createSafeStaticMethods: createSafeStaticMethods,
        utils: utils
    };
    function createSafeInstanceMethods(ctor, methods) {
        var proto;
        {
            proto = Object.getPrototypeOf(ctor.prototype);
        }
        methods.forEach(function (method) {
            if (!(method in proto) || typeof proto[method] !== 'function') {
                throw new TypeError("Method \"" + method + "\" does not exist on " + ctor.name + " prototype");
            }
            // cannot replace the method on the prototype as there are additional properties
            // associated with class prototype methods generated by emscripten
            // cannot replace the prototype either as it is used for reference
            // equality check during construction of instances (e.g. new VirgilHash()
            // fails if we replace the `VirgilHash.prototype` with a custom object)
            proto[method + 'Safe'] = wrapNativeFunction(proto[method]);
        });
    }
    function createSafeStaticMethods(ctor, methods) {
        methods.forEach(function (method) {
            if (!hasOwn.call(ctor, method) || typeof ctor[method] !== 'function') {
                throw new TypeError("Method \"" + method + "\" does not exist on " + ctor.name);
            }
            // adding Safe suffix for consistency with instance methods
            ctor[method + 'Safe'] = wrapNativeFunction(ctor[method], ctor);
        });
    }
    function wrapNativeFunction(fn, target) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var transformedArgs = [];
            for (var i = 0; i < args.length; i++) {
                if (utils.isBuffer(args[i])) {
                    var arr = utils.bufferToVirgilByteArray(args[i]);
                    transformedArgs[i] = arr;
                }
                else {
                    transformedArgs[i] = args[i];
                }
            }
            var result;
            try {
                result = apply.call(fn, target || this, transformedArgs);
                if (utils.isVirgilByteArray(result)) {
                    result = utils.virgilByteArrayToBuffer(result);
                }
                return result;
            }
            finally {
            }
        };
    }
}
function createUtils(lib$$1) {
    return {
        isBuffer: function (obj) {
            return Buffer.isBuffer(obj);
        },
        bufferToVirgilByteArray: function (buffer) {
            {
                var array = new lib$$1.VirgilByteArray(buffer.byteLength);
                for (var i = 0; i < buffer.length; ++i) {
                    array.set(i, buffer[i]);
                }
                return array;
            }
        },
        isVirgilByteArray: function (obj) {
            {
                if (obj == null) {
                    return false;
                }
                var tag = toString.call(obj);
                return tag === '[object _exports_VirgilByteArray]' || tag === '[object VirgilByteArray]';
            }
        },
        virgilByteArrayToBuffer: function (byteArray) {
            var size = byteArray.size();
            // using `allocUnsafe` for additional performance
            // as this method is used a lot
            var buffer = Buffer.allocUnsafe(size);
            for (var i = 0; i < size; ++i) {
                buffer[i] = byteArray.get(i);
            }
            return buffer;
        }
    };
}

/**
 * Converts `val` to an array. If `val` is already an array, it is returned as is.
 * @hidden
 * @param {T[] | T} val - Value to convert.
 * @returns {T[]} Converted array
 */
function toArray(val) {
    return val == null
        ? []
        : Array.isArray(val) ? val : [val];
}

/**
 * Key used to embed Data Signature into ASN.1 structure.
 * Used in `signThenEncrypt` & `decryptThenVerify`.
 *
 * @hidden
 *
 * @type {string}
 */
var DATA_SIGNATURE_KEY = 'VIRGIL-DATA-SIGNATURE';
/**
 * Key used to embed signer identifier into ASN.1 structure.
 * Used in signThenEncrypt & decryptThenVerify
 *
 * @hidden
 *
 * @type {string}
 */
var DATA_SIGNER_ID_KEY = 'VIRGIL-DATA-SIGNER-ID';

var EMPTY_BUFFER = Buffer.alloc(0);
/**
 * Creates a low level API wrapper for "native" Virgil Crypto library
 * referenced by `lib`.
 *
 * @hidden
 *
 * @param {any} lib - Native Virgil Crypto library (browser or Node.js)
 */
function createCryptoWrapper(lib$$1) {
    var wrapper = createNativeTypeWrapper(lib$$1);
    wrapper.createSafeInstanceMethods(lib$$1.VirgilCipher, [
        'addKeyRecipient',
        'encrypt',
        'decryptWithKey',
        'addPasswordRecipient',
        'decryptWithPassword',
        'getContentInfo',
        'setContentInfo',
        'keyRecipientExists'
    ]);
    wrapper.createSafeInstanceMethods(lib$$1.VirgilSeqCipher, [
        'addKeyRecipient',
        'addPasswordRecipient',
        'startEncryption',
        'startDecryptionWithKey',
        'startDecryptionWithPassword',
        'process',
        'finish'
    ]);
    wrapper.createSafeInstanceMethods(lib$$1.VirgilSigner, ['sign', 'verify']);
    wrapper.createSafeInstanceMethods(lib$$1.VirgilSeqSigner, [
        'startSigning',
        'startVerifying',
        'update',
        'sign',
        'verify'
    ]);
    wrapper.createSafeInstanceMethods(lib$$1.VirgilHash, ['hash']);
    wrapper.createSafeInstanceMethods(lib$$1.VirgilCustomParams, ['setData', 'getData']);
    wrapper.createSafeInstanceMethods(lib$$1.VirgilKeyPair, ['privateKey', 'publicKey']);
    wrapper.createSafeStaticMethods(lib$$1.VirgilKeyPair, [
        'generate',
        'generateRecommended',
        'decryptPrivateKey',
        'encryptPrivateKey',
        'extractPublicKey',
        'privateKeyToDER',
        'publicKeyToDER',
        'resetPrivateKeyPassword',
        'generateFromKeyMaterial',
        'generateRecommendedFromKeyMaterial'
    ]);
    var createVirgilCipher = function () {
        var cipher = new lib$$1.VirgilCipher();
        return cipher;
    };
    var createVirgilSigner = function () {
        var sha512 = lib$$1.VirgilHash.Algorithm_SHA512;
        var signer = new lib$$1.VirgilSigner(sha512);
        return signer;
    };
    var createVirgilHash = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _a;
        var hash = new ((_a = lib$$1.VirgilHash).bind.apply(_a, __spread([void 0], args)))();
        return hash;
    };
    var getRandomBytes = function (numOfBytes) {
        var random = new lib$$1.VirgilRandom('');
        return wrapper.utils.virgilByteArrayToBuffer(random.randomize(numOfBytes));
    };
    return {
        generateKeyPair: function (options) {
            if (options === void 0) { options = {}; }
            var type = options.type, _a = options.password, password = _a === void 0 ? EMPTY_BUFFER : _a;
            var keyPair;
            if (type) {
                keyPair = lib$$1.VirgilKeyPair.generateSafe(getLibKeyPairType(type), password);
            }
            else {
                keyPair = lib$$1.VirgilKeyPair.generateRecommendedSafe(password);
            }
            return {
                privateKey: keyPair.privateKeySafe(),
                publicKey: keyPair.publicKeySafe()
            };
        },
        generateKeyPairFromKeyMaterial: function (options) {
            var keyMaterial = options.keyMaterial, type = options.type, _a = options.password, password = _a === void 0 ? EMPTY_BUFFER : _a;
            if (keyMaterial.byteLength < 32) {
                throw new WeakKeyMaterialError('Key material is not secure. Expected length >= 32.');
            }
            var keyPair;
            if (type) {
                keyPair = lib$$1.VirgilKeyPair.generateFromKeyMaterialSafe(getLibKeyPairType(type), keyMaterial, password);
            }
            else {
                keyPair = lib$$1.VirgilKeyPair.generateRecommendedFromKeyMaterialSafe(keyMaterial, password);
            }
            return {
                privateKey: keyPair.privateKeySafe(),
                publicKey: keyPair.publicKeySafe()
            };
        },
        privateKeyToDer: function (privateKey, privateKeyPassword) {
            if (privateKeyPassword === void 0) { privateKeyPassword = EMPTY_BUFFER; }
            return lib$$1.VirgilKeyPair.privateKeyToDERSafe(privateKey, privateKeyPassword);
        },
        publicKeyToDer: function (publicKey) {
            return lib$$1.VirgilKeyPair.publicKeyToDERSafe(publicKey);
        },
        extractPublicKey: function (privateKey, privateKeyPassword) {
            if (privateKeyPassword === void 0) { privateKeyPassword = EMPTY_BUFFER; }
            return lib$$1.VirgilKeyPair.extractPublicKeySafe(privateKey, privateKeyPassword);
        },
        encryptPrivateKey: function (privateKey, privateKeyPassword) {
            return lib$$1.VirgilKeyPair.encryptPrivateKeySafe(privateKey, privateKeyPassword);
        },
        decryptPrivateKey: function (privateKey, privateKeyPassword) {
            return lib$$1.VirgilKeyPair.decryptPrivateKeySafe(privateKey, privateKeyPassword);
        },
        changePrivateKeyPassword: function (privateKey, oldPassword, newPassword) {
            return lib$$1.VirgilKeyPair.resetPrivateKeyPasswordSafe(privateKey, oldPassword, newPassword);
        },
        hash: function (data, algorithm) {
            if (algorithm === void 0) { algorithm = HashAlgorithm.SHA256; }
            var libAlgorithm = lib$$1.VirgilHash["Algorithm_" + algorithm];
            var virgilHash = createVirgilHash(libAlgorithm);
            return virgilHash.hashSafe(data);
        },
        encryptWithPassword: function (data, password) {
            var cipher = createVirgilCipher();
            cipher.addPasswordRecipientSafe(password);
            return cipher.encryptSafe(data, true);
        },
        decryptWithPassword: function (encryptedData, password) {
            var cipher = createVirgilCipher();
            return cipher.decryptWithPasswordSafe(encryptedData, password);
        },
        encrypt: function (data, encryptionKey) {
            var encryptionKeys = toArray(encryptionKey);
            var cipher = createVirgilCipher();
            encryptionKeys.forEach(function (_a) {
                var identifier = _a.identifier, key = _a.key;
                cipher.addKeyRecipientSafe(identifier, key);
            });
            return cipher.encryptSafe(data, true);
        },
        decrypt: function (encryptedData, decryptionKey) {
            var identifier = decryptionKey.identifier, key = decryptionKey.key, _a = decryptionKey.password, password = _a === void 0 ? EMPTY_BUFFER : _a;
            var cipher = createVirgilCipher();
            return cipher.decryptWithKeySafe(encryptedData, identifier, key, password);
        },
        sign: function (data, signingKey) {
            var key = signingKey.key, _a = signingKey.password, password = _a === void 0 ? EMPTY_BUFFER : _a;
            var signer = createVirgilSigner();
            return signer.signSafe(data, key, password);
        },
        verify: function (data, signature, verificationKey) {
            var key = verificationKey.key;
            var signer = createVirgilSigner();
            return signer.verifySafe(data, signature, key);
        },
        signThenEncrypt: function (data, signingKey, encryptionKey) {
            var encryptionKeys = toArray(encryptionKey);
            var signer = createVirgilSigner();
            var cipher = createVirgilCipher();
            var signatureKey = Buffer.from(DATA_SIGNATURE_KEY);
            var signerIdKey = Buffer.from(DATA_SIGNER_ID_KEY);
            var customParams = cipher.customParams();
            var signature = signer.signSafe(data, signingKey.key, signingKey.password || EMPTY_BUFFER);
            customParams.setDataSafe(signatureKey, signature);
            if (signingKey.identifier != null) {
                customParams.setDataSafe(signerIdKey, signingKey.identifier);
            }
            encryptionKeys.forEach(function (_a) {
                var identifier = _a.identifier, key = _a.key;
                return cipher.addKeyRecipientSafe(identifier, key);
            });
            return cipher.encryptSafe(data, true);
        },
        decryptThenVerify: function (cipherData, decryptionKey, verificationKey) {
            var verificationKeys = toArray(verificationKey);
            var signer = createVirgilSigner();
            var cipher = createVirgilCipher();
            var signatureKey = Buffer.from(DATA_SIGNATURE_KEY);
            var plainData = cipher.decryptWithKeySafe(cipherData, decryptionKey.identifier, decryptionKey.key, decryptionKey.password || EMPTY_BUFFER);
            var customParams = cipher.customParams();
            var signature = customParams.getDataSafe(signatureKey);
            var isValid;
            if (verificationKeys.length === 1) {
                isValid = signer.verifySafe(plainData, signature, verificationKeys[0].key);
            }
            else {
                var signerId_1 = tryGetSignerId(customParams);
                if (signerId_1 !== null) {
                    var theKey = verificationKeys.find(function (key) { return key.identifier != null && key.identifier.equals(signerId_1); });
                    if (theKey === undefined) {
                        isValid = false;
                    }
                    else {
                        isValid = signer.verifySafe(plainData, signature, theKey.key);
                    }
                }
                else {
                    // no signer id in metadata, try all public keys in sequence
                    isValid = verificationKeys.some(function (key) { return signer.verifySafe(plainData, signature, key.key); });
                }
            }
            if (!isValid) {
                throw new IntegrityCheckFailedError('Signature verification has failed.');
            }
            return plainData;
        },
        getRandomBytes: getRandomBytes,
        signThenEncryptDetached: function (data, privateKey, publicKeys) {
            var signer = createVirgilSigner();
            var cipher = createVirgilCipher();
            var customParams = cipher.customParams();
            var signature = signer.signSafe(data, privateKey.key, privateKey.password || EMPTY_BUFFER);
            customParams.setDataSafe(Buffer.from(DATA_SIGNATURE_KEY), signature);
            customParams.setDataSafe(Buffer.from(DATA_SIGNER_ID_KEY), privateKey.identifier);
            publicKeys.forEach(function (_a) {
                var identifier = _a.identifier, key = _a.key;
                return cipher.addKeyRecipientSafe(identifier, key);
            });
            var encryptedData = cipher.encryptSafe(data, false);
            var contentInfo = cipher.getContentInfoSafe();
            return { encryptedData: encryptedData, metadata: contentInfo };
        },
        decryptThenVerifyDetached: function (encryptedData, metadata, privateKey, publicKeys) {
            var signer = createVirgilSigner();
            var cipher = createVirgilCipher();
            cipher.setContentInfoSafe(metadata);
            if (!cipher.keyRecipientExistsSafe(privateKey.identifier)) {
                throw new VirgilCryptoError('Wrong private key. The data has not been encrypted with the corresponding public key.');
            }
            var decryptedData = cipher.decryptWithKeySafe(encryptedData, privateKey.identifier, privateKey.key, privateKey.password || EMPTY_BUFFER);
            var customParams = cipher.customParams();
            var signature = customParams.getDataSafe(Buffer.from(DATA_SIGNATURE_KEY));
            var signerId = tryGetSignerId(customParams);
            if (!signerId) {
                throw new VirgilCryptoError('Signer ID not found in the cryptogram.');
            }
            var matchingPublicKey = publicKeys.find(function (k) { return k.identifier.equals(signerId); });
            if (!matchingPublicKey) {
                throw new VirgilCryptoError('Wrong public key(s). The data has not been signed with the corresponding private key(s).');
            }
            if (!signer.verifySafe(decryptedData, signature, matchingPublicKey.key)) {
                throw new IntegrityCheckFailedError('Signature verification has failed.');
            }
            return decryptedData;
        },
        createVirgilSeqCipher: function () {
            return new lib$$1.VirgilSeqCipher();
        },
        createVirgilSeqSigner: function () {
            return new lib$$1.VirgilSeqSigner();
        }
    };
    function tryGetSignerId(customParams) {
        var signerIdKey = Buffer.from(DATA_SIGNER_ID_KEY);
        try {
            return customParams.getDataSafe(signerIdKey);
        }
        catch (e) {
            return null;
        }
    }
    function getLibKeyPairType(type) {
        return lib$$1.VirgilKeyPair["Type_" + type];
    }
}

/**
 * Class implementing  cryptographic operations required to sign and
 * verify the validity of access tokens (i.e. the `IAccessTokenSigner` interface
 * from {@link https://bit.ly/2GAAH0F|virgil-sdk}),
 * using {@link VirgilCrypto}.
 */
var VirgilAccessTokenSigner = /** @class */ (function () {
    /**
     * Initializes the new `VirgilAccessTokenSigner`
     * @param {VirgilCrypto} virgilCrypto - VirgilCrypto instance, providing
     * implementation of crypto operations.
     */
    function VirgilAccessTokenSigner(virgilCrypto) {
        this.virgilCrypto = virgilCrypto;
        if (virgilCrypto == null)
            throw new Error('`virgilCrypto` is required');
    }
    /**
     * Returns an identifier of the algorithm used for signature calculation
     * and verification.
     *
     * @returns {string} The algorithm identifier. Currently 'VEDS512'
     */
    VirgilAccessTokenSigner.prototype.getAlgorithm = function () {
        return 'VEDS512';
    };
    /**
     * Generates digital signature of the given access token using the given
     * private key.
     * @param {Buffer | string} token - The access token bytes.
     * @param {IPrivateKey} privateKey - The private key object.
     * @returns {Buffer} - The signature.
     */
    VirgilAccessTokenSigner.prototype.generateTokenSignature = function (token, privateKey) {
        return this.virgilCrypto.calculateSignature(token, privateKey);
    };
    /**
     * Verifies the validity of the given signature for the given token and public key.
     * @param {Buffer | string} token - The token.
     * @param {Buffer | string} signature - The signature.
     * @param {IPublicKey} publicKey - The signer's public key.
     * @returns {boolean} - `true` if signature is valid, otherwise `false`
     */
    VirgilAccessTokenSigner.prototype.verifyTokenSignature = function (token, signature, publicKey) {
        return this.virgilCrypto.verifySignature(token, signature, publicKey);
    };
    return VirgilAccessTokenSigner;
}());

/**
 * Class implementing operations required to convert between raw
 * private key material and private key objects and vice versa
 * (i.e. the `IPrivateKeyExporter` interface from
 * {@link https://bit.ly/2KFRmT8|virgil-sdk}), using {@link VirgilCrypto}.
 */
var VirgilPrivateKeyExporter = /** @class */ (function () {
    /**
     * Initializes the new `VirgilPrivateKeyExporter`
     * @param {VirgilCrypto} virgilCrypto - VirgilCrypto instance, providing
     * implementation of crypto operations.
     * @param {string} [password] - Optional password used to encrypt the key
     * before export and decrypt before import.
     * NOTE: do NOT use the default (no password), unless your storage/transport
     * channel is secure.
     */
    function VirgilPrivateKeyExporter(virgilCrypto, password) {
        this.virgilCrypto = virgilCrypto;
        this.password = password;
        if (virgilCrypto == null)
            throw new Error('`virgilCrypto` is required');
    }
    /**
     * Exports private key material in DER format from the given private key object.
     *
     * @param {IPrivateKey} key - The private key object to export the key material from.
     * @returns {Buffer} - The private key material in DER format.
     */
    VirgilPrivateKeyExporter.prototype.exportPrivateKey = function (key) {
        return this.virgilCrypto.exportPrivateKey(key, this.password);
    };
    /**
     * Creates a {@link VirgilPrivateKey} object from private key material in PEM or DER format.
     *
     * @param {Buffer | string} keyData - The private key material. If `keyData` is
     * a string, base64 encoding is assumed.
     * @returns {VirgilPrivateKey} The private key object.
     */
    VirgilPrivateKeyExporter.prototype.importPrivateKey = function (keyData) {
        return this.virgilCrypto.importPrivateKey(keyData, this.password);
    };
    return VirgilPrivateKeyExporter;
}());

/**
 * Class implementing  cryptographic operations required to create and
 * verify the validity of Virgil Cards (i.e. the `ICardCrypto` interface
 * from {@link https://bit.ly/2GCZLnU|virgil-sdk}), using {@link VirgilCrypto}.
 */
var VirgilCardCrypto = /** @class */ (function () {
    /**
     * Initializes the new `VirgilCardCrypto`
     * @param {VirgilCrypto} virgilCrypto - VirgilCrypto instance, providing
     * implementation of crypto operations.
     */
    function VirgilCardCrypto(virgilCrypto) {
        this.virgilCrypto = virgilCrypto;
        if (virgilCrypto == null)
            throw new Error('`virgilCrypto` is required');
    }
    /**
     * Generates digital signature of the given data using the given private key.
     *
     * @param {Buffer | string} data - The data to be signed.
     * @param {IPrivateKey} privateKey - The private key object.
     * @returns {Buffer} - The signature data.
     */
    VirgilCardCrypto.prototype.generateSignature = function (data, privateKey) {
        return this.virgilCrypto.calculateSignature(data, privateKey);
    };
    /**
     * Verifies the validity of the digital signature for the given data and public key.
     *
     * @param {Buffer | string} data - The data that were signed.
     * @param {Buffer | string} signature - The signature.
     * @param {IPublicKey} publicKey - The signer's public key.
     * @returns {boolean} - `true` if signature is valid, otherwise `false`
     */
    VirgilCardCrypto.prototype.verifySignature = function (data, signature, publicKey) {
        return this.virgilCrypto.verifySignature(data, signature, publicKey);
    };
    /**
     * Exports public key material in DER format from the given public key object.
     *
     * @param {IPublicKey} publicKey - The public key object to export the key material from.
     * @returns {Buffer} - The public key material in DER format.
     */
    VirgilCardCrypto.prototype.exportPublicKey = function (publicKey) {
        return this.virgilCrypto.exportPublicKey(publicKey);
    };
    /**
     * Creates a {@link VirgilPublicKey} object from public key material in PEM or DER format.
     *
     * @param {Buffer | string} publicKeyData - The public key material. If `publicKeyData` is
     * a string, base64 encoding is assumed.
     * @returns {VirgilPublicKey} The public key object.
     */
    VirgilCardCrypto.prototype.importPublicKey = function (publicKeyData) {
        return this.virgilCrypto.importPublicKey(publicKeyData);
    };
    /**
     * Computes SHA-512 hash of the given data.
     * @param {Buffer | string} data - The data to be hashed.
     * @returns {Buffer} - The resulting hash value.
     */
    VirgilCardCrypto.prototype.generateSha512 = function (data) {
        return this.virgilCrypto.calculateHash(data, HashAlgorithm.SHA512);
    };
    return VirgilCardCrypto;
}());

/**
 * String decoding utilities.
 */
var encoding = {
    /**
     * Decodes the base64-encoded string and returns `Buffer`.
     * @param {string} str - The string to decode.
     * @returns {Buffer}
     */
    base64ToBytes: function (str) {
        return Buffer.from(str, 'base64');
    },
    /**
     * Decodes the hex string and returns `Buffer`.
     * @param {string} str - The string to decode.
     * @returns {Buffer}
     */
    hexToBytes: function (str) {
        return Buffer.from(str, 'hex');
    },
    /**
     * Decodes the utf8 string and returns `Buffer`.
     * @param {string} str - The string to decode.
     * @returns {Buffer}
     */
    stringToBytes: function (str) {
        return Buffer.from(str, 'utf8');
    }
};

var privateKeys = new WeakMap();
var setValue = WeakMap.prototype.set;
var getValue = WeakMap.prototype.get;
var hasValue = WeakMap.prototype.has;
/**
 * Gets the private key bytes of the given private key object from internal store.
 * @param {VirgilPrivateKey} privateKey - Private key object.
 * @returns {Buffer} - Private key bytes.
 *
 * @hidden
 */
function getPrivateKeyBytes(privateKey) {
    return getValue.call(privateKeys, privateKey);
}
/**
 * Saves the private key bytes corresponding to the given private key object into
 * internal buffer.
 *
 * @param {VirgilPrivateKey} privateKey - Private key object.
 * @param {Buffer} bytes - Private key bytes.
 *
 * @hidden
 */
function setPrivateKeyBytes(privateKey, bytes) {
    setValue.call(privateKeys, privateKey, bytes);
}
/**
 * Checks if the private key bytes corresponding to the given private key
 * object exist in the internal buffer.
 *
 * @hidden
 *
 * @param { VirgilPrivateKey } privateKey - Private key object.
 *
 * @returns {boolean}
 */
function hasPrivateKeyBytes(privateKey) {
    return hasValue.call(privateKeys, privateKey);
}

/**
 * Represents a private key for operations with {@link VirgilCrypto}.
 *
 * `VirgilPrivateKey` objects are not meant to be created directly using the `new` keyword.
 * Use the {@link VirgilCrypto.generateKeys} and {@link VirgilCrypto.importPrivateKey} methods
 * to create `VirgilPrivateKey` instances.
 *
 * @protected
 */
var VirgilPrivateKey = /** @class */ (function () {
    function VirgilPrivateKey(identifier, key) {
        this.identifier = identifier;
        setPrivateKeyBytes(this, key);
    }
    return VirgilPrivateKey;
}());

/**
 * Represents a public key for operations with {@link VirgilCrypto}.
 *
 * `VirgilPublicKey` objects are not meant to be created directly using the `new` keyword.
 * Use the {@link VirgilCrypto.generateKeys} and {@link VirgilCrypto.importPublicKey} methods
 * to create `VirgilPublicKey` instances.
 *
 * @protected
 */
var VirgilPublicKey = /** @class */ (function () {
    function VirgilPublicKey(identifier, key) {
        this.identifier = identifier;
        this.key = key;
    }
    return VirgilPublicKey;
}());

/**
 * Attempts to convert the given `value` to Buffer. Throws a `TypeError` if the
 * `value` cannot be converted.
 *
 * @hidden
 *
 * @param {string | Buffer | ArrayBuffer} value - The value to convert.
 *
 * If `value` is Buffer, it is used as is, without copying the underlying memory.
 *
 * If `value` is ArrayBuffer, creates a view if the ArrayBuffer without copying
 * the underlying memory.
 *
 * @param {string} encoding - If `value` is a string, specifies its encoding,
 * otherwise is ignored.
 * @param {string} [label] - The name of the argument to include in error message
 * in case when the value cannot be converted to Buffer.
 * @returns {Buffer}
 */
function anyToBuffer(value, encoding, label) {
    if (label === void 0) { label = 'argument'; }
    if (Buffer.isBuffer(value)) {
        return value;
    }
    if (typeof value === 'string') {
        return Buffer.from(value, encoding);
    }
    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return Buffer.from(value);
    }
    throw new TypeError("Expected `" + label + "` to be a string, Buffer or ArrayBuffer, got " + typeof value + ".");
}

// import node version, the `rollup-plugin-resolve-crypto-lib`
/**
 * @hidden
 * @type {IVirgilCryptoWrapper}
 */
var cryptoWrapper = createCryptoWrapper(lib);

/**
 * @hidden
 */
function validatePrivateKey(privateKey, label) {
    if (label === void 0) { label = 'privateKey'; }
    if (privateKey == null || !Buffer.isBuffer(privateKey.identifier) || !hasPrivateKeyBytes(privateKey)) {
        throw new TypeError("`" + label + "` is not a VirgilPrivateKey.");
    }
}
/**
 * @hidden
 */
function validatePublicKey(publicKey, label) {
    if (label === void 0) { label = 'publicKey'; }
    if (publicKey == null || !Buffer.isBuffer(publicKey.identifier) || !Buffer.isBuffer(publicKey.key)) {
        throw new TypeError("`" + label + "` is not a VirgilPublicKey.");
    }
}
/**
 * @hidden
 */
function validatePublicKeysArray(publicKeys, label) {
    if (label === void 0) { label = 'publicKeys'; }
    if (publicKeys.length === 0) {
        throw new TypeError("`" + label + "` array must not be empty.");
    }
    publicKeys.forEach(function (pubkey) { return validatePublicKey(pubkey); });
}

/**
 * @internal
 *
 * Base class for `VirgilStreamCipher` and `VirgilStreamDecipher` wrapping
 * a low-level `VirgilSeqCipher` object.
 */
var VirgilStreamCipherBase = /** @class */ (function () {
    function VirgilStreamCipherBase() {
        /**
         * Indicates whether the `final` method has been called.
         */
        this.isFinished = false;
        /**
         * Indicates whether the `dispose` method has been called.
         * This can be `true` only in browser, because of the requirement to
         * manually free the memory used by C++ class instances from virgil-crypto.
         */
        this.isDisposed = false;
        this.seqCipher = cryptoWrapper.createVirgilSeqCipher();
    }
    /**
     * Encrypt of decrypt chunk of data based on current mode.
     * @param {Data} data - Chunk of data to encrypt \ decrypt
     * @param {StringEncoding} encoding - If `data` is a string, specifies its
     * encoding, otherwise is ignored. Default is 'utf8'.
     *
     * @returns {Buffer} - Encrypted or decrypted chunk
     */
    VirgilStreamCipherBase.prototype.update = function (data, encoding) {
        if (encoding === void 0) { encoding = 'utf8'; }
        this.ensureLegalState();
        return this.seqCipher.processSafe(anyToBuffer(data, encoding));
    };
    /**
     * Returns any remaining encrypted or decrypted data depending on current
     * mode.
     * Once `final` has been called, this instance cannot be used to encrypt
     * or decrypt data, attempts to call any method including `final` will
     * result in an error being thrown.
     * This method also automatically calls `dispose`.
     */
    VirgilStreamCipherBase.prototype.final = function () {
        this.ensureLegalState();
        try {
            return this.seqCipher.finishSafe();
        }
        finally {
            this.isFinished = true;
            this.dispose();
        }
    };
    /**
     * Frees the memory occupied by {@link seqCipher} in the browser.
     * In node.js this is a noop.
     */
    VirgilStreamCipherBase.prototype.dispose = function () {
    };
    /**
     * @hidden
     */
    VirgilStreamCipherBase.prototype.ensureLegalState = function () {
        if (this.isFinished) {
            throw new Error('Illegal state. Cannot use cipher after the `final` method has been called.');
        }
        if (this.isDisposed) {
            throw new Error('Illegal state. Cannot use cipher after the `dispose` method has been called.');
        }
    };
    return VirgilStreamCipherBase;
}());

/**
 * Class responsible for encryption of streams of data.
 */
var VirgilStreamCipher = /** @class */ (function (_super) {
    __extends(VirgilStreamCipher, _super);
    /**
     * Initializes a new instance of `VirgilStreamCipher`.
     * `VirgilStreamCipher` objects are not meant to be created with the `new`
     * operator, use {@link VirgilCrypto.createStreamCipher} to create an
     * instance.
     *
     * @internal
     *
     * @param {VirgilPublicKey|VirgilPublicKey[]} publicKeys - A single
     * {@link VirgilPublicKey} or an array of {@link VirgilPublicKey}'s to
     * to encrypt the data with.
     */
    function VirgilStreamCipher(publicKeys) {
        var e_1, _a;
        var _this = this;
        var publicKeyArr = toArray(publicKeys);
        validatePublicKeysArray(publicKeyArr);
        _this = _super.call(this) || this;
        try {
            for (var publicKeyArr_1 = __values(publicKeyArr), publicKeyArr_1_1 = publicKeyArr_1.next(); !publicKeyArr_1_1.done; publicKeyArr_1_1 = publicKeyArr_1.next()) {
                var _b = publicKeyArr_1_1.value, identifier = _b.identifier, key = _b.key;
                _this.seqCipher.addKeyRecipientSafe(identifier, key);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (publicKeyArr_1_1 && !publicKeyArr_1_1.done && (_a = publicKeyArr_1.return)) _a.call(publicKeyArr_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return _this;
    }
    /**
     * Starts sequential encryption process following the algorithm below:
     *
     * 1. Generates random AES-256 key - KEY1
     * 2. Generates ephemeral keypair for each recipient public key
     * 3. Uses Diffie-Hellman to obtain shared secret with each recipient
     *    public key & ephemeral private key
     * 4. Computes KDF to obtain AES-256 key - KEY2 - from shared secret for
     *    each recipient
     * 5. Encrypts KEY1 with KEY2 using AES-256-CBC for each recipient
     * 6. Returns the ASN.1 structure containing the encrypted KEY2 for each
     *    recipient public key (content_info)
     *
     * The data passed to the {@link VirgilStreamCipher.update} method after
     * this method is called will be encrypted with the KEY1
     */
    VirgilStreamCipher.prototype.start = function () {
        this.ensureLegalState();
        return this.seqCipher.startEncryptionSafe();
    };
    return VirgilStreamCipher;
}(VirgilStreamCipherBase));

/**
 * Class responsible for decryption of streams of data.
 * Follows the same algorithm for decryption as the
 * {@link VirgilCrypto.decrypt} method.
 */
var VirgilStreamDecipher = /** @class */ (function (_super) {
    __extends(VirgilStreamDecipher, _super);
    /**
     * Initializes a new instance of `VirgilStreamDecipher`.
     * `VirgilStreamDecipher` objects are not meant to be created with the `new`
     * operator, use {@link VirgilCrypto.createStreamDecipher} to create an
     * instance.
     *
     * @internal
     *
     * @param {VirgilPrivateKey} - The {@link VirgilPrivateKey} object to be
     * used to decrypt the data.
     */
    function VirgilStreamDecipher(privateKey) {
        var _this = this;
        validatePrivateKey(privateKey);
        _this = _super.call(this) || this;
        var privateKeyValue = getPrivateKeyBytes(privateKey);
        _this.seqCipher.startDecryptionWithKeySafe(privateKey.identifier, privateKeyValue, Buffer.alloc(0));
        return _this;
    }
    return VirgilStreamDecipher;
}(VirgilStreamCipherBase));

/**
 * @internal
 * Base class for `VirgilStreamSigner` and `VirgilStreamVerifier` wrapping
 * a low-level `VirgilSeqSigner` object.
 */
var VirgilStreamSignerBase = /** @class */ (function () {
    function VirgilStreamSignerBase() {
        /**
         * Inidcates whether the `dispose` method has been called.
         */
        // tslint:disable-next-line:variable-name
        this._isDisposed = false;
        this.seqSigner = cryptoWrapper.createVirgilSeqSigner();
    }
    /**
     * Add new chunk of data to be signed or verified.
     * @param {Data} data - The chunk of data to be signed or verified.
     * @param {StringEncoding} [encoding] - If `data` is a string, specifies it's
     * encoding, otherwise is ignored. Default is 'utf8'.
     */
    VirgilStreamSignerBase.prototype.update = function (data, encoding) {
        if (encoding === void 0) { encoding = 'utf8'; }
        if (this.isDisposed()) {
            throw new Error('Illegal state. Cannot use signer after the `dispose` method has been called.');
        }
        this.seqSigner.updateSafe(anyToBuffer(data, encoding));
        return this;
    };
    /**
     * Frees the memory occupied by {@link seqSigner} in the browser.
     * In node.js this is a noop.
     */
    VirgilStreamSignerBase.prototype.dispose = function () {
    };
    /**
     * @hidden
     */
    VirgilStreamSignerBase.prototype.isDisposed = function () {
        return this._isDisposed;
    };
    return VirgilStreamSignerBase;
}());

/**
 * Class responsible for generating signatures of streams of data.
 */
var VirgilStreamSigner = /** @class */ (function (_super) {
    __extends(VirgilStreamSigner, _super);
    /**
     * Initializes a new instance of `VirgilStreamSigner`.
     * `VirgilStreamSigner` objects are not meant to be created with the `new`
     * operator, use {@link VirgilCrypto.createStreamSigner} to create an instance.
     *
     * @internal
     */
    function VirgilStreamSigner() {
        var _this = _super.call(this) || this;
        _this.seqSigner.startSigningSafe();
        return _this;
    }
    /**
     * Signs the data collected by {@link VirgilStreamSigner.update} method
     * and returns the signature.
     *
     * @param {VirgilPrivateKey} privateKey - The private key to use to
     * calculate the signature.
     * @param {boolen} [final] - Optional. Indicating whether to automatically
     * free the memory occupied by internal {@link seqSigner} object in the
     * browser.
     * Default is `true`. Pass `false` if you need to calculate more than one
     * signature of the same data with different keys.
     *
     * In node.js this argument is ignored because the memory will be freed by the
     * garbage collector.
     *
     * @returns {Buffer} The signature
     */
    VirgilStreamSigner.prototype.sign = function (privateKey, final) {
        if (final === void 0) { final = true; }
        if (this.isDisposed()) {
            throw new Error('Illegal state. The VirgilStreamSigner has been disposed. ' +
                'Pass `false` as the second argument to the `sign` method ' +
                'if you need to generate more than one signature.');
        }
        validatePrivateKey(privateKey);
        var privateKeyValue = getPrivateKeyBytes(privateKey);
        try {
            return this.seqSigner.signSafe(privateKeyValue, Buffer.alloc(0));
        }
        finally {
            if (final) {
                this.dispose();
            }
        }
    };
    return VirgilStreamSigner;
}(VirgilStreamSignerBase));

/**
 * Class responsible for verifying signatures of streams of data.
 */
var VirgilStreamVerifier = /** @class */ (function (_super) {
    __extends(VirgilStreamVerifier, _super);
    /**
     * Initializes a new instance of `VirgilStreamVerifier`.
     * `VirgilStreamVerifier` objects are not meant to be created with the `new`
     * operator, use {@link VirgilCrypto.createStreamVerifier} to create an instance.
     *
     * @internal
     *
     * @param {Data} signature = The signature to be verified.
     * @param {StringEncoding} [encoding] - If `signature` is a string,
     * specifies its encoding, otherwise is ignored. Default is 'utf8'.
     */
    function VirgilStreamVerifier(signature, encoding) {
        if (encoding === void 0) { encoding = 'base64'; }
        var _this = this;
        var signatureBuf = anyToBuffer(signature, encoding, 'signature');
        _this = _super.call(this) || this;
        _this.seqSigner.startVerifyingSafe(signatureBuf);
        return _this;
    }
    /**
     * Verifies the validity of the signature for the data collected by the
     * {@link VirgilStreamVerifier.update} method and the given public key.
     *
     * @param {VirgilPublicKey} publicKey - The public key to use to verify
     * the signature.
     * @param {boolean} [final] - Optional. Indicating whether to automatically
     * free the memory occupied by internal {@link seqSigner} object in the
     * browser.
     * Default is `true`. Pass `false` if you need to verify the signature
     * with more than one public key.
     *
     * In node.js this argument is ignored because the memory will be freed by the
     * garbage collector.
     *
     * @returns {boolean} `true` if signature is valid, otherwise `false`
     */
    VirgilStreamVerifier.prototype.verify = function (publicKey, final) {
        if (final === void 0) { final = true; }
        if (this.isDisposed()) {
            throw new Error('Illegal state. The VirgilStreamVerifier has been disposed. ' +
                'Pass `false` as the second argument to the `verify` method ' +
                'if you need to verify with more than one public key.');
        }
        validatePublicKey(publicKey);
        try {
            return this.seqSigner.verifySafe(publicKey.key);
        }
        finally {
            if (final) {
                this.dispose();
            }
        }
    };
    return VirgilStreamVerifier;
}(VirgilStreamSignerBase));

/**
 * Provides implementation of high-level cryptographic operations using Virgil Crypto Library.
 */
var VirgilCrypto = /** @class */ (function () {
    /**
     * Initializes a new instance of {@link VirgilCrypto}.
     *
     * @param {Object} [options]
     * @param {boolean} [options.useSha256Identifiers]
     * @param {KeyPairType} [options.defaultKeyPairType]
     */
    function VirgilCrypto(_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.useSha256Identifiers, useSha256Identifiers = _c === void 0 ? false : _c, _d = _b.defaultKeyPairType, defaultKeyPairType = _d === void 0 ? KeyPairType.Default : _d;
        this.useSha256Identifiers = useSha256Identifiers;
        this.defaultKeyPairType = defaultKeyPairType;
    }
    /**
     * Generates a new key pair.
     *
     * @param {KeyPairType} [keyPairType] - Optional type of the key pair.
     * See {@link KeyPairType} for available options. Default is Ed25519.
     * @returns {KeyPair} - The newly generated key pair.
     * */
    VirgilCrypto.prototype.generateKeys = function (type) {
        var keyPairType = type != null ? type : this.defaultKeyPairType;
        var keyPair = cryptoWrapper.generateKeyPair({ type: keyPairType });
        return this.wrapKeyPair(keyPair);
    };
    /**
     * Generates a new key pair from the given key material.
     * @param {Data} keyMaterial - The data to be used for key generation,
     * must be strong enough (have high entropy). If `keyMaterial` is a
     * string, base64 encoding is assumed.
     * @param {KeyPairType} [type] - Optional type of the key pair.
     * See {@link KeyPairType} for available options. Default is Ed25519.
     * @returns {VirgilKeyPair}
     */
    VirgilCrypto.prototype.generateKeysFromKeyMaterial = function (keyMaterial, type) {
        var keyPairType = type != null ? type : this.defaultKeyPairType;
        var keyMaterialBuf = anyToBuffer(keyMaterial, 'base64', 'keyMaterial');
        var keyPair = cryptoWrapper.generateKeyPairFromKeyMaterial({
            keyMaterial: keyMaterialBuf,
            type: keyPairType
        });
        return this.wrapKeyPair(keyPair);
    };
    /**
     * Creates a `VirgilPrivateKey` object from private key bytes in PEM or DER format.
     *
     * @param {Data} rawPrivateKey - The private key bytes. If `rawPrivateKey` is a
     * string, base64 encoding is assumed.
     * @param {string} [password] - Optional password the key bytes are encrypted with.
     *
     * @returns {VirgilPrivateKey} - The private key object.
     * */
    VirgilCrypto.prototype.importPrivateKey = function (rawPrivateKey, password) {
        var rawPrivateKeyBuf = anyToBuffer(rawPrivateKey, 'base64', 'rawPrivateKey');
        if (password) {
            rawPrivateKeyBuf = cryptoWrapper.decryptPrivateKey(rawPrivateKeyBuf, Buffer.from(password, 'utf8'));
        }
        var privateKeyDer = cryptoWrapper.privateKeyToDer(rawPrivateKeyBuf);
        var publicKeyDer = cryptoWrapper.extractPublicKey(privateKeyDer);
        var identifier = this.calculateKeypairIdentifier(publicKeyDer);
        return new VirgilPrivateKey(identifier, privateKeyDer);
    };
    /**
     * Exports private key material in DER format from the given private key object.
     *
     * @param {VirgilPrivateKey} privateKey - The private key object.
     * @param {string} [password] - Optional password to encrypt the key material with.
     *
     * @returns {Buffer} - The private key material in DER format.
     * */
    VirgilCrypto.prototype.exportPrivateKey = function (privateKey, password) {
        validatePrivateKey(privateKey);
        var privateKeyValue = getPrivateKeyBytes(privateKey);
        if (password == null) {
            return privateKeyValue;
        }
        return cryptoWrapper.encryptPrivateKey(privateKeyValue, Buffer.from(password, 'utf8'));
    };
    /**
     * Creates a `VirgilPublicKey` object from public key material in PEM or DER format.
     *
     * @param {Data} rawPublicKey - The public key bytes. If `rawPublicKey` is a
     * string, base64 encoding is assumed.
     *
     * @returns {VirgilPublicKey} - The imported key handle.
     * */
    VirgilCrypto.prototype.importPublicKey = function (rawPublicKey) {
        var rawPublicKeyBuf = anyToBuffer(rawPublicKey, 'base64', 'rawPublicKey');
        var publicKeyDer = cryptoWrapper.publicKeyToDer(rawPublicKeyBuf);
        var identifier = this.calculateKeypairIdentifier(publicKeyDer);
        return new VirgilPublicKey(identifier, publicKeyDer);
    };
    /**
     * Exports public key material in DER format from the given public key object.
     *
     * @param {VirgilPublicKey} publicKey - The public key object.
     *
     * @returns {Buffer} - The public key bytes.
     * */
    VirgilCrypto.prototype.exportPublicKey = function (publicKey) {
        validatePublicKey(publicKey);
        return publicKey.key;
    };
    /**
     * Encrypts the data for the given public key(s) following the algorithm below:
     *
     * 1. Generates random AES-256 key - KEY1
     * 2. Encrypts the data with KEY1 using AES-256-GCM
     * 3. Generates ephemeral keypair for each recipient public key
     * 4. Uses Diffie-Hellman to obtain shared secret with each recipient public key & ephemeral private key
     * 5. Computes KDF to obtain AES-256 key - KEY2 - from shared secret for each recipient
     * 6. Encrypts KEY1 with KEY2 using AES-256-CBC for each recipient
     *
     * @param {Data} data - The data to be encrypted. If `data` is a
     * string, utf-8 encoding is assumed.
     * @param {VirgilPublicKey|VirgilPublicKey[]} publicKey - Public key or an array of public keys
     * of the intended recipients.
     *
     * @returns {Buffer} - Encrypted data.
     * */
    VirgilCrypto.prototype.encrypt = function (data, publicKey) {
        var dataBuf = anyToBuffer(data, 'utf8', 'data');
        var publicKeys = toArray(publicKey);
        validatePublicKeysArray(publicKeys);
        return cryptoWrapper.encrypt(dataBuf, publicKeys);
    };
    /**
     * Decrypts the data with the given private key following the algorithm below:
     *
     * 1. Uses Diffie-Hellman to obtain shared secret with sender ephemeral public key & the `privateKey`
     * 2. Computes KDF to obtain AES-256 KEY2 from shared secret
     * 3. Decrypts KEY1 using AES-256-CBC and KEY2
     * 4. Decrypts data using KEY1 and AES-256-GCM
     *
     * @param {Data} encryptedData - The data to be decrypted. If `encryptedData` is a
     * string, base64 encoding is assumed.
     * @param {VirgilPrivateKey} privateKey - The private key to decrypt with.
     *
     * @returns {Buffer} - Decrypted data
     * */
    VirgilCrypto.prototype.decrypt = function (encryptedData, privateKey) {
        var encryptedDataBuf = anyToBuffer(encryptedData, 'base64', 'encryptedData');
        validatePrivateKey(privateKey);
        var privateKeyValue = getPrivateKeyBytes(privateKey);
        return cryptoWrapper.decrypt(encryptedDataBuf, {
            identifier: privateKey.identifier,
            key: privateKeyValue
        });
    };
    /**
     * Calculates the hash of the given data.
     *
     * @param {Data} data - The data to calculate the hash of. If `data` is a
     * string, utf-8 encoding is assumed.
     * @param {string} [algorithm] - Optional name of the hash algorithm to use.
     * See {@link HashAlgorithm} for available options. Default is SHA256.
     *
     * @returns {Buffer} - The hash.
     * */
    VirgilCrypto.prototype.calculateHash = function (data, algorithm) {
        if (algorithm === void 0) { algorithm = HashAlgorithm.SHA256; }
        var dataBuf = anyToBuffer(data, 'utf8', 'data');
        return cryptoWrapper.hash(dataBuf, algorithm);
    };
    /**
     * Extracts a public key from the private key handle.
     *
     * @param {VirgilPrivateKey} privateKey - The private key object to extract from.
     *
     * @returns {VirgilPublicKey} - The handle to the extracted public key.
     * */
    VirgilCrypto.prototype.extractPublicKey = function (privateKey) {
        validatePrivateKey(privateKey);
        var privateKeyValue = getPrivateKeyBytes(privateKey);
        var publicKey = cryptoWrapper.extractPublicKey(privateKeyValue);
        return new VirgilPublicKey(privateKey.identifier, publicKey);
    };
    /**
     * Calculates the signature of the data using the private key.
     *
     * NOTE: Returned value contains only digital signature, not data itself.
     *
     * NOTE: Data inside this function is guaranteed to be hashed with SHA512 at least one time.
     *
     * It's secure to pass raw data here.
     *
     * @param {Data} data - The data to be signed. If `data` is a
     * string, utf-8 encoding is assumed.
     * @param {VirgilPrivateKey} privateKey - The private key object.
     *
     * @returns {Buffer} - The signature.
     * */
    VirgilCrypto.prototype.calculateSignature = function (data, privateKey) {
        var dataBuf = anyToBuffer(data, 'utf8', 'data');
        validatePrivateKey(privateKey);
        var privateKeyValue = getPrivateKeyBytes(privateKey);
        return cryptoWrapper.sign(dataBuf, { key: privateKeyValue });
    };
    /**
     * Verifies the provided data using the given signature and public key.
     * Note: Verification algorithm depends on PublicKey type. Default: EdDSA
     *
     * @param {Data} data - The data to be verified. If `data` is a
     * string, utf-8 encoding is assumed.
     * @param {Data} signature - The signature to verify. If `signature` is a
     * string, base64 encoding is assumed.
     * @param {VirgilPublicKey} publicKey - The public key object.
     *
     * @returns {boolean} - True or False depending on the validity of the signature for the data
     * and public key.
     * */
    VirgilCrypto.prototype.verifySignature = function (data, signature, publicKey) {
        var dataBuf = anyToBuffer(data, 'utf8', 'data');
        var signatureBuf = anyToBuffer(signature, 'base64', 'signature');
        validatePublicKey(publicKey);
        return cryptoWrapper.verify(dataBuf, signatureBuf, publicKey);
    };
    /**
     * Calculates the signature on the data using the private key,
     * then encrypts the data along with the signature using the public key(s).
     *
     * 1. Generates signature depending on the type of private key
     * 2. Generates random AES-256 key - KEY1
     * 3. Encrypts both data and signature with KEY1 using AES-256-GCM
     * 4. Generates ephemeral key pair for each recipient
     * 5. Uses Diffie-Hellman to obtain shared secret with each recipient's public key & each ephemeral private key
     * 6. Computes KDF to obtain AES-256 key - KEY2 - from shared secret for each recipient
     * 7. Encrypts KEY1 with KEY2 using AES-256-CBC for each recipient
     *
     * @param {Data} data - The data to sign and encrypt. If `data` is a
     * string, utf-8 encoding is assumed.
     * @param {VirgilPrivateKey} privateKey - The private key to use to calculate signature.
     * @param {VirgilPublicKey|VirgilPublicKey[]} publicKey - The public key of the intended recipient or an array
     * of public keys of multiple recipients.
     *
     * @returns {Buffer} - Encrypted data with attached signature.
     * */
    VirgilCrypto.prototype.signThenEncrypt = function (data, privateKey, publicKey) {
        var dataBuf = anyToBuffer(data, 'utf8', 'data');
        validatePrivateKey(privateKey);
        var privateKeyBytes = getPrivateKeyBytes(privateKey);
        var publicKeys = toArray(publicKey);
        validatePublicKeysArray(publicKeys);
        return cryptoWrapper.signThenEncrypt(dataBuf, {
            identifier: privateKey.identifier,
            key: privateKeyBytes
        }, publicKeys);
    };
    /**
     * Decrypts the data using the private key, then verifies decrypted data
     * using the attached signature and the given public key.
     *
     * 1. Uses Diffie-Hellman to obtain shared secret with sender ephemeral public key & recipient's private key
     * 2. Computes KDF to obtain AES-256 key - KEY2 - from shared secret
     * 3. Decrypts KEY1 using AES-256-CBC and KEY2
     * 4. Decrypts both data and signature using KEY1 and AES-256-GCM
     * 5. Verifies signature
     *
     * @param {Data} encryptedData - The data to be decrypted and verified. If `encryptedData` is a
     * string, base64 encoding is assumed.
     * @param {VirgilPrivateKey} privateKey - The private key object to use for decryption.
     *
     * @param {(VirgilPublicKey|VirgilPublicKey[])} publicKey - The public key object
     * or an array of public key objects to use to verify data integrity. If `publicKey`
     * is an array, the attached signature must be valid for any one of them.
     *
     * @returns {Buffer} - Decrypted data iff verification is successful,
     * otherwise throws {@link IntegrityCheckFailedError}.
     * */
    VirgilCrypto.prototype.decryptThenVerify = function (encryptedData, privateKey, publicKey) {
        var cipherDataBuf = anyToBuffer(encryptedData, 'base64', 'encryptedData');
        var publicKeys = toArray(publicKey);
        validatePublicKeysArray(publicKeys);
        validatePrivateKey(privateKey);
        var privateKeyBytes = getPrivateKeyBytes(privateKey);
        return cryptoWrapper.decryptThenVerify(cipherDataBuf, {
            identifier: privateKey.identifier,
            key: privateKeyBytes
        }, publicKeys);
    };
    /**
     * Generates a pseudo-random sequence of bytes of the given length.
     * @param {number} length - The number of bytes to generate.
     * @returns {Buffer}
     */
    VirgilCrypto.prototype.getRandomBytes = function (length) {
        return cryptoWrapper.getRandomBytes(length);
    };
    /**
     * Same as {@link IVirgilCrypto.signThenEncrypt} but returns the metadata (i.e. public
     * algorithm parameters used for encryption) as a separate property on the response
     * object rather than embedded in the encrypted data as regular `signThenEncrypt` does.
     *
     * @param {Data} data - The data to sign and encrypt. If `data` is a
     * string, utf-8 encoding is assumed.
     * @param {VirgilPrivateKey} privateKey - The private key to use to calculate signature.
     * @param {VirgilPublicKey | VirgilPublicKey[]} publicKey - The public key of the intended
     * recipient or an array of public keys of multiple recipients.
     * @returns {{encryptedData: Buffer; metadata: Buffer}} - Encrypted data and metadata.
     */
    VirgilCrypto.prototype.signThenEncryptDetached = function (data, privateKey, publicKey) {
        var dataBuf = anyToBuffer(data, 'utf8', 'data');
        validatePrivateKey(privateKey);
        var privateKeyBytes = getPrivateKeyBytes(privateKey);
        var publicKeys = toArray(publicKey);
        validatePublicKeysArray(publicKeys);
        return cryptoWrapper.signThenEncryptDetached(dataBuf, {
            identifier: privateKey.identifier,
            key: privateKeyBytes
        }, publicKeys);
    };
    /**
     * Same as {@link IVirgilCrypto.decryptThenVerify} but expects the Virgil Cryptogram
     * (the content info) to be passed as `contentInfo` parameter instead of be embedded
     * in the `encryptedData`.
     * @param {Data} encryptedData - The data to be decrypted and verified. If `encryptedData`
     * is a string, base64 encoding is assumed.
     * @param {Data} metadata - The metadata (i.e. public  algorithm parameters used for
     * encryption) required for decryption.
     * @param {VirgilPrivateKey} privateKey - The private key object to use for decryption.
     * @param {VirgilPublicKey | VirgilPublicKey[]} publicKey - The public key object
     * or an array of public key objects to use to verify data integrity. If the public key
     * identifier specified in `metadata` does not correspond to the `publicKey` argument
     * (or any of the keys in the `publicKey` array), an error is thrown.
     * @returns {Buffer} - Decrypted data iff verification is successful,
     * otherwise throws {@link IntegrityCheckFailedError}.
     */
    VirgilCrypto.prototype.decryptThenVerifyDetached = function (encryptedData, metadata, privateKey, publicKey) {
        var encryptedDataBuf = anyToBuffer(encryptedData, 'base64', 'encryptedData');
        var metadataBuf = anyToBuffer(metadata, 'base64', 'contentInfo');
        var publicKeys = toArray(publicKey);
        validatePublicKeysArray(publicKeys);
        validatePrivateKey(privateKey);
        var privateKeyBytes = getPrivateKeyBytes(privateKey);
        return cryptoWrapper.decryptThenVerifyDetached(encryptedDataBuf, metadataBuf, {
            identifier: privateKey.identifier,
            key: privateKeyBytes
        }, publicKeys);
    };
    /**
     * Creates an instance of {@link VirgilStreamCipher} to be used
     * to encrypt data in chunks using the given `publicKey`.
     * @param {VirgilPublicKey|VirgilPublicKey[]} publicKey - A signle
     * public key or an array of public keys to encrypt the data with.
     */
    VirgilCrypto.prototype.createStreamCipher = function (publicKey) {
        return new VirgilStreamCipher(publicKey);
    };
    /**
     * Creates an instance of {@link VirgilStreamDecipher} to be used
     * to decrypt data in chunks using the given `privateKey`.
     * @param {VirgilPrivateKey} privateKey - The private key to decrypt
     * the data with.
     */
    VirgilCrypto.prototype.createStreamDecipher = function (privateKey) {
        return new VirgilStreamDecipher(privateKey);
    };
    /**
     * Creates an instance of {@link VirgilStreamSigner} to be used
     * to calculate signature of data in chunks.
     */
    VirgilCrypto.prototype.createStreamSigner = function () {
        return new VirgilStreamSigner();
    };
    /**
     * Creates an instance of {@link VirgilStreamVerifier} to be used
     * to verify the `signature` for the data in comming in chunks.
     *
     * @param {Data} signature - The signature to be verified.
     * @param {StringEncoding} encoding - If `signature` is a string,
     * specifies its encoding, otherwise is ignored. Default is 'utf8'.
     */
    VirgilCrypto.prototype.createStreamVerifier = function (signature, encoding) {
        return new VirgilStreamVerifier(signature, encoding);
    };
    /**
     * Calculates the keypair identifier form the public key material.
     * Takes first 8 bytes of SHA512 of public key DER if `useSHA256Identifiers=false`
     * and SHA256 of public key der if `useSHA256Identifiers=true`
     *
     * @hidden
     *
     * @param {Buffer} publicKeyData - Public key material.
     * @returns {Buffer} Key pair identifier
     */
    VirgilCrypto.prototype.calculateKeypairIdentifier = function (publicKeyData) {
        if (this.useSha256Identifiers) {
            return cryptoWrapper.hash(publicKeyData, HashAlgorithm.SHA256);
        }
        return cryptoWrapper.hash(publicKeyData, HashAlgorithm.SHA512).slice(0, 8);
    };
    /**
     * Wraps binary private and public keys into {@link VirgilKeyPair} object.
     *
     * @hidden
     *
     * @param {KeyPair} keyPair
     * @returns {VirgilKeyPair}
     */
    VirgilCrypto.prototype.wrapKeyPair = function (keyPair) {
        var privateKeyDer = cryptoWrapper.privateKeyToDer(keyPair.privateKey);
        var publicKeyDer = cryptoWrapper.publicKeyToDer(keyPair.publicKey);
        var identifier = this.calculateKeypairIdentifier(publicKeyDer);
        return {
            privateKey: new VirgilPrivateKey(identifier, privateKeyDer),
            publicKey: new VirgilPublicKey(identifier, publicKeyDer)
        };
    };
    return VirgilCrypto;
}());

export { KeyPairType, HashAlgorithm, VirgilAccessTokenSigner, VirgilPrivateKeyExporter, VirgilCardCrypto, encoding, VirgilPrivateKey, VirgilPublicKey, VirgilCrypto };
