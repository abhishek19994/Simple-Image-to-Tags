(function (global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
            typeof define === 'function' && define.amd ? define(['exports'], factory) :
            (factory((global.VirgilPythia = {})));
}(this, (function (exports) { 'use strict';

            var global$1 = (typeof global !== "undefined" ? global :
                        typeof self !== "undefined" ? self :
                        typeof window !== "undefined" ? window : {});

            var lookup = [];
            var revLookup = [];
            var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
            var inited = false;
            function init () {
              inited = true;
              var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
              for (var i = 0, len = code.length; i < len; ++i) {
                lookup[i] = code[i];
                revLookup[code.charCodeAt(i)] = i;
              }

              revLookup['-'.charCodeAt(0)] = 62;
              revLookup['_'.charCodeAt(0)] = 63;
            }

            function toByteArray (b64) {
              if (!inited) {
                init();
              }
              var i, j, l, tmp, placeHolders, arr;
              var len = b64.length;

              if (len % 4 > 0) {
                throw new Error('Invalid string. Length must be a multiple of 4')
              }

              // the number of equal signs (place holders)
              // if there are two placeholders, than the two characters before it
              // represent one byte
              // if there is only one, then the three characters before it represent 2 bytes
              // this is just a cheap hack to not do indexOf twice
              placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

              // base64 is 4/3 + up to two characters of the original data
              arr = new Arr(len * 3 / 4 - placeHolders);

              // if there are placeholders, only get up to the last complete 4 chars
              l = placeHolders > 0 ? len - 4 : len;

              var L = 0;

              for (i = 0, j = 0; i < l; i += 4, j += 3) {
                tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
                arr[L++] = (tmp >> 16) & 0xFF;
                arr[L++] = (tmp >> 8) & 0xFF;
                arr[L++] = tmp & 0xFF;
              }

              if (placeHolders === 2) {
                tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
                arr[L++] = tmp & 0xFF;
              } else if (placeHolders === 1) {
                tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
                arr[L++] = (tmp >> 8) & 0xFF;
                arr[L++] = tmp & 0xFF;
              }

              return arr
            }

            function tripletToBase64 (num) {
              return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
            }

            function encodeChunk (uint8, start, end) {
              var tmp;
              var output = [];
              for (var i = start; i < end; i += 3) {
                tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
                output.push(tripletToBase64(tmp));
              }
              return output.join('')
            }

            function fromByteArray (uint8) {
              if (!inited) {
                init();
              }
              var tmp;
              var len = uint8.length;
              var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
              var output = '';
              var parts = [];
              var maxChunkLength = 16383; // must be multiple of 3

              // go through the array every three bytes, we'll deal with trailing stuff later
              for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
              }

              // pad the end with zeros, but make sure to not forget the extra bytes
              if (extraBytes === 1) {
                tmp = uint8[len - 1];
                output += lookup[tmp >> 2];
                output += lookup[(tmp << 4) & 0x3F];
                output += '==';
              } else if (extraBytes === 2) {
                tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
                output += lookup[tmp >> 10];
                output += lookup[(tmp >> 4) & 0x3F];
                output += lookup[(tmp << 2) & 0x3F];
                output += '=';
              }

              parts.push(output);

              return parts.join('')
            }

            function read (buffer, offset, isLE, mLen, nBytes) {
              var e, m;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var nBits = -7;
              var i = isLE ? (nBytes - 1) : 0;
              var d = isLE ? -1 : 1;
              var s = buffer[offset + i];

              i += d;

              e = s & ((1 << (-nBits)) - 1);
              s >>= (-nBits);
              nBits += eLen;
              for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

              m = e & ((1 << (-nBits)) - 1);
              e >>= (-nBits);
              nBits += mLen;
              for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

              if (e === 0) {
                e = 1 - eBias;
              } else if (e === eMax) {
                return m ? NaN : ((s ? -1 : 1) * Infinity)
              } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
              }
              return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
            }

            function write (buffer, value, offset, isLE, mLen, nBytes) {
              var e, m, c;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
              var i = isLE ? 0 : (nBytes - 1);
              var d = isLE ? 1 : -1;
              var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

              value = Math.abs(value);

              if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
              } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                  e--;
                  c *= 2;
                }
                if (e + eBias >= 1) {
                  value += rt / c;
                } else {
                  value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                  e++;
                  c /= 2;
                }

                if (e + eBias >= eMax) {
                  m = 0;
                  e = eMax;
                } else if (e + eBias >= 1) {
                  m = (value * c - 1) * Math.pow(2, mLen);
                  e = e + eBias;
                } else {
                  m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                  e = 0;
                }
              }

              for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

              e = (e << mLen) | m;
              eLen += mLen;
              for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

              buffer[offset + i - d] |= s * 128;
            }

            var toString = {}.toString;

            var isArray = Array.isArray || function (arr) {
              return toString.call(arr) == '[object Array]';
            };

            var INSPECT_MAX_BYTES = 50;

            /**
             * If `Buffer.TYPED_ARRAY_SUPPORT`:
             *   === true    Use Uint8Array implementation (fastest)
             *   === false   Use Object implementation (most compatible, even IE6)
             *
             * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
             * Opera 11.6+, iOS 4.2+.
             *
             * Due to various browser bugs, sometimes the Object implementation will be used even
             * when the browser supports typed arrays.
             *
             * Note:
             *
             *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
             *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
             *
             *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
             *
             *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
             *     incorrect length in some situations.

             * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
             * get the Object implementation, which is slower but behaves correctly.
             */
            Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
              ? global$1.TYPED_ARRAY_SUPPORT
              : true;

            function kMaxLength () {
              return Buffer.TYPED_ARRAY_SUPPORT
                ? 0x7fffffff
                : 0x3fffffff
            }

            function createBuffer (that, length) {
              if (kMaxLength() < length) {
                throw new RangeError('Invalid typed array length')
              }
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                // Return an augmented `Uint8Array` instance, for best performance
                that = new Uint8Array(length);
                that.__proto__ = Buffer.prototype;
              } else {
                // Fallback: Return an object instance of the Buffer class
                if (that === null) {
                  that = new Buffer(length);
                }
                that.length = length;
              }

              return that
            }

            /**
             * The Buffer constructor returns instances of `Uint8Array` that have their
             * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
             * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
             * and the `Uint8Array` methods. Square bracket notation works as expected -- it
             * returns a single octet.
             *
             * The `Uint8Array` prototype remains unmodified.
             */

            function Buffer (arg, encodingOrOffset, length) {
              if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
                return new Buffer(arg, encodingOrOffset, length)
              }

              // Common case.
              if (typeof arg === 'number') {
                if (typeof encodingOrOffset === 'string') {
                  throw new Error(
                    'If encoding is specified then the first argument must be a string'
                  )
                }
                return allocUnsafe(this, arg)
              }
              return from(this, arg, encodingOrOffset, length)
            }

            Buffer.poolSize = 8192; // not used by this implementation

            // TODO: Legacy, not needed anymore. Remove in next major version.
            Buffer._augment = function (arr) {
              arr.__proto__ = Buffer.prototype;
              return arr
            };

            function from (that, value, encodingOrOffset, length) {
              if (typeof value === 'number') {
                throw new TypeError('"value" argument must not be a number')
              }

              if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
                return fromArrayBuffer(that, value, encodingOrOffset, length)
              }

              if (typeof value === 'string') {
                return fromString(that, value, encodingOrOffset)
              }

              return fromObject(that, value)
            }

            /**
             * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
             * if value is a number.
             * Buffer.from(str[, encoding])
             * Buffer.from(array)
             * Buffer.from(buffer)
             * Buffer.from(arrayBuffer[, byteOffset[, length]])
             **/
            Buffer.from = function (value, encodingOrOffset, length) {
              return from(null, value, encodingOrOffset, length)
            };

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              Buffer.prototype.__proto__ = Uint8Array.prototype;
              Buffer.__proto__ = Uint8Array;
            }

            function assertSize (size) {
              if (typeof size !== 'number') {
                throw new TypeError('"size" argument must be a number')
              } else if (size < 0) {
                throw new RangeError('"size" argument must not be negative')
              }
            }

            function alloc (that, size, fill, encoding) {
              assertSize(size);
              if (size <= 0) {
                return createBuffer(that, size)
              }
              if (fill !== undefined) {
                // Only pay attention to encoding if it's a string. This
                // prevents accidentally sending in a number that would
                // be interpretted as a start offset.
                return typeof encoding === 'string'
                  ? createBuffer(that, size).fill(fill, encoding)
                  : createBuffer(that, size).fill(fill)
              }
              return createBuffer(that, size)
            }

            /**
             * Creates a new filled Buffer instance.
             * alloc(size[, fill[, encoding]])
             **/
            Buffer.alloc = function (size, fill, encoding) {
              return alloc(null, size, fill, encoding)
            };

            function allocUnsafe (that, size) {
              assertSize(size);
              that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
              if (!Buffer.TYPED_ARRAY_SUPPORT) {
                for (var i = 0; i < size; ++i) {
                  that[i] = 0;
                }
              }
              return that
            }

            /**
             * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
             * */
            Buffer.allocUnsafe = function (size) {
              return allocUnsafe(null, size)
            };
            /**
             * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
             */
            Buffer.allocUnsafeSlow = function (size) {
              return allocUnsafe(null, size)
            };

            function fromString (that, string, encoding) {
              if (typeof encoding !== 'string' || encoding === '') {
                encoding = 'utf8';
              }

              if (!Buffer.isEncoding(encoding)) {
                throw new TypeError('"encoding" must be a valid string encoding')
              }

              var length = byteLength(string, encoding) | 0;
              that = createBuffer(that, length);

              var actual = that.write(string, encoding);

              if (actual !== length) {
                // Writing a hex string, for example, that contains invalid characters will
                // cause everything after the first invalid character to be ignored. (e.g.
                // 'abxxcd' will be treated as 'ab')
                that = that.slice(0, actual);
              }

              return that
            }

            function fromArrayLike (that, array) {
              var length = array.length < 0 ? 0 : checked(array.length) | 0;
              that = createBuffer(that, length);
              for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255;
              }
              return that
            }

            function fromArrayBuffer (that, array, byteOffset, length) {
              array.byteLength; // this throws if `array` is not a valid ArrayBuffer

              if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError('\'offset\' is out of bounds')
              }

              if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError('\'length\' is out of bounds')
              }

              if (byteOffset === undefined && length === undefined) {
                array = new Uint8Array(array);
              } else if (length === undefined) {
                array = new Uint8Array(array, byteOffset);
              } else {
                array = new Uint8Array(array, byteOffset, length);
              }

              if (Buffer.TYPED_ARRAY_SUPPORT) {
                // Return an augmented `Uint8Array` instance, for best performance
                that = array;
                that.__proto__ = Buffer.prototype;
              } else {
                // Fallback: Return an object instance of the Buffer class
                that = fromArrayLike(that, array);
              }
              return that
            }

            function fromObject (that, obj) {
              if (internalIsBuffer(obj)) {
                var len = checked(obj.length) | 0;
                that = createBuffer(that, len);

                if (that.length === 0) {
                  return that
                }

                obj.copy(that, 0, 0, len);
                return that
              }

              if (obj) {
                if ((typeof ArrayBuffer !== 'undefined' &&
                    obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
                  if (typeof obj.length !== 'number' || isnan(obj.length)) {
                    return createBuffer(that, 0)
                  }
                  return fromArrayLike(that, obj)
                }

                if (obj.type === 'Buffer' && isArray(obj.data)) {
                  return fromArrayLike(that, obj.data)
                }
              }

              throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
            }

            function checked (length) {
              // Note: cannot use `length < kMaxLength()` here because that fails when
              // length is NaN (which is otherwise coerced to zero.)
              if (length >= kMaxLength()) {
                throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                                     'size: 0x' + kMaxLength().toString(16) + ' bytes')
              }
              return length | 0
            }
            Buffer.isBuffer = isBuffer;
            function internalIsBuffer (b) {
              return !!(b != null && b._isBuffer)
            }

            Buffer.compare = function compare (a, b) {
              if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
                throw new TypeError('Arguments must be Buffers')
              }

              if (a === b) return 0

              var x = a.length;
              var y = b.length;

              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                  x = a[i];
                  y = b[i];
                  break
                }
              }

              if (x < y) return -1
              if (y < x) return 1
              return 0
            };

            Buffer.isEncoding = function isEncoding (encoding) {
              switch (String(encoding).toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'latin1':
                case 'binary':
                case 'base64':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return true
                default:
                  return false
              }
            };

            Buffer.concat = function concat (list, length) {
              if (!isArray(list)) {
                throw new TypeError('"list" argument must be an Array of Buffers')
              }

              if (list.length === 0) {
                return Buffer.alloc(0)
              }

              var i;
              if (length === undefined) {
                length = 0;
                for (i = 0; i < list.length; ++i) {
                  length += list[i].length;
                }
              }

              var buffer = Buffer.allocUnsafe(length);
              var pos = 0;
              for (i = 0; i < list.length; ++i) {
                var buf = list[i];
                if (!internalIsBuffer(buf)) {
                  throw new TypeError('"list" argument must be an Array of Buffers')
                }
                buf.copy(buffer, pos);
                pos += buf.length;
              }
              return buffer
            };

            function byteLength (string, encoding) {
              if (internalIsBuffer(string)) {
                return string.length
              }
              if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
                  (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                return string.byteLength
              }
              if (typeof string !== 'string') {
                string = '' + string;
              }

              var len = string.length;
              if (len === 0) return 0

              // Use a for loop to avoid recursion
              var loweredCase = false;
              for (;;) {
                switch (encoding) {
                  case 'ascii':
                  case 'latin1':
                  case 'binary':
                    return len
                  case 'utf8':
                  case 'utf-8':
                  case undefined:
                    return utf8ToBytes(string).length
                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return len * 2
                  case 'hex':
                    return len >>> 1
                  case 'base64':
                    return base64ToBytes(string).length
                  default:
                    if (loweredCase) return utf8ToBytes(string).length // assume utf8
                    encoding = ('' + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer.byteLength = byteLength;

            function slowToString (encoding, start, end) {
              var loweredCase = false;

              // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
              // property of a typed array.

              // This behaves neither like String nor Uint8Array in that we set start/end
              // to their upper/lower bounds if the value passed is out of range.
              // undefined is handled specially as per ECMA-262 6th Edition,
              // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
              if (start === undefined || start < 0) {
                start = 0;
              }
              // Return early if start > this.length. Done here to prevent potential uint32
              // coercion fail below.
              if (start > this.length) {
                return ''
              }

              if (end === undefined || end > this.length) {
                end = this.length;
              }

              if (end <= 0) {
                return ''
              }

              // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
              end >>>= 0;
              start >>>= 0;

              if (end <= start) {
                return ''
              }

              if (!encoding) encoding = 'utf8';

              while (true) {
                switch (encoding) {
                  case 'hex':
                    return hexSlice(this, start, end)

                  case 'utf8':
                  case 'utf-8':
                    return utf8Slice(this, start, end)

                  case 'ascii':
                    return asciiSlice(this, start, end)

                  case 'latin1':
                  case 'binary':
                    return latin1Slice(this, start, end)

                  case 'base64':
                    return base64Slice(this, start, end)

                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return utf16leSlice(this, start, end)

                  default:
                    if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                    encoding = (encoding + '').toLowerCase();
                    loweredCase = true;
                }
              }
            }

            // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
            // Buffer instances.
            Buffer.prototype._isBuffer = true;

            function swap (b, n, m) {
              var i = b[n];
              b[n] = b[m];
              b[m] = i;
            }

            Buffer.prototype.swap16 = function swap16 () {
              var len = this.length;
              if (len % 2 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 16-bits')
              }
              for (var i = 0; i < len; i += 2) {
                swap(this, i, i + 1);
              }
              return this
            };

            Buffer.prototype.swap32 = function swap32 () {
              var len = this.length;
              if (len % 4 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 32-bits')
              }
              for (var i = 0; i < len; i += 4) {
                swap(this, i, i + 3);
                swap(this, i + 1, i + 2);
              }
              return this
            };

            Buffer.prototype.swap64 = function swap64 () {
              var len = this.length;
              if (len % 8 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 64-bits')
              }
              for (var i = 0; i < len; i += 8) {
                swap(this, i, i + 7);
                swap(this, i + 1, i + 6);
                swap(this, i + 2, i + 5);
                swap(this, i + 3, i + 4);
              }
              return this
            };

            Buffer.prototype.toString = function toString () {
              var length = this.length | 0;
              if (length === 0) return ''
              if (arguments.length === 0) return utf8Slice(this, 0, length)
              return slowToString.apply(this, arguments)
            };

            Buffer.prototype.equals = function equals (b) {
              if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
              if (this === b) return true
              return Buffer.compare(this, b) === 0
            };

            Buffer.prototype.inspect = function inspect () {
              var str = '';
              var max = INSPECT_MAX_BYTES;
              if (this.length > 0) {
                str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
                if (this.length > max) str += ' ... ';
              }
              return '<Buffer ' + str + '>'
            };

            Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
              if (!internalIsBuffer(target)) {
                throw new TypeError('Argument must be a Buffer')
              }

              if (start === undefined) {
                start = 0;
              }
              if (end === undefined) {
                end = target ? target.length : 0;
              }
              if (thisStart === undefined) {
                thisStart = 0;
              }
              if (thisEnd === undefined) {
                thisEnd = this.length;
              }

              if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError('out of range index')
              }

              if (thisStart >= thisEnd && start >= end) {
                return 0
              }
              if (thisStart >= thisEnd) {
                return -1
              }
              if (start >= end) {
                return 1
              }

              start >>>= 0;
              end >>>= 0;
              thisStart >>>= 0;
              thisEnd >>>= 0;

              if (this === target) return 0

              var x = thisEnd - thisStart;
              var y = end - start;
              var len = Math.min(x, y);

              var thisCopy = this.slice(thisStart, thisEnd);
              var targetCopy = target.slice(start, end);

              for (var i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                  x = thisCopy[i];
                  y = targetCopy[i];
                  break
                }
              }

              if (x < y) return -1
              if (y < x) return 1
              return 0
            };

            // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
            // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
            //
            // Arguments:
            // - buffer - a Buffer to search
            // - val - a string, Buffer, or number
            // - byteOffset - an index into `buffer`; will be clamped to an int32
            // - encoding - an optional encoding, relevant is val is a string
            // - dir - true for indexOf, false for lastIndexOf
            function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
              // Empty buffer means no match
              if (buffer.length === 0) return -1

              // Normalize byteOffset
              if (typeof byteOffset === 'string') {
                encoding = byteOffset;
                byteOffset = 0;
              } else if (byteOffset > 0x7fffffff) {
                byteOffset = 0x7fffffff;
              } else if (byteOffset < -0x80000000) {
                byteOffset = -0x80000000;
              }
              byteOffset = +byteOffset;  // Coerce to Number.
              if (isNaN(byteOffset)) {
                // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                byteOffset = dir ? 0 : (buffer.length - 1);
              }

              // Normalize byteOffset: negative offsets start from the end of the buffer
              if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
              if (byteOffset >= buffer.length) {
                if (dir) return -1
                else byteOffset = buffer.length - 1;
              } else if (byteOffset < 0) {
                if (dir) byteOffset = 0;
                else return -1
              }

              // Normalize val
              if (typeof val === 'string') {
                val = Buffer.from(val, encoding);
              }

              // Finally, search either indexOf (if dir is true) or lastIndexOf
              if (internalIsBuffer(val)) {
                // Special case: looking for empty string/buffer always fails
                if (val.length === 0) {
                  return -1
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
              } else if (typeof val === 'number') {
                val = val & 0xFF; // Search for a byte value [0-255]
                if (Buffer.TYPED_ARRAY_SUPPORT &&
                    typeof Uint8Array.prototype.indexOf === 'function') {
                  if (dir) {
                    return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
                  } else {
                    return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
                  }
                }
                return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
              }

              throw new TypeError('val must be string, number or Buffer')
            }

            function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
              var indexSize = 1;
              var arrLength = arr.length;
              var valLength = val.length;

              if (encoding !== undefined) {
                encoding = String(encoding).toLowerCase();
                if (encoding === 'ucs2' || encoding === 'ucs-2' ||
                    encoding === 'utf16le' || encoding === 'utf-16le') {
                  if (arr.length < 2 || val.length < 2) {
                    return -1
                  }
                  indexSize = 2;
                  arrLength /= 2;
                  valLength /= 2;
                  byteOffset /= 2;
                }
              }

              function read$$1 (buf, i) {
                if (indexSize === 1) {
                  return buf[i]
                } else {
                  return buf.readUInt16BE(i * indexSize)
                }
              }

              var i;
              if (dir) {
                var foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) {
                  if (read$$1(arr, i) === read$$1(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                    if (foundIndex === -1) foundIndex = i;
                    if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
                  } else {
                    if (foundIndex !== -1) i -= i - foundIndex;
                    foundIndex = -1;
                  }
                }
              } else {
                if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                for (i = byteOffset; i >= 0; i--) {
                  var found = true;
                  for (var j = 0; j < valLength; j++) {
                    if (read$$1(arr, i + j) !== read$$1(val, j)) {
                      found = false;
                      break
                    }
                  }
                  if (found) return i
                }
              }

              return -1
            }

            Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
              return this.indexOf(val, byteOffset, encoding) !== -1
            };

            Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
            };

            Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
            };

            function hexWrite (buf, string, offset, length) {
              offset = Number(offset) || 0;
              var remaining = buf.length - offset;
              if (!length) {
                length = remaining;
              } else {
                length = Number(length);
                if (length > remaining) {
                  length = remaining;
                }
              }

              // must be an even number of digits
              var strLen = string.length;
              if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

              if (length > strLen / 2) {
                length = strLen / 2;
              }
              for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string.substr(i * 2, 2), 16);
                if (isNaN(parsed)) return i
                buf[offset + i] = parsed;
              }
              return i
            }

            function utf8Write (buf, string, offset, length) {
              return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
            }

            function asciiWrite (buf, string, offset, length) {
              return blitBuffer(asciiToBytes(string), buf, offset, length)
            }

            function latin1Write (buf, string, offset, length) {
              return asciiWrite(buf, string, offset, length)
            }

            function base64Write (buf, string, offset, length) {
              return blitBuffer(base64ToBytes(string), buf, offset, length)
            }

            function ucs2Write (buf, string, offset, length) {
              return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
            }

            Buffer.prototype.write = function write$$1 (string, offset, length, encoding) {
              // Buffer#write(string)
              if (offset === undefined) {
                encoding = 'utf8';
                length = this.length;
                offset = 0;
              // Buffer#write(string, encoding)
              } else if (length === undefined && typeof offset === 'string') {
                encoding = offset;
                length = this.length;
                offset = 0;
              // Buffer#write(string, offset[, length][, encoding])
              } else if (isFinite(offset)) {
                offset = offset | 0;
                if (isFinite(length)) {
                  length = length | 0;
                  if (encoding === undefined) encoding = 'utf8';
                } else {
                  encoding = length;
                  length = undefined;
                }
              // legacy write(string, encoding, offset, length) - remove in v0.13
              } else {
                throw new Error(
                  'Buffer.write(string, encoding, offset[, length]) is no longer supported'
                )
              }

              var remaining = this.length - offset;
              if (length === undefined || length > remaining) length = remaining;

              if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                throw new RangeError('Attempt to write outside buffer bounds')
              }

              if (!encoding) encoding = 'utf8';

              var loweredCase = false;
              for (;;) {
                switch (encoding) {
                  case 'hex':
                    return hexWrite(this, string, offset, length)

                  case 'utf8':
                  case 'utf-8':
                    return utf8Write(this, string, offset, length)

                  case 'ascii':
                    return asciiWrite(this, string, offset, length)

                  case 'latin1':
                  case 'binary':
                    return latin1Write(this, string, offset, length)

                  case 'base64':
                    // Warning: maxLength not taken into account in base64Write
                    return base64Write(this, string, offset, length)

                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return ucs2Write(this, string, offset, length)

                  default:
                    if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                    encoding = ('' + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            };

            Buffer.prototype.toJSON = function toJSON () {
              return {
                type: 'Buffer',
                data: Array.prototype.slice.call(this._arr || this, 0)
              }
            };

            function base64Slice (buf, start, end) {
              if (start === 0 && end === buf.length) {
                return fromByteArray(buf)
              } else {
                return fromByteArray(buf.slice(start, end))
              }
            }

            function utf8Slice (buf, start, end) {
              end = Math.min(buf.length, end);
              var res = [];

              var i = start;
              while (i < end) {
                var firstByte = buf[i];
                var codePoint = null;
                var bytesPerSequence = (firstByte > 0xEF) ? 4
                  : (firstByte > 0xDF) ? 3
                  : (firstByte > 0xBF) ? 2
                  : 1;

                if (i + bytesPerSequence <= end) {
                  var secondByte, thirdByte, fourthByte, tempCodePoint;

                  switch (bytesPerSequence) {
                    case 1:
                      if (firstByte < 0x80) {
                        codePoint = firstByte;
                      }
                      break
                    case 2:
                      secondByte = buf[i + 1];
                      if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                        if (tempCodePoint > 0x7F) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break
                    case 3:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break
                    case 4:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      fourthByte = buf[i + 3];
                      if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                          codePoint = tempCodePoint;
                        }
                      }
                  }
                }

                if (codePoint === null) {
                  // we did not generate a valid codePoint so insert a
                  // replacement char (U+FFFD) and advance only 1 byte
                  codePoint = 0xFFFD;
                  bytesPerSequence = 1;
                } else if (codePoint > 0xFFFF) {
                  // encode to utf16 (surrogate pair dance)
                  codePoint -= 0x10000;
                  res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                  codePoint = 0xDC00 | codePoint & 0x3FF;
                }

                res.push(codePoint);
                i += bytesPerSequence;
              }

              return decodeCodePointsArray(res)
            }

            // Based on http://stackoverflow.com/a/22747272/680742, the browser with
            // the lowest limit is Chrome, with 0x10000 args.
            // We go 1 magnitude less, for safety
            var MAX_ARGUMENTS_LENGTH = 0x1000;

            function decodeCodePointsArray (codePoints) {
              var len = codePoints.length;
              if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
              }

              // Decode in chunks to avoid "call stack size exceeded".
              var res = '';
              var i = 0;
              while (i < len) {
                res += String.fromCharCode.apply(
                  String,
                  codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                );
              }
              return res
            }

            function asciiSlice (buf, start, end) {
              var ret = '';
              end = Math.min(buf.length, end);

              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 0x7F);
              }
              return ret
            }

            function latin1Slice (buf, start, end) {
              var ret = '';
              end = Math.min(buf.length, end);

              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i]);
              }
              return ret
            }

            function hexSlice (buf, start, end) {
              var len = buf.length;

              if (!start || start < 0) start = 0;
              if (!end || end < 0 || end > len) end = len;

              var out = '';
              for (var i = start; i < end; ++i) {
                out += toHex(buf[i]);
              }
              return out
            }

            function utf16leSlice (buf, start, end) {
              var bytes = buf.slice(start, end);
              var res = '';
              for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
              }
              return res
            }

            Buffer.prototype.slice = function slice (start, end) {
              var len = this.length;
              start = ~~start;
              end = end === undefined ? len : ~~end;

              if (start < 0) {
                start += len;
                if (start < 0) start = 0;
              } else if (start > len) {
                start = len;
              }

              if (end < 0) {
                end += len;
                if (end < 0) end = 0;
              } else if (end > len) {
                end = len;
              }

              if (end < start) end = start;

              var newBuf;
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                newBuf = this.subarray(start, end);
                newBuf.__proto__ = Buffer.prototype;
              } else {
                var sliceLen = end - start;
                newBuf = new Buffer(sliceLen, undefined);
                for (var i = 0; i < sliceLen; ++i) {
                  newBuf[i] = this[i + start];
                }
              }

              return newBuf
            };

            /*
             * Need to make sure that buffer isn't trying to write out of bounds.
             */
            function checkOffset (offset, ext, length) {
              if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
              if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
            }

            Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul;
              }

              return val
            };

            Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                checkOffset(offset, byteLength, this.length);
              }

              var val = this[offset + --byteLength];
              var mul = 1;
              while (byteLength > 0 && (mul *= 0x100)) {
                val += this[offset + --byteLength] * mul;
              }

              return val
            };

            Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 1, this.length);
              return this[offset]
            };

            Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              return this[offset] | (this[offset + 1] << 8)
            };

            Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              return (this[offset] << 8) | this[offset + 1]
            };

            Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);

              return ((this[offset]) |
                  (this[offset + 1] << 8) |
                  (this[offset + 2] << 16)) +
                  (this[offset + 3] * 0x1000000)
            };

            Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (this[offset] * 0x1000000) +
                ((this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                this[offset + 3])
            };

            Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul;
              }
              mul *= 0x80;

              if (val >= mul) val -= Math.pow(2, 8 * byteLength);

              return val
            };

            Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var i = byteLength;
              var mul = 1;
              var val = this[offset + --i];
              while (i > 0 && (mul *= 0x100)) {
                val += this[offset + --i] * mul;
              }
              mul *= 0x80;

              if (val >= mul) val -= Math.pow(2, 8 * byteLength);

              return val
            };

            Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 1, this.length);
              if (!(this[offset] & 0x80)) return (this[offset])
              return ((0xff - this[offset] + 1) * -1)
            };

            Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              var val = this[offset] | (this[offset + 1] << 8);
              return (val & 0x8000) ? val | 0xFFFF0000 : val
            };

            Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              var val = this[offset + 1] | (this[offset] << 8);
              return (val & 0x8000) ? val | 0xFFFF0000 : val
            };

            Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (this[offset]) |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16) |
                (this[offset + 3] << 24)
            };

            Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (this[offset] << 24) |
                (this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                (this[offset + 3])
            };

            Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return read(this, offset, true, 23, 4)
            };

            Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return read(this, offset, false, 23, 4)
            };

            Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 8, this.length);
              return read(this, offset, true, 52, 8)
            };

            Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 8, this.length);
              return read(this, offset, false, 52, 8)
            };

            function checkInt (buf, value, offset, ext, max, min) {
              if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
              if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
              if (offset + ext > buf.length) throw new RangeError('Index out of range')
            }

            Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
              }

              var mul = 1;
              var i = 0;
              this[offset] = value & 0xFF;
              while (++i < byteLength && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xFF;
              }

              return offset + byteLength
            };

            Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
              }

              var i = byteLength - 1;
              var mul = 1;
              this[offset + i] = value & 0xFF;
              while (--i >= 0 && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xFF;
              }

              return offset + byteLength
            };

            Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
              if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
              this[offset] = (value & 0xff);
              return offset + 1
            };

            function objectWriteUInt16 (buf, value, offset, littleEndian) {
              if (value < 0) value = 0xffff + value + 1;
              for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
                buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                  (littleEndian ? i : 1 - i) * 8;
              }
            }

            Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
              } else {
                objectWriteUInt16(this, value, offset, true);
              }
              return offset + 2
            };

            Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 8);
                this[offset + 1] = (value & 0xff);
              } else {
                objectWriteUInt16(this, value, offset, false);
              }
              return offset + 2
            };

            function objectWriteUInt32 (buf, value, offset, littleEndian) {
              if (value < 0) value = 0xffffffff + value + 1;
              for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
                buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
              }
            }

            Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset + 3] = (value >>> 24);
                this[offset + 2] = (value >>> 16);
                this[offset + 1] = (value >>> 8);
                this[offset] = (value & 0xff);
              } else {
                objectWriteUInt32(this, value, offset, true);
              }
              return offset + 4
            };

            Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 24);
                this[offset + 1] = (value >>> 16);
                this[offset + 2] = (value >>> 8);
                this[offset + 3] = (value & 0xff);
              } else {
                objectWriteUInt32(this, value, offset, false);
              }
              return offset + 4
            };

            Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);

                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }

              var i = 0;
              var mul = 1;
              var sub = 0;
              this[offset] = value & 0xFF;
              while (++i < byteLength && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
              }

              return offset + byteLength
            };

            Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);

                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }

              var i = byteLength - 1;
              var mul = 1;
              var sub = 0;
              this[offset + i] = value & 0xFF;
              while (--i >= 0 && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
              }

              return offset + byteLength
            };

            Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
              if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
              if (value < 0) value = 0xff + value + 1;
              this[offset] = (value & 0xff);
              return offset + 1
            };

            Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
              } else {
                objectWriteUInt16(this, value, offset, true);
              }
              return offset + 2
            };

            Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 8);
                this[offset + 1] = (value & 0xff);
              } else {
                objectWriteUInt16(this, value, offset, false);
              }
              return offset + 2
            };

            Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
                this[offset + 2] = (value >>> 16);
                this[offset + 3] = (value >>> 24);
              } else {
                objectWriteUInt32(this, value, offset, true);
              }
              return offset + 4
            };

            Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
              if (value < 0) value = 0xffffffff + value + 1;
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 24);
                this[offset + 1] = (value >>> 16);
                this[offset + 2] = (value >>> 8);
                this[offset + 3] = (value & 0xff);
              } else {
                objectWriteUInt32(this, value, offset, false);
              }
              return offset + 4
            };

            function checkIEEE754 (buf, value, offset, ext, max, min) {
              if (offset + ext > buf.length) throw new RangeError('Index out of range')
              if (offset < 0) throw new RangeError('Index out of range')
            }

            function writeFloat (buf, value, offset, littleEndian, noAssert) {
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
              }
              write(buf, value, offset, littleEndian, 23, 4);
              return offset + 4
            }

            Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
              return writeFloat(this, value, offset, true, noAssert)
            };

            Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
              return writeFloat(this, value, offset, false, noAssert)
            };

            function writeDouble (buf, value, offset, littleEndian, noAssert) {
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
              }
              write(buf, value, offset, littleEndian, 52, 8);
              return offset + 8
            }

            Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
              return writeDouble(this, value, offset, true, noAssert)
            };

            Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
              return writeDouble(this, value, offset, false, noAssert)
            };

            // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
            Buffer.prototype.copy = function copy (target, targetStart, start, end) {
              if (!start) start = 0;
              if (!end && end !== 0) end = this.length;
              if (targetStart >= target.length) targetStart = target.length;
              if (!targetStart) targetStart = 0;
              if (end > 0 && end < start) end = start;

              // Copy 0 bytes; we're done
              if (end === start) return 0
              if (target.length === 0 || this.length === 0) return 0

              // Fatal error conditions
              if (targetStart < 0) {
                throw new RangeError('targetStart out of bounds')
              }
              if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
              if (end < 0) throw new RangeError('sourceEnd out of bounds')

              // Are we oob?
              if (end > this.length) end = this.length;
              if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
              }

              var len = end - start;
              var i;

              if (this === target && start < targetStart && targetStart < end) {
                // descending copy from end
                for (i = len - 1; i >= 0; --i) {
                  target[i + targetStart] = this[i + start];
                }
              } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                // ascending copy from start
                for (i = 0; i < len; ++i) {
                  target[i + targetStart] = this[i + start];
                }
              } else {
                Uint8Array.prototype.set.call(
                  target,
                  this.subarray(start, start + len),
                  targetStart
                );
              }

              return len
            };

            // Usage:
            //    buffer.fill(number[, offset[, end]])
            //    buffer.fill(buffer[, offset[, end]])
            //    buffer.fill(string[, offset[, end]][, encoding])
            Buffer.prototype.fill = function fill (val, start, end, encoding) {
              // Handle string cases:
              if (typeof val === 'string') {
                if (typeof start === 'string') {
                  encoding = start;
                  start = 0;
                  end = this.length;
                } else if (typeof end === 'string') {
                  encoding = end;
                  end = this.length;
                }
                if (val.length === 1) {
                  var code = val.charCodeAt(0);
                  if (code < 256) {
                    val = code;
                  }
                }
                if (encoding !== undefined && typeof encoding !== 'string') {
                  throw new TypeError('encoding must be a string')
                }
                if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                  throw new TypeError('Unknown encoding: ' + encoding)
                }
              } else if (typeof val === 'number') {
                val = val & 255;
              }

              // Invalid ranges are not set to a default, so can range check early.
              if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError('Out of range index')
              }

              if (end <= start) {
                return this
              }

              start = start >>> 0;
              end = end === undefined ? this.length : end >>> 0;

              if (!val) val = 0;

              var i;
              if (typeof val === 'number') {
                for (i = start; i < end; ++i) {
                  this[i] = val;
                }
              } else {
                var bytes = internalIsBuffer(val)
                  ? val
                  : utf8ToBytes(new Buffer(val, encoding).toString());
                var len = bytes.length;
                for (i = 0; i < end - start; ++i) {
                  this[i + start] = bytes[i % len];
                }
              }

              return this
            };

            // HELPER FUNCTIONS
            // ================

            var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

            function base64clean (str) {
              // Node strips out invalid characters like \n and \t from the string, base64-js does not
              str = stringtrim(str).replace(INVALID_BASE64_RE, '');
              // Node converts strings with length < 2 to ''
              if (str.length < 2) return ''
              // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
              while (str.length % 4 !== 0) {
                str = str + '=';
              }
              return str
            }

            function stringtrim (str) {
              if (str.trim) return str.trim()
              return str.replace(/^\s+|\s+$/g, '')
            }

            function toHex (n) {
              if (n < 16) return '0' + n.toString(16)
              return n.toString(16)
            }

            function utf8ToBytes (string, units) {
              units = units || Infinity;
              var codePoint;
              var length = string.length;
              var leadSurrogate = null;
              var bytes = [];

              for (var i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i);

                // is surrogate component
                if (codePoint > 0xD7FF && codePoint < 0xE000) {
                  // last char was a lead
                  if (!leadSurrogate) {
                    // no lead yet
                    if (codePoint > 0xDBFF) {
                      // unexpected trail
                      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                      continue
                    } else if (i + 1 === length) {
                      // unpaired lead
                      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                      continue
                    }

                    // valid lead
                    leadSurrogate = codePoint;

                    continue
                  }

                  // 2 leads in a row
                  if (codePoint < 0xDC00) {
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    leadSurrogate = codePoint;
                    continue
                  }

                  // valid surrogate pair
                  codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
                } else if (leadSurrogate) {
                  // valid bmp char, but last char was a lead
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                }

                leadSurrogate = null;

                // encode utf8
                if (codePoint < 0x80) {
                  if ((units -= 1) < 0) break
                  bytes.push(codePoint);
                } else if (codePoint < 0x800) {
                  if ((units -= 2) < 0) break
                  bytes.push(
                    codePoint >> 0x6 | 0xC0,
                    codePoint & 0x3F | 0x80
                  );
                } else if (codePoint < 0x10000) {
                  if ((units -= 3) < 0) break
                  bytes.push(
                    codePoint >> 0xC | 0xE0,
                    codePoint >> 0x6 & 0x3F | 0x80,
                    codePoint & 0x3F | 0x80
                  );
                } else if (codePoint < 0x110000) {
                  if ((units -= 4) < 0) break
                  bytes.push(
                    codePoint >> 0x12 | 0xF0,
                    codePoint >> 0xC & 0x3F | 0x80,
                    codePoint >> 0x6 & 0x3F | 0x80,
                    codePoint & 0x3F | 0x80
                  );
                } else {
                  throw new Error('Invalid code point')
                }
              }

              return bytes
            }

            function asciiToBytes (str) {
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                // Node's code seems to be doing this and not & 0x7F..
                byteArray.push(str.charCodeAt(i) & 0xFF);
              }
              return byteArray
            }

            function utf16leToBytes (str, units) {
              var c, hi, lo;
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0) break

                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
              }

              return byteArray
            }


            function base64ToBytes (str) {
              return toByteArray(base64clean(str))
            }

            function blitBuffer (src, dst, offset, length) {
              for (var i = 0; i < length; ++i) {
                if ((i + offset >= dst.length) || (i >= src.length)) break
                dst[i + offset] = src[i];
              }
              return i
            }

            function isnan (val) {
              return val !== val // eslint-disable-line no-self-compare
            }


            // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
            // The _isBuffer check is for Safari 5-7 support, because it's missing
            // Object.prototype.constructor. Remove this eventually
            function isBuffer(obj) {
              return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
            }

            function isFastBuffer (obj) {
              return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
            }

            // For Node v0.10 support. Remove this eventually.
            function isSlowBuffer (obj) {
              return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
            }

            /**
             * Converts the `arg` to an array. If `arg` is already an array, it is returned as is.
             *
             * @hidden
             *
             * @param arg - Value to convert
             * @returns {[]}
             */
            function toArray(arg) {
              return arg == null ? [] : Array.isArray(arg) ? arg : [arg];
            }

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
              return typeof obj;
            } : function (obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };

            var classCallCheck = function (instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            };

            var createClass = function () {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }

              return function (Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();

            var inherits = function (subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }

              subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            };

            var possibleConstructorReturn = function (self, call) {
              if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }

              return call && (typeof call === "object" || typeof call === "function") ? call : self;
            };

            /**
             * Represents cryptographic public keys with versions, which are
             * used to verify the result of `transform` operation.
             *
             * @hidden
             */
            var ProofKeys = function () {

            	/**
              * Creates a new instance of `ProofKeys`.
              * @param {string|string[]} proofKeys - Array of strings (or a single string)
              * representing the Pythia public key(s). String must be in the following format:
              * 		`'PK.{version}.{base64-encoded-data}'`
              *
              * If `proofKeys` is empty or contains string in a wrong format, an error is thrown.
              */
            	function ProofKeys(proofKeys) {
            		classCallCheck(this, ProofKeys);

            		proofKeys = toArray(proofKeys);

            		if (proofKeys.length === 0) {
            			throw new Error('Parameter `proofKeys` must not be empty');
            		}

            		this.proofKeys = proofKeys.map(parseProofKey).sort(compareVersion);
            	}

            	/**
              * Retrieves the current Pythia public key.
              * @returns {{ version: number, key: Buffer }}
              */


            	createClass(ProofKeys, [{
            		key: 'currentKey',
            		value: function currentKey() {
            			if (this.proofKeys[0] === undefined) {
            				// Something very bad has happened. Probably, unsuccessful migration
            				throw new Error('No proof key exists');
            			}

            			return this.proofKeys[0];
            		}

            		/**
               * Retrieves a Pythia public key by `version`.
               * @param {number} version - Version of the public key to retrieve.
               * @returns {{ version: number, key: Buffer }}
               */

            	}, {
            		key: 'proofKey',
            		value: function proofKey(version) {
            			var proofKey = this.proofKeys.find(function (k) {
            				return k.version === version;
            			});
            			if (proofKey === undefined) {
            				// Something very bad has happened. Probably, unsuccessful migration
            				throw new Error('Proof key of version ' + version + ' does not exist');
            			}

            			return proofKey;
            		}
            	}]);
            	return ProofKeys;
            }();

            function compareVersion(proofKeyA, proofKeyB) {
            	// sort in descending order
            	return proofKeyB.version - proofKeyA.version;
            }

            function parseProofKey(str) {
            	var parts = str.split('.');
            	if (parts.length !== 3 || parts[0] !== 'PK') {
            		throw new Error('ProofKey string is invalid');
            	}

            	var version = Number(parts[1]);
            	var key = Buffer.from(parts[2], 'base64');

            	return {
            		version: version,
            		key: key
            	};
            }

            /**
             * Represents a user's breach-proof password parameters.
             */
            var BreachProofPassword = function () {

            	/**
              * Creates a new instance of `BreachProofPassword`.
              *
              * @protected
              *
              * @param {Buffer} salt - User identifier.
              * @param {Buffer} deblindedPassword - Deblinded transformed password value.
              * This value is not equal to password and is zero-knowledge protected.
              * @param {number} version - The password version.
              */
            	function BreachProofPassword(salt, deblindedPassword, version) {
            		classCallCheck(this, BreachProofPassword);

            		this.salt = ensureBuffer(salt, 'salt');
            		this.deblindedPassword = ensureBuffer(deblindedPassword, 'deblindedPassword');
            		this.version = version;
            	}

            	/**
              * Converts this instance to serializable JavaScript object.
              * @returns {{ salt: string, deblindedPassword: string, version: number }}
              */


            	createClass(BreachProofPassword, [{
            		key: 'toJSON',
            		value: function toJSON() {
            			return {
            				salt: this.salt.toString('base64'),
            				deblindedPassword: this.deblindedPassword.toString('base64'),
            				version: this.version
            			};
            		}
            	}]);
            	return BreachProofPassword;
            }();

            function ensureBuffer(arg, name) {
            	if (isBuffer(arg)) {
            		return arg;
            	}

            	if (typeof arg === 'string') {
            		return Buffer.from(arg, 'base64');
            	}

            	throw new TypeError('Invalid argument \'' + name + '\'. Expected Buffer or string, got ' + (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)));
            }

            /**
             * Checks whether two buffers are equal in constant time.
             *
             * @hidden
             *
             * @param buf1
             * @param buf2
             * @returns {boolean}
             */
            function constantTimeEqual(buf1, buf2) {
            	if (!(isBuffer(buf1) && isBuffer(buf2))) {
            		throw new Error('Only Buffer instances can be checked for equality');
            	}

            	if (buf1.byteLength !== buf2.byteLength) {
            		throw new Error('Both buffers must be of the same length');
            	}

            	var equal = 0;
            	for (var i = 0; i < buf1.length; i++) {
            		equal |= buf1[i] ^ buf2[i];
            	}

            	return equal === 0;
            }

            function PythiaError(message) {
            	this.message = message;
            	if (Error.captureStackTrace) {
            		Error.captureStackTrace(this, this.constructor);
            	} else {
            		this.stack = new Error().stack;
            	}
            }

            PythiaError.prototype = Object.create(Error.prototype);
            PythiaError.prototype.name = 'PythiaError';
            PythiaError.prototype.constructor = PythiaError;

            /**
             * An error thrown when an HTTP request to the Virgil API fails.
             * @param message - Error message
             * @param code - Optional error code.
             * @param httpStatus - HTTP status of the failed request.
             * @constructor
             */
            var PythiaClientError = function (_PythiaError) {
            	inherits(PythiaClientError, _PythiaError);

            	function PythiaClientError(message, code, httpStatus) {
            		classCallCheck(this, PythiaClientError);

            		var _this = possibleConstructorReturn(this, (PythiaClientError.__proto__ || Object.getPrototypeOf(PythiaClientError)).call(this, message));

            		_this.code = code;
            		_this.httpStatus = httpStatus;
            		return _this;
            	}

            	return PythiaClientError;
            }(PythiaError);

            /**
             * An error thrown when server-provided cryptographic proof of correctness
             * of transformed password cannot be verified.
             */
            var ProofVerificationFailedError = function (_PythiaError2) {
            	inherits(ProofVerificationFailedError, _PythiaError2);

            	function ProofVerificationFailedError() {
            		classCallCheck(this, ProofVerificationFailedError);

            		var _this2 = possibleConstructorReturn(this, (ProofVerificationFailedError.__proto__ || Object.getPrototypeOf(ProofVerificationFailedError)).call(this, 'Transformed password proof verification has failed'));

            		_this2.name = 'ProofVerificationFailedError';
            		return _this2;
            	}

            	return ProofVerificationFailedError;
            }(PythiaError);

            /**
             * An error thrown when updating a breach-proof password with an update token
             * and the password's version doesn't match the `from` version in update token.
             */
            var UnexpectedBreachProofPasswordVersionError = function (_PythiaError3) {
            	inherits(UnexpectedBreachProofPasswordVersionError, _PythiaError3);

            	function UnexpectedBreachProofPasswordVersionError(expectedVersion, actualVersion) {
            		classCallCheck(this, UnexpectedBreachProofPasswordVersionError);

            		var _this3 = possibleConstructorReturn(this, (UnexpectedBreachProofPasswordVersionError.__proto__ || Object.getPrototypeOf(UnexpectedBreachProofPasswordVersionError)).call(this, 'Unexpected Breach-proof password version. Expected ' + expectedVersion + ', got ' + actualVersion));

            		_this3.name = 'UnexpectedBreachProofPasswordVersionError';
            		return _this3;
            	}

            	return UnexpectedBreachProofPasswordVersionError;
            }(PythiaError);

            /**
             * @hidden
             */
            var SALT_BYTE_LENGTH = 32;

            /**
             * Class responsible generation, verification and updating of breach-proof passwords.
             *
             * `Pythia` instances are not meant to be created directly using the `new` keyword,
             * use {@link createPythia} method to create an instance.
             */
            var Pythia = function () {

            	/**
              * Creates a new instance of `Pythia`.
              * @param params - Pythia configuration.
              */
            	function Pythia(params) {
            		classCallCheck(this, Pythia);
            		var proofKeys = params.proofKeys,
            		    accessTokenProvider = params.accessTokenProvider,
            		    client = params.client,
            		    virgilCrypto = params.virgilCrypto,
            		    virgilPythiaCrypto = params.virgilPythiaCrypto;

            		this.proofKeys = proofKeys;
            		this.accessTokenProvider = accessTokenProvider;
            		this.client = client;
            		this.virgilCrypto = virgilCrypto;
            		this.virgilPythiaCrypto = virgilPythiaCrypto;
            	}

            	/**
              * Checks whether the given plaintext `password` corresponds to
              * the given `breachProofPassword`.
              *
              * @param password - The plaintext password.
              * @param breachProofPassword - The breach-proof password.
              * @param [includeProof] - Indicates whether to instruct the Pythia Server to include
              * the cryptographic proof that transformed blinded password was generated correctly.
              * Default is `false`.
              *
              * @returns {Promise<boolean>} `true` if plaintext password corresponds to the
              * breach-proof password, otherwise `false`.
              */


            	createClass(Pythia, [{
            		key: 'verifyBreachProofPassword',
            		value: function verifyBreachProofPassword(password, breachProofPassword, includeProof) {
            			var _this = this;

            			var _virgilPythiaCrypto$b = this.virgilPythiaCrypto.blind(password),
            			    blindedPassword = _virgilPythiaCrypto$b.blindedPassword,
            			    blindingSecret = _virgilPythiaCrypto$b.blindingSecret;

            			var proofKey = this.proofKeys.proofKey(breachProofPassword.version);

            			return this.accessTokenProvider.getToken(makeTokenContext()).then(function (accessToken) {
            				return _this.client.transformPassword({
            					blindedPassword: blindedPassword,
            					salt: breachProofPassword.salt,
            					version: breachProofPassword.version,
            					includeProof: includeProof,
            					token: accessToken.toString()
            				});
            			}).then(function (_ref) {
            				var transformedPassword = _ref.transformedPassword,
            				    proof = _ref.proof;

            				if (includeProof) {
            					var verified = _this.virgilPythiaCrypto.verify({
            						transformedPassword: transformedPassword,
            						blindedPassword: blindedPassword,
            						tweak: breachProofPassword.salt,
            						transformationPublicKey: proofKey.key,
            						proofValueC: proof.valueC,
            						proofValueU: proof.valueU
            					});

            					if (!verified) {
            						throw new ProofVerificationFailedError();
            					}
            				}

            				var deblindedPassword = _this.virgilPythiaCrypto.deblind({ transformedPassword: transformedPassword, blindingSecret: blindingSecret });
            				return constantTimeEqual(deblindedPassword, breachProofPassword.deblindedPassword);
            			});
            		}

            		/**
               * Creates a breach-proof password from the given plaintext `password`.
               *
               * @param password - The plaintext password.
               *
               * @returns {Promise<BreachProofPassword>}
               */

            	}, {
            		key: 'createBreachProofPassword',
            		value: function createBreachProofPassword(password) {
            			var _this2 = this;

            			var salt = this.virgilCrypto.getRandomBytes(SALT_BYTE_LENGTH);

            			var _virgilPythiaCrypto$b2 = this.virgilPythiaCrypto.blind(password),
            			    blindedPassword = _virgilPythiaCrypto$b2.blindedPassword,
            			    blindingSecret = _virgilPythiaCrypto$b2.blindingSecret;

            			var latestProofKey = this.proofKeys.currentKey();

            			return this.accessTokenProvider.getToken(makeTokenContext()).then(function (accessToken) {
            				return _this2.client.transformPassword({
            					blindedPassword: blindedPassword,
            					salt: salt,
            					version: latestProofKey.version,
            					includeProof: true,
            					token: accessToken.toString()
            				});
            			}).then(function (_ref2) {
            				var transformedPassword = _ref2.transformedPassword,
            				    proof = _ref2.proof;

            				var verified = _this2.virgilPythiaCrypto.verify({
            					transformedPassword: transformedPassword,
            					blindedPassword: blindedPassword,
            					tweak: salt,
            					transformationPublicKey: latestProofKey.key,
            					proofValueC: proof.valueC,
            					proofValueU: proof.valueU
            				});

            				if (!verified) {
            					throw new ProofVerificationFailedError();
            				}

            				var deblindedPassword = _this2.virgilPythiaCrypto.deblind({ transformedPassword: transformedPassword, blindingSecret: blindingSecret });
            				return new BreachProofPassword(salt, deblindedPassword, latestProofKey.version);
            			});
            		}

            		/**
               * Generates a new breach-proof password based on the current `breachProofPassword`
               * and `updateToken`.
               *
               * @param updateToken - The password update token. You can get it at Virgil Developer Dashboard.
               * @param breachProofPassword - The current breach-proof password.
               *
               * @returns {BreachProofPassword} - The new breach-proof password.
               */

            	}, {
            		key: 'updateBreachProofPassword',
            		value: function updateBreachProofPassword(updateToken, breachProofPassword) {
            			var _parseUpdateToken = parseUpdateToken(updateToken),
            			    prevVersion = _parseUpdateToken.prevVersion,
            			    nextVersion = _parseUpdateToken.nextVersion,
            			    token = _parseUpdateToken.token;

            			if (breachProofPassword.version !== prevVersion) {
            				throw new UnexpectedBreachProofPasswordVersionError(prevVersion, breachProofPassword.version);
            			}

            			var newDeblindedPassword = this.virgilPythiaCrypto.updateDeblindedWithToken({
            				deblindedPassword: breachProofPassword.deblindedPassword,
            				updateToken: token
            			});
            			return new BreachProofPassword(breachProofPassword.salt, newDeblindedPassword, nextVersion);
            		}
            	}]);
            	return Pythia;
            }();

            function parseUpdateToken(updateToken) {
            	var parts = updateToken.split('.');
            	if (parts.length !== 4 || parts[0] !== 'UT') {
            		throw new Error('UpdateToken string is invalid');
            	}

            	return {
            		prevVersion: Number(parts[1]),
            		nextVersion: Number(parts[2]),
            		token: Buffer.from(parts[3], 'base64')
            	};
            }

            function makeTokenContext() {
            	return {
            		service: 'pythia',
            		identity: 'PYTHIA-CLIENT',
            		operation: 'transform',
            		forceReload: false
            	};
            }

            var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

            function createCommonjsModule(fn, module) {
            	return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            var browserPonyfill = createCommonjsModule(function (module) {
            var __root__ = (function (root) {
            function F() { this.fetch = false; }
            F.prototype = root;
            return new F();
            })(typeof self !== 'undefined' ? self : commonjsGlobal);
            (function(self) {

            (function(self) {

              if (self.fetch) {
                return
              }

              var support = {
                searchParams: 'URLSearchParams' in self,
                iterable: 'Symbol' in self && 'iterator' in Symbol,
                blob: 'FileReader' in self && 'Blob' in self && (function() {
                  try {
                    new Blob();
                    return true
                  } catch(e) {
                    return false
                  }
                })(),
                formData: 'FormData' in self,
                arrayBuffer: 'ArrayBuffer' in self
              };

              if (support.arrayBuffer) {
                var viewClasses = [
                  '[object Int8Array]',
                  '[object Uint8Array]',
                  '[object Uint8ClampedArray]',
                  '[object Int16Array]',
                  '[object Uint16Array]',
                  '[object Int32Array]',
                  '[object Uint32Array]',
                  '[object Float32Array]',
                  '[object Float64Array]'
                ];

                var isDataView = function(obj) {
                  return obj && DataView.prototype.isPrototypeOf(obj)
                };

                var isArrayBufferView = ArrayBuffer.isView || function(obj) {
                  return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
                };
              }

              function normalizeName(name) {
                if (typeof name !== 'string') {
                  name = String(name);
                }
                if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
                  throw new TypeError('Invalid character in header field name')
                }
                return name.toLowerCase()
              }

              function normalizeValue(value) {
                if (typeof value !== 'string') {
                  value = String(value);
                }
                return value
              }

              // Build a destructive iterator for the value list
              function iteratorFor(items) {
                var iterator = {
                  next: function() {
                    var value = items.shift();
                    return {done: value === undefined, value: value}
                  }
                };

                if (support.iterable) {
                  iterator[Symbol.iterator] = function() {
                    return iterator
                  };
                }

                return iterator
              }

              function Headers(headers) {
                this.map = {};

                if (headers instanceof Headers) {
                  headers.forEach(function(value, name) {
                    this.append(name, value);
                  }, this);
                } else if (Array.isArray(headers)) {
                  headers.forEach(function(header) {
                    this.append(header[0], header[1]);
                  }, this);
                } else if (headers) {
                  Object.getOwnPropertyNames(headers).forEach(function(name) {
                    this.append(name, headers[name]);
                  }, this);
                }
              }

              Headers.prototype.append = function(name, value) {
                name = normalizeName(name);
                value = normalizeValue(value);
                var oldValue = this.map[name];
                this.map[name] = oldValue ? oldValue+','+value : value;
              };

              Headers.prototype['delete'] = function(name) {
                delete this.map[normalizeName(name)];
              };

              Headers.prototype.get = function(name) {
                name = normalizeName(name);
                return this.has(name) ? this.map[name] : null
              };

              Headers.prototype.has = function(name) {
                return this.map.hasOwnProperty(normalizeName(name))
              };

              Headers.prototype.set = function(name, value) {
                this.map[normalizeName(name)] = normalizeValue(value);
              };

              Headers.prototype.forEach = function(callback, thisArg) {
                for (var name in this.map) {
                  if (this.map.hasOwnProperty(name)) {
                    callback.call(thisArg, this.map[name], name, this);
                  }
                }
              };

              Headers.prototype.keys = function() {
                var items = [];
                this.forEach(function(value, name) { items.push(name); });
                return iteratorFor(items)
              };

              Headers.prototype.values = function() {
                var items = [];
                this.forEach(function(value) { items.push(value); });
                return iteratorFor(items)
              };

              Headers.prototype.entries = function() {
                var items = [];
                this.forEach(function(value, name) { items.push([name, value]); });
                return iteratorFor(items)
              };

              if (support.iterable) {
                Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
              }

              function consumed(body) {
                if (body.bodyUsed) {
                  return Promise.reject(new TypeError('Already read'))
                }
                body.bodyUsed = true;
              }

              function fileReaderReady(reader) {
                return new Promise(function(resolve, reject) {
                  reader.onload = function() {
                    resolve(reader.result);
                  };
                  reader.onerror = function() {
                    reject(reader.error);
                  };
                })
              }

              function readBlobAsArrayBuffer(blob) {
                var reader = new FileReader();
                var promise = fileReaderReady(reader);
                reader.readAsArrayBuffer(blob);
                return promise
              }

              function readBlobAsText(blob) {
                var reader = new FileReader();
                var promise = fileReaderReady(reader);
                reader.readAsText(blob);
                return promise
              }

              function readArrayBufferAsText(buf) {
                var view = new Uint8Array(buf);
                var chars = new Array(view.length);

                for (var i = 0; i < view.length; i++) {
                  chars[i] = String.fromCharCode(view[i]);
                }
                return chars.join('')
              }

              function bufferClone(buf) {
                if (buf.slice) {
                  return buf.slice(0)
                } else {
                  var view = new Uint8Array(buf.byteLength);
                  view.set(new Uint8Array(buf));
                  return view.buffer
                }
              }

              function Body() {
                this.bodyUsed = false;

                this._initBody = function(body) {
                  this._bodyInit = body;
                  if (!body) {
                    this._bodyText = '';
                  } else if (typeof body === 'string') {
                    this._bodyText = body;
                  } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                    this._bodyBlob = body;
                  } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                    this._bodyFormData = body;
                  } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                    this._bodyText = body.toString();
                  } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                    this._bodyArrayBuffer = bufferClone(body.buffer);
                    // IE 10-11 can't handle a DataView body.
                    this._bodyInit = new Blob([this._bodyArrayBuffer]);
                  } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                    this._bodyArrayBuffer = bufferClone(body);
                  } else {
                    throw new Error('unsupported BodyInit type')
                  }

                  if (!this.headers.get('content-type')) {
                    if (typeof body === 'string') {
                      this.headers.set('content-type', 'text/plain;charset=UTF-8');
                    } else if (this._bodyBlob && this._bodyBlob.type) {
                      this.headers.set('content-type', this._bodyBlob.type);
                    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                      this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                    }
                  }
                };

                if (support.blob) {
                  this.blob = function() {
                    var rejected = consumed(this);
                    if (rejected) {
                      return rejected
                    }

                    if (this._bodyBlob) {
                      return Promise.resolve(this._bodyBlob)
                    } else if (this._bodyArrayBuffer) {
                      return Promise.resolve(new Blob([this._bodyArrayBuffer]))
                    } else if (this._bodyFormData) {
                      throw new Error('could not read FormData body as blob')
                    } else {
                      return Promise.resolve(new Blob([this._bodyText]))
                    }
                  };

                  this.arrayBuffer = function() {
                    if (this._bodyArrayBuffer) {
                      return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
                    } else {
                      return this.blob().then(readBlobAsArrayBuffer)
                    }
                  };
                }

                this.text = function() {
                  var rejected = consumed(this);
                  if (rejected) {
                    return rejected
                  }

                  if (this._bodyBlob) {
                    return readBlobAsText(this._bodyBlob)
                  } else if (this._bodyArrayBuffer) {
                    return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
                  } else if (this._bodyFormData) {
                    throw new Error('could not read FormData body as text')
                  } else {
                    return Promise.resolve(this._bodyText)
                  }
                };

                if (support.formData) {
                  this.formData = function() {
                    return this.text().then(decode)
                  };
                }

                this.json = function() {
                  return this.text().then(JSON.parse)
                };

                return this
              }

              // HTTP methods whose capitalization should be normalized
              var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

              function normalizeMethod(method) {
                var upcased = method.toUpperCase();
                return (methods.indexOf(upcased) > -1) ? upcased : method
              }

              function Request(input, options) {
                options = options || {};
                var body = options.body;

                if (input instanceof Request) {
                  if (input.bodyUsed) {
                    throw new TypeError('Already read')
                  }
                  this.url = input.url;
                  this.credentials = input.credentials;
                  if (!options.headers) {
                    this.headers = new Headers(input.headers);
                  }
                  this.method = input.method;
                  this.mode = input.mode;
                  if (!body && input._bodyInit != null) {
                    body = input._bodyInit;
                    input.bodyUsed = true;
                  }
                } else {
                  this.url = String(input);
                }

                this.credentials = options.credentials || this.credentials || 'omit';
                if (options.headers || !this.headers) {
                  this.headers = new Headers(options.headers);
                }
                this.method = normalizeMethod(options.method || this.method || 'GET');
                this.mode = options.mode || this.mode || null;
                this.referrer = null;

                if ((this.method === 'GET' || this.method === 'HEAD') && body) {
                  throw new TypeError('Body not allowed for GET or HEAD requests')
                }
                this._initBody(body);
              }

              Request.prototype.clone = function() {
                return new Request(this, { body: this._bodyInit })
              };

              function decode(body) {
                var form = new FormData();
                body.trim().split('&').forEach(function(bytes) {
                  if (bytes) {
                    var split = bytes.split('=');
                    var name = split.shift().replace(/\+/g, ' ');
                    var value = split.join('=').replace(/\+/g, ' ');
                    form.append(decodeURIComponent(name), decodeURIComponent(value));
                  }
                });
                return form
              }

              function parseHeaders(rawHeaders) {
                var headers = new Headers();
                // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
                // https://tools.ietf.org/html/rfc7230#section-3.2
                var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
                preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
                  var parts = line.split(':');
                  var key = parts.shift().trim();
                  if (key) {
                    var value = parts.join(':').trim();
                    headers.append(key, value);
                  }
                });
                return headers
              }

              Body.call(Request.prototype);

              function Response(bodyInit, options) {
                if (!options) {
                  options = {};
                }

                this.type = 'default';
                this.status = options.status === undefined ? 200 : options.status;
                this.ok = this.status >= 200 && this.status < 300;
                this.statusText = 'statusText' in options ? options.statusText : 'OK';
                this.headers = new Headers(options.headers);
                this.url = options.url || '';
                this._initBody(bodyInit);
              }

              Body.call(Response.prototype);

              Response.prototype.clone = function() {
                return new Response(this._bodyInit, {
                  status: this.status,
                  statusText: this.statusText,
                  headers: new Headers(this.headers),
                  url: this.url
                })
              };

              Response.error = function() {
                var response = new Response(null, {status: 0, statusText: ''});
                response.type = 'error';
                return response
              };

              var redirectStatuses = [301, 302, 303, 307, 308];

              Response.redirect = function(url, status) {
                if (redirectStatuses.indexOf(status) === -1) {
                  throw new RangeError('Invalid status code')
                }

                return new Response(null, {status: status, headers: {location: url}})
              };

              self.Headers = Headers;
              self.Request = Request;
              self.Response = Response;

              self.fetch = function(input, init) {
                return new Promise(function(resolve, reject) {
                  var request = new Request(input, init);
                  var xhr = new XMLHttpRequest();

                  xhr.onload = function() {
                    var options = {
                      status: xhr.status,
                      statusText: xhr.statusText,
                      headers: parseHeaders(xhr.getAllResponseHeaders() || '')
                    };
                    options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
                    var body = 'response' in xhr ? xhr.response : xhr.responseText;
                    resolve(new Response(body, options));
                  };

                  xhr.onerror = function() {
                    reject(new TypeError('Network request failed'));
                  };

                  xhr.ontimeout = function() {
                    reject(new TypeError('Network request failed'));
                  };

                  xhr.open(request.method, request.url, true);

                  if (request.credentials === 'include') {
                    xhr.withCredentials = true;
                  } else if (request.credentials === 'omit') {
                    xhr.withCredentials = false;
                  }

                  if ('responseType' in xhr && support.blob) {
                    xhr.responseType = 'blob';
                  }

                  request.headers.forEach(function(value, name) {
                    xhr.setRequestHeader(name, value);
                  });

                  xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
                })
              };
              self.fetch.polyfill = true;
            })(typeof self !== 'undefined' ? self : this);
            }).call(__root__, void(0));
            var fetch = __root__.fetch;
            var Response = fetch.Response = __root__.Response;
            var Request = fetch.Request = __root__.Request;
            var Headers = fetch.Headers = __root__.Headers;
            if (module.exports) {
            module.exports = fetch;
            }
            });
            var browserPonyfill_1 = browserPonyfill.fetch;
            var browserPonyfill_2 = browserPonyfill.Headers;
            var browserPonyfill_3 = browserPonyfill.Request;
            var browserPonyfill_4 = browserPonyfill.Response;

            /**
             * Class responsible for sending HTTP requests to
             * Virgil Pythia service.
             *
             * @hidden
             */
            var Connection = function () {
            	function Connection(baseUrl) {
            		classCallCheck(this, Connection);

            		this.baseUrl = baseUrl;
            	}

            	createClass(Connection, [{
            		key: 'send',
            		value: function send(url, opts) {
            			opts = normalizeOptions(opts);
            			return browserPonyfill(this.baseUrl + url, opts).then(function (response) {
            				if (!response.ok) {
            					return response.json().then(function (reason) {
            						var message = reason.message || response.statusText;
            						throw new PythiaClientError(message, reason.code, response.status);
            					});
            				}

            				return response.json();
            			});
            		}
            	}]);
            	return Connection;
            }();

            function normalizeOptions(opts) {
            	opts = Object.assign({}, opts);

            	var headers = new browserPonyfill_2(opts.headers || {});
            	if (opts.accessToken && !headers.has('Authorization')) {
            		headers.set('Authorization', 'Virgil ' + opts.accessToken);
            		delete opts.accessToken;
            	}

            	opts.headers = headers;

            	if (opts.body) {
            		var json = JSON.stringify(opts.body);
            		if (!headers.has('Content-Type')) {
            			headers.set('Content-Type', 'application/json');
            		}

            		opts.body = json;
            		opts.method = (opts.method || 'POST').toUpperCase();
            	} else {
            		opts.method = (opts.method || 'GET').toUpperCase();
            	}

            	return opts;
            }

            /**
             * Virgil Pythia Service client.
             *
             * @hidden
             */
            var PythiaClient = function () {

            	/**
              * Creates a new instance of `PythiaClient`.
              * @param {string|Connection|null} apiUrl - Either the URL of the Virgil API
              * Service, or a {@link Connection} instance, or `null`.
              */
            	function PythiaClient(apiUrl) {
            		classCallCheck(this, PythiaClient);

            		if (apiUrl == null) {
            			this.connection = new Connection('https://api.virgilsecurity.com');
            		} else if (typeof apiUrl === 'string') {
            			this.connection = new Connection(apiUrl);
            		} else {
            			this.connection = apiUrl;
            		}
            	}

            	/**
              * Sends a request to transform the blinded password.
              *
              * @param {Object} params - Input parameters.
              * @param {Buffer} params.salt - Arbitrary binary data identifying the user.
              * @param {Buffer} params.blindedPassword - The obfuscated user password.
              * @param {string} params.token - The access token to authenticate the request.
              * @param {number} [params.version] - Version of the user's password.
              * @param {boolean} [params.includeProof] - Indicates whether to include the cryptographic
              * proof in the response.
              *
              * @returns {Promise<{ transformedPassword: Buffer, proof?: { valueC: Buffer, valueU: Buffer } }>}
              */


            	createClass(PythiaClient, [{
            		key: 'transformPassword',
            		value: function transformPassword(params) {
            			var salt = params.salt,
            			    blindedPassword = params.blindedPassword,
            			    token = params.token,
            			    version = params.version,
            			    includeProof = params.includeProof;

            			var body = {
            				blinded_password: blindedPassword.toString('base64'),
            				user_id: salt.toString('base64')
            			};

            			if (version) {
            				body.version = version;
            			}

            			if (includeProof) {
            				body.include_proof = includeProof;
            			}

            			return this.connection.send('/pythia/v1/password', {
            				body: body,
            				accessToken: token
            			}).then(function (_ref) {
            				var transformed_password = _ref.transformed_password,
            				    proof = _ref.proof;

            				var result = {
            					transformedPassword: Buffer.from(transformed_password, 'base64')
            				};

            				if (includeProof) {
            					result.proof = {
            						valueC: Buffer.from(proof.value_c, 'base64'),
            						valueU: Buffer.from(proof.value_u, 'base64')
            					};
            				}

            				return result;
            			});
            		}

            		/**
               * Sends a request to generate a pseudo-random value, that can be used as
               * a seed for asymmetric key pair generation, from the blinded password.
               * @param {Buffer} blindedPassword - The obfuscated user password.
               * @param {string} [brainKeyId] - Optional identifier of the brain key.
               * @param {string} token - The access token to authenticate the request.
               * @returns {Promise<Buffer>}
               */

            	}, {
            		key: 'generateSeed',
            		value: function generateSeed(_ref2) {
            			var blindedPassword = _ref2.blindedPassword,
            			    brainKeyId = _ref2.brainKeyId,
            			    token = _ref2.token;

            			var body = {
            				blinded_password: blindedPassword.toString('base64')
            			};

            			if (brainKeyId) {
            				body.brainkey_id = brainKeyId;
            			}

            			return this.connection.send('/pythia/v1/brainkey', {
            				body: body,
            				accessToken: token
            			}).then(function (_ref3) {
            				var seed = _ref3.seed;
            				return Buffer.from(seed, 'base64');
            			});
            		}
            	}]);
            	return PythiaClient;
            }();

            /**
             * Factory function used to create instances of {@link Pythia} class.
             * @param {Object} params - Dependencies needed for `Pythia`.
             * @param {VirgilCrypto} params.virgilCrypto - Instance of `VirgilCrypto`
             * class from `virgil-crypto` module.
             * @param {VirgilPythiaCrypto} params.virgilPythiaCrypto - Instance of `VirgilPythiaCrypto`
             * class from `virgil-crypto` module.
             * @param {IAccessTokenProvider} params.accessTokenProvider - Object implementing
             * the `IAccessTokenProvider` interface from `virgil-sdk` module.
             * @param {string|string[]} params.proofKeys - The proof key or an array of proof keys in
             * string format. The format must be the following:
             * 		`'PK.{version}.{base64-encoded-data}'`
             *
             * @returns {Pythia}
             */
            function createPythia(params) {
            	var virgilCrypto = params.virgilCrypto,
            	    virgilPythiaCrypto = params.virgilPythiaCrypto,
            	    accessTokenProvider = params.accessTokenProvider,
            	    proofKeys = params.proofKeys,
            	    apiUrl = params.apiUrl;


            	requiredArg(virgilCrypto, 'virgilCrypto');
            	requiredArg(virgilPythiaCrypto, 'virgilPythiaCrypto');
            	requiredArg(accessTokenProvider, 'accessTokenProvider');
            	requiredArg(proofKeys, 'proofKeys');

            	return new Pythia({
            		proofKeys: new ProofKeys(proofKeys),
            		accessTokenProvider: accessTokenProvider,
            		client: new PythiaClient(apiUrl),
            		virgilCrypto: virgilCrypto,
            		virgilPythiaCrypto: virgilPythiaCrypto
            	});
            }

            function requiredArg(arg, argName) {
            	if (arg == null) {
            		throw new Error('Invalid Pythia parameters. "' + argName + '" is required.');
            	}
            }

            /**
             * Pythia BrainKey.
             *
             * BrainKey instances are not meant to be created with the `new` keyword. Use
             * the {@link createBrainKey} function to instantiate a `BrainKey`.
             */
            var BrainKey = function () {
            	/**
              * Initializes a new instance of `BrainKey`.
              *
              * @protected
              *
              * @param client - The service client.
              * @param accessTokenProvider - The access token provider.
              * @param pythiaCrypto - Crypto operations provider.
              * @param keyPairType - Type of key pair to generate.
              */
            	function BrainKey(_ref) {
            		var client = _ref.client,
            		    accessTokenProvider = _ref.accessTokenProvider,
            		    virgilCrypto = _ref.virgilCrypto,
            		    virgilPythiaCrypto = _ref.virgilPythiaCrypto,
            		    keyPairType = _ref.keyPairType;
            		classCallCheck(this, BrainKey);

            		this.client = client;
            		this.accessTokenProvider = accessTokenProvider;
            		this.keyPairType = keyPairType;
            		this.virgilCrypto = virgilCrypto;
            		this.virgilPythiaCrypto = virgilPythiaCrypto;
            	}

            	/**
              * Asynchronously generates an asymmetric key pair based on the given
              * `password` and `brainKeyId`.
              *
              * @param password - The password to generate the key pair from.
              * @param brainKeyId - Optional brainKey identifier. Used when one needs
              * to generate several different key pairs from the single password.
              *
              * @returns {Promise<{ privateKey: IPrivateKey, publicKey: IPublicKey }>}
              */


            	createClass(BrainKey, [{
            		key: 'generateKeyPair',
            		value: function generateKeyPair(password, brainKeyId) {
            			var _this = this;

            			var _virgilPythiaCrypto$b = this.virgilPythiaCrypto.blind(password),
            			    blindedPassword = _virgilPythiaCrypto$b.blindedPassword,
            			    blindingSecret = _virgilPythiaCrypto$b.blindingSecret;

            			return this.accessTokenProvider.getToken(makeTokenContext$1()).then(function (accessToken) {
            				return _this.client.generateSeed({
            					blindedPassword: blindedPassword,
            					brainKeyId: brainKeyId,
            					token: accessToken.toString()
            				});
            			}).then(function (seed) {
            				var deblindedPassword = _this.virgilPythiaCrypto.deblind({
            					transformedPassword: seed,
            					blindingSecret: blindingSecret
            				});
            				return _this.virgilCrypto.generateKeysFromKeyMaterial(deblindedPassword, _this.keyPairType);
            			});
            		}
            	}]);
            	return BrainKey;
            }();

            function makeTokenContext$1() {
            	return {
            		service: 'pythia',
            		operation: 'seed',
            		forceReload: false
            	};
            }

            /**
             * Factory function to create instances of {@link BrainKey} class.
             *
             * @param {Object} params - Dependencies needed for `BrainKey`.
             * @param {VirgilCrypto} params.virgilCrypto - Instance of `VirgilCrypto`
             * class from `virgil-crypto` module.
             * @param {VirgilPythiaCrypto} params.virgilPythiaCrypto - Instance of `VirgilPythiaCrypto`
             * class from `virgil-crypto` module.
             * @param {IAccessTokenProvider} params.accessTokenProvider - Object implementing
             * the `IAccessTokenProvider` interface from `virgil-sdk` module.
             * @param {string} [params.keyPairType] - Type of keys to generate. For available
             * options see `KeyPairType` enum in `virgil-crypto` module. Optional. The
             * recommended type is used by default.
             *
             * @returns {BrainKey}
             */
            function createBrainKey(params) {
            	var virgilCrypto = params.virgilCrypto,
            	    virgilPythiaCrypto = params.virgilPythiaCrypto,
            	    accessTokenProvider = params.accessTokenProvider,
            	    keyPairType = params.keyPairType,
            	    apiUrl = params.apiUrl;


            	requiredArg$1(virgilCrypto, 'virgilCrypto');
            	requiredArg$1(virgilPythiaCrypto, 'virgilPythiaCrypto');
            	requiredArg$1(accessTokenProvider, 'accessTokenProvider');

            	return new BrainKey({
            		keyPairType: keyPairType,
            		accessTokenProvider: accessTokenProvider,
            		client: new PythiaClient(apiUrl),
            		virgilCrypto: virgilCrypto,
            		virgilPythiaCrypto: virgilPythiaCrypto
            	});
            }

            function requiredArg$1(arg, argName) {
            	if (arg == null) {
            		throw new Error('Invalid BrainKey parameters. "' + argName + '" is required.');
            	}
            }

            exports.createPythia = createPythia;
            exports.createBrainKey = createBrainKey;
            exports.BreachProofPassword = BreachProofPassword;
            exports.PythiaClientError = PythiaClientError;
            exports.ProofVerificationFailedError = ProofVerificationFailedError;
            exports.UnexpectedBreachProofPasswordVersionError = UnexpectedBreachProofPasswordVersionError;

            Object.defineProperty(exports, '__esModule', { value: true });

})));
