'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fetch = require('cross-fetch');
var fetch__default = _interopDefault(fetch);

/**
 * Converts the `arg` to an array. If `arg` is already an array, it is returned as is.
 *
 * @hidden
 *
 * @param arg - Value to convert
 * @returns {[]}
 */
function toArray(arg) {
  return arg == null ? [] : Array.isArray(arg) ? arg : [arg];
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

/**
 * Represents cryptographic public keys with versions, which are
 * used to verify the result of `transform` operation.
 *
 * @hidden
 */
var ProofKeys = function () {

	/**
  * Creates a new instance of `ProofKeys`.
  * @param {string|string[]} proofKeys - Array of strings (or a single string)
  * representing the Pythia public key(s). String must be in the following format:
  * 		`'PK.{version}.{base64-encoded-data}'`
  *
  * If `proofKeys` is empty or contains string in a wrong format, an error is thrown.
  */
	function ProofKeys(proofKeys) {
		classCallCheck(this, ProofKeys);

		proofKeys = toArray(proofKeys);

		if (proofKeys.length === 0) {
			throw new Error('Parameter `proofKeys` must not be empty');
		}

		this.proofKeys = proofKeys.map(parseProofKey).sort(compareVersion);
	}

	/**
  * Retrieves the current Pythia public key.
  * @returns {{ version: number, key: Buffer }}
  */


	createClass(ProofKeys, [{
		key: 'currentKey',
		value: function currentKey() {
			if (this.proofKeys[0] === undefined) {
				// Something very bad has happened. Probably, unsuccessful migration
				throw new Error('No proof key exists');
			}

			return this.proofKeys[0];
		}

		/**
   * Retrieves a Pythia public key by `version`.
   * @param {number} version - Version of the public key to retrieve.
   * @returns {{ version: number, key: Buffer }}
   */

	}, {
		key: 'proofKey',
		value: function proofKey(version) {
			var proofKey = this.proofKeys.find(function (k) {
				return k.version === version;
			});
			if (proofKey === undefined) {
				// Something very bad has happened. Probably, unsuccessful migration
				throw new Error('Proof key of version ' + version + ' does not exist');
			}

			return proofKey;
		}
	}]);
	return ProofKeys;
}();

function compareVersion(proofKeyA, proofKeyB) {
	// sort in descending order
	return proofKeyB.version - proofKeyA.version;
}

function parseProofKey(str) {
	var parts = str.split('.');
	if (parts.length !== 3 || parts[0] !== 'PK') {
		throw new Error('ProofKey string is invalid');
	}

	var version = Number(parts[1]);
	var key = Buffer.from(parts[2], 'base64');

	return {
		version: version,
		key: key
	};
}

/**
 * Represents a user's breach-proof password parameters.
 */
var BreachProofPassword = function () {

	/**
  * Creates a new instance of `BreachProofPassword`.
  *
  * @protected
  *
  * @param {Buffer} salt - User identifier.
  * @param {Buffer} deblindedPassword - Deblinded transformed password value.
  * This value is not equal to password and is zero-knowledge protected.
  * @param {number} version - The password version.
  */
	function BreachProofPassword(salt, deblindedPassword, version) {
		classCallCheck(this, BreachProofPassword);

		this.salt = ensureBuffer(salt, 'salt');
		this.deblindedPassword = ensureBuffer(deblindedPassword, 'deblindedPassword');
		this.version = version;
	}

	/**
  * Converts this instance to serializable JavaScript object.
  * @returns {{ salt: string, deblindedPassword: string, version: number }}
  */


	createClass(BreachProofPassword, [{
		key: 'toJSON',
		value: function toJSON() {
			return {
				salt: this.salt.toString('base64'),
				deblindedPassword: this.deblindedPassword.toString('base64'),
				version: this.version
			};
		}
	}]);
	return BreachProofPassword;
}();

function ensureBuffer(arg, name) {
	if (Buffer.isBuffer(arg)) {
		return arg;
	}

	if (typeof arg === 'string') {
		return Buffer.from(arg, 'base64');
	}

	throw new TypeError('Invalid argument \'' + name + '\'. Expected Buffer or string, got ' + (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)));
}

/**
 * Checks whether two buffers are equal in constant time.
 *
 * @hidden
 *
 * @param buf1
 * @param buf2
 * @returns {boolean}
 */
function constantTimeEqual(buf1, buf2) {
	if (!(Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2))) {
		throw new Error('Only Buffer instances can be checked for equality');
	}

	if (buf1.byteLength !== buf2.byteLength) {
		throw new Error('Both buffers must be of the same length');
	}

	var equal = 0;
	for (var i = 0; i < buf1.length; i++) {
		equal |= buf1[i] ^ buf2[i];
	}

	return equal === 0;
}

function PythiaError(message) {
	this.message = message;
	if (Error.captureStackTrace) {
		Error.captureStackTrace(this, this.constructor);
	} else {
		this.stack = new Error().stack;
	}
}

PythiaError.prototype = Object.create(Error.prototype);
PythiaError.prototype.name = 'PythiaError';
PythiaError.prototype.constructor = PythiaError;

/**
 * An error thrown when an HTTP request to the Virgil API fails.
 * @param message - Error message
 * @param code - Optional error code.
 * @param httpStatus - HTTP status of the failed request.
 * @constructor
 */
var PythiaClientError = function (_PythiaError) {
	inherits(PythiaClientError, _PythiaError);

	function PythiaClientError(message, code, httpStatus) {
		classCallCheck(this, PythiaClientError);

		var _this = possibleConstructorReturn(this, (PythiaClientError.__proto__ || Object.getPrototypeOf(PythiaClientError)).call(this, message));

		_this.code = code;
		_this.httpStatus = httpStatus;
		return _this;
	}

	return PythiaClientError;
}(PythiaError);

/**
 * An error thrown when server-provided cryptographic proof of correctness
 * of transformed password cannot be verified.
 */
var ProofVerificationFailedError = function (_PythiaError2) {
	inherits(ProofVerificationFailedError, _PythiaError2);

	function ProofVerificationFailedError() {
		classCallCheck(this, ProofVerificationFailedError);

		var _this2 = possibleConstructorReturn(this, (ProofVerificationFailedError.__proto__ || Object.getPrototypeOf(ProofVerificationFailedError)).call(this, 'Transformed password proof verification has failed'));

		_this2.name = 'ProofVerificationFailedError';
		return _this2;
	}

	return ProofVerificationFailedError;
}(PythiaError);

/**
 * An error thrown when updating a breach-proof password with an update token
 * and the password's version doesn't match the `from` version in update token.
 */
var UnexpectedBreachProofPasswordVersionError = function (_PythiaError3) {
	inherits(UnexpectedBreachProofPasswordVersionError, _PythiaError3);

	function UnexpectedBreachProofPasswordVersionError(expectedVersion, actualVersion) {
		classCallCheck(this, UnexpectedBreachProofPasswordVersionError);

		var _this3 = possibleConstructorReturn(this, (UnexpectedBreachProofPasswordVersionError.__proto__ || Object.getPrototypeOf(UnexpectedBreachProofPasswordVersionError)).call(this, 'Unexpected Breach-proof password version. Expected ' + expectedVersion + ', got ' + actualVersion));

		_this3.name = 'UnexpectedBreachProofPasswordVersionError';
		return _this3;
	}

	return UnexpectedBreachProofPasswordVersionError;
}(PythiaError);

/**
 * @hidden
 */
var SALT_BYTE_LENGTH = 32;

/**
 * Class responsible generation, verification and updating of breach-proof passwords.
 *
 * `Pythia` instances are not meant to be created directly using the `new` keyword,
 * use {@link createPythia} method to create an instance.
 */
var Pythia = function () {

	/**
  * Creates a new instance of `Pythia`.
  * @param params - Pythia configuration.
  */
	function Pythia(params) {
		classCallCheck(this, Pythia);
		var proofKeys = params.proofKeys,
		    accessTokenProvider = params.accessTokenProvider,
		    client = params.client,
		    virgilCrypto = params.virgilCrypto,
		    virgilPythiaCrypto = params.virgilPythiaCrypto;

		this.proofKeys = proofKeys;
		this.accessTokenProvider = accessTokenProvider;
		this.client = client;
		this.virgilCrypto = virgilCrypto;
		this.virgilPythiaCrypto = virgilPythiaCrypto;
	}

	/**
  * Checks whether the given plaintext `password` corresponds to
  * the given `breachProofPassword`.
  *
  * @param password - The plaintext password.
  * @param breachProofPassword - The breach-proof password.
  * @param [includeProof] - Indicates whether to instruct the Pythia Server to include
  * the cryptographic proof that transformed blinded password was generated correctly.
  * Default is `false`.
  *
  * @returns {Promise<boolean>} `true` if plaintext password corresponds to the
  * breach-proof password, otherwise `false`.
  */


	createClass(Pythia, [{
		key: 'verifyBreachProofPassword',
		value: function verifyBreachProofPassword(password, breachProofPassword, includeProof) {
			var _this = this;

			var _virgilPythiaCrypto$b = this.virgilPythiaCrypto.blind(password),
			    blindedPassword = _virgilPythiaCrypto$b.blindedPassword,
			    blindingSecret = _virgilPythiaCrypto$b.blindingSecret;

			var proofKey = this.proofKeys.proofKey(breachProofPassword.version);

			return this.accessTokenProvider.getToken(makeTokenContext()).then(function (accessToken) {
				return _this.client.transformPassword({
					blindedPassword: blindedPassword,
					salt: breachProofPassword.salt,
					version: breachProofPassword.version,
					includeProof: includeProof,
					token: accessToken.toString()
				});
			}).then(function (_ref) {
				var transformedPassword = _ref.transformedPassword,
				    proof = _ref.proof;

				if (includeProof) {
					var verified = _this.virgilPythiaCrypto.verify({
						transformedPassword: transformedPassword,
						blindedPassword: blindedPassword,
						tweak: breachProofPassword.salt,
						transformationPublicKey: proofKey.key,
						proofValueC: proof.valueC,
						proofValueU: proof.valueU
					});

					if (!verified) {
						throw new ProofVerificationFailedError();
					}
				}

				var deblindedPassword = _this.virgilPythiaCrypto.deblind({ transformedPassword: transformedPassword, blindingSecret: blindingSecret });
				return constantTimeEqual(deblindedPassword, breachProofPassword.deblindedPassword);
			});
		}

		/**
   * Creates a breach-proof password from the given plaintext `password`.
   *
   * @param password - The plaintext password.
   *
   * @returns {Promise<BreachProofPassword>}
   */

	}, {
		key: 'createBreachProofPassword',
		value: function createBreachProofPassword(password) {
			var _this2 = this;

			var salt = this.virgilCrypto.getRandomBytes(SALT_BYTE_LENGTH);

			var _virgilPythiaCrypto$b2 = this.virgilPythiaCrypto.blind(password),
			    blindedPassword = _virgilPythiaCrypto$b2.blindedPassword,
			    blindingSecret = _virgilPythiaCrypto$b2.blindingSecret;

			var latestProofKey = this.proofKeys.currentKey();

			return this.accessTokenProvider.getToken(makeTokenContext()).then(function (accessToken) {
				return _this2.client.transformPassword({
					blindedPassword: blindedPassword,
					salt: salt,
					version: latestProofKey.version,
					includeProof: true,
					token: accessToken.toString()
				});
			}).then(function (_ref2) {
				var transformedPassword = _ref2.transformedPassword,
				    proof = _ref2.proof;

				var verified = _this2.virgilPythiaCrypto.verify({
					transformedPassword: transformedPassword,
					blindedPassword: blindedPassword,
					tweak: salt,
					transformationPublicKey: latestProofKey.key,
					proofValueC: proof.valueC,
					proofValueU: proof.valueU
				});

				if (!verified) {
					throw new ProofVerificationFailedError();
				}

				var deblindedPassword = _this2.virgilPythiaCrypto.deblind({ transformedPassword: transformedPassword, blindingSecret: blindingSecret });
				return new BreachProofPassword(salt, deblindedPassword, latestProofKey.version);
			});
		}

		/**
   * Generates a new breach-proof password based on the current `breachProofPassword`
   * and `updateToken`.
   *
   * @param updateToken - The password update token. You can get it at Virgil Developer Dashboard.
   * @param breachProofPassword - The current breach-proof password.
   *
   * @returns {BreachProofPassword} - The new breach-proof password.
   */

	}, {
		key: 'updateBreachProofPassword',
		value: function updateBreachProofPassword(updateToken, breachProofPassword) {
			var _parseUpdateToken = parseUpdateToken(updateToken),
			    prevVersion = _parseUpdateToken.prevVersion,
			    nextVersion = _parseUpdateToken.nextVersion,
			    token = _parseUpdateToken.token;

			if (breachProofPassword.version !== prevVersion) {
				throw new UnexpectedBreachProofPasswordVersionError(prevVersion, breachProofPassword.version);
			}

			var newDeblindedPassword = this.virgilPythiaCrypto.updateDeblindedWithToken({
				deblindedPassword: breachProofPassword.deblindedPassword,
				updateToken: token
			});
			return new BreachProofPassword(breachProofPassword.salt, newDeblindedPassword, nextVersion);
		}
	}]);
	return Pythia;
}();

function parseUpdateToken(updateToken) {
	var parts = updateToken.split('.');
	if (parts.length !== 4 || parts[0] !== 'UT') {
		throw new Error('UpdateToken string is invalid');
	}

	return {
		prevVersion: Number(parts[1]),
		nextVersion: Number(parts[2]),
		token: Buffer.from(parts[3], 'base64')
	};
}

function makeTokenContext() {
	return {
		service: 'pythia',
		identity: 'PYTHIA-CLIENT',
		operation: 'transform',
		forceReload: false
	};
}

/**
 * Class responsible for sending HTTP requests to
 * Virgil Pythia service.
 *
 * @hidden
 */
var Connection = function () {
	function Connection(baseUrl) {
		classCallCheck(this, Connection);

		this.baseUrl = baseUrl;
	}

	createClass(Connection, [{
		key: 'send',
		value: function send(url, opts) {
			opts = normalizeOptions(opts);
			return fetch__default(this.baseUrl + url, opts).then(function (response) {
				if (!response.ok) {
					return response.json().then(function (reason) {
						var message = reason.message || response.statusText;
						throw new PythiaClientError(message, reason.code, response.status);
					});
				}

				return response.json();
			});
		}
	}]);
	return Connection;
}();

function normalizeOptions(opts) {
	opts = Object.assign({}, opts);

	var headers = new fetch.Headers(opts.headers || {});
	if (opts.accessToken && !headers.has('Authorization')) {
		headers.set('Authorization', 'Virgil ' + opts.accessToken);
		delete opts.accessToken;
	}

	opts.headers = headers;

	if (opts.body) {
		var json = JSON.stringify(opts.body);
		if (!headers.has('Content-Type')) {
			headers.set('Content-Type', 'application/json');
		}

		opts.body = json;
		opts.method = (opts.method || 'POST').toUpperCase();
	} else {
		opts.method = (opts.method || 'GET').toUpperCase();
	}

	return opts;
}

/**
 * Virgil Pythia Service client.
 *
 * @hidden
 */
var PythiaClient = function () {

	/**
  * Creates a new instance of `PythiaClient`.
  * @param {string|Connection|null} apiUrl - Either the URL of the Virgil API
  * Service, or a {@link Connection} instance, or `null`.
  */
	function PythiaClient(apiUrl) {
		classCallCheck(this, PythiaClient);

		if (apiUrl == null) {
			this.connection = new Connection('https://api.virgilsecurity.com');
		} else if (typeof apiUrl === 'string') {
			this.connection = new Connection(apiUrl);
		} else {
			this.connection = apiUrl;
		}
	}

	/**
  * Sends a request to transform the blinded password.
  *
  * @param {Object} params - Input parameters.
  * @param {Buffer} params.salt - Arbitrary binary data identifying the user.
  * @param {Buffer} params.blindedPassword - The obfuscated user password.
  * @param {string} params.token - The access token to authenticate the request.
  * @param {number} [params.version] - Version of the user's password.
  * @param {boolean} [params.includeProof] - Indicates whether to include the cryptographic
  * proof in the response.
  *
  * @returns {Promise<{ transformedPassword: Buffer, proof?: { valueC: Buffer, valueU: Buffer } }>}
  */


	createClass(PythiaClient, [{
		key: 'transformPassword',
		value: function transformPassword(params) {
			var salt = params.salt,
			    blindedPassword = params.blindedPassword,
			    token = params.token,
			    version = params.version,
			    includeProof = params.includeProof;

			var body = {
				blinded_password: blindedPassword.toString('base64'),
				user_id: salt.toString('base64')
			};

			if (version) {
				body.version = version;
			}

			if (includeProof) {
				body.include_proof = includeProof;
			}

			return this.connection.send('/pythia/v1/password', {
				body: body,
				accessToken: token
			}).then(function (_ref) {
				var transformed_password = _ref.transformed_password,
				    proof = _ref.proof;

				var result = {
					transformedPassword: Buffer.from(transformed_password, 'base64')
				};

				if (includeProof) {
					result.proof = {
						valueC: Buffer.from(proof.value_c, 'base64'),
						valueU: Buffer.from(proof.value_u, 'base64')
					};
				}

				return result;
			});
		}

		/**
   * Sends a request to generate a pseudo-random value, that can be used as
   * a seed for asymmetric key pair generation, from the blinded password.
   * @param {Buffer} blindedPassword - The obfuscated user password.
   * @param {string} [brainKeyId] - Optional identifier of the brain key.
   * @param {string} token - The access token to authenticate the request.
   * @returns {Promise<Buffer>}
   */

	}, {
		key: 'generateSeed',
		value: function generateSeed(_ref2) {
			var blindedPassword = _ref2.blindedPassword,
			    brainKeyId = _ref2.brainKeyId,
			    token = _ref2.token;

			var body = {
				blinded_password: blindedPassword.toString('base64')
			};

			if (brainKeyId) {
				body.brainkey_id = brainKeyId;
			}

			return this.connection.send('/pythia/v1/brainkey', {
				body: body,
				accessToken: token
			}).then(function (_ref3) {
				var seed = _ref3.seed;
				return Buffer.from(seed, 'base64');
			});
		}
	}]);
	return PythiaClient;
}();

/**
 * Factory function used to create instances of {@link Pythia} class.
 * @param {Object} params - Dependencies needed for `Pythia`.
 * @param {VirgilCrypto} params.virgilCrypto - Instance of `VirgilCrypto`
 * class from `virgil-crypto` module.
 * @param {VirgilPythiaCrypto} params.virgilPythiaCrypto - Instance of `VirgilPythiaCrypto`
 * class from `virgil-crypto` module.
 * @param {IAccessTokenProvider} params.accessTokenProvider - Object implementing
 * the `IAccessTokenProvider` interface from `virgil-sdk` module.
 * @param {string|string[]} params.proofKeys - The proof key or an array of proof keys in
 * string format. The format must be the following:
 * 		`'PK.{version}.{base64-encoded-data}'`
 *
 * @returns {Pythia}
 */
function createPythia(params) {
	var virgilCrypto = params.virgilCrypto,
	    virgilPythiaCrypto = params.virgilPythiaCrypto,
	    accessTokenProvider = params.accessTokenProvider,
	    proofKeys = params.proofKeys,
	    apiUrl = params.apiUrl;


	requiredArg(virgilCrypto, 'virgilCrypto');
	requiredArg(virgilPythiaCrypto, 'virgilPythiaCrypto');
	requiredArg(accessTokenProvider, 'accessTokenProvider');
	requiredArg(proofKeys, 'proofKeys');

	return new Pythia({
		proofKeys: new ProofKeys(proofKeys),
		accessTokenProvider: accessTokenProvider,
		client: new PythiaClient(apiUrl),
		virgilCrypto: virgilCrypto,
		virgilPythiaCrypto: virgilPythiaCrypto
	});
}

function requiredArg(arg, argName) {
	if (arg == null) {
		throw new Error('Invalid Pythia parameters. "' + argName + '" is required.');
	}
}

/**
 * Pythia BrainKey.
 *
 * BrainKey instances are not meant to be created with the `new` keyword. Use
 * the {@link createBrainKey} function to instantiate a `BrainKey`.
 */
var BrainKey = function () {
	/**
  * Initializes a new instance of `BrainKey`.
  *
  * @protected
  *
  * @param client - The service client.
  * @param accessTokenProvider - The access token provider.
  * @param pythiaCrypto - Crypto operations provider.
  * @param keyPairType - Type of key pair to generate.
  */
	function BrainKey(_ref) {
		var client = _ref.client,
		    accessTokenProvider = _ref.accessTokenProvider,
		    virgilCrypto = _ref.virgilCrypto,
		    virgilPythiaCrypto = _ref.virgilPythiaCrypto,
		    keyPairType = _ref.keyPairType;
		classCallCheck(this, BrainKey);

		this.client = client;
		this.accessTokenProvider = accessTokenProvider;
		this.keyPairType = keyPairType;
		this.virgilCrypto = virgilCrypto;
		this.virgilPythiaCrypto = virgilPythiaCrypto;
	}

	/**
  * Asynchronously generates an asymmetric key pair based on the given
  * `password` and `brainKeyId`.
  *
  * @param password - The password to generate the key pair from.
  * @param brainKeyId - Optional brainKey identifier. Used when one needs
  * to generate several different key pairs from the single password.
  *
  * @returns {Promise<{ privateKey: IPrivateKey, publicKey: IPublicKey }>}
  */


	createClass(BrainKey, [{
		key: 'generateKeyPair',
		value: function generateKeyPair(password, brainKeyId) {
			var _this = this;

			var _virgilPythiaCrypto$b = this.virgilPythiaCrypto.blind(password),
			    blindedPassword = _virgilPythiaCrypto$b.blindedPassword,
			    blindingSecret = _virgilPythiaCrypto$b.blindingSecret;

			return this.accessTokenProvider.getToken(makeTokenContext$1()).then(function (accessToken) {
				return _this.client.generateSeed({
					blindedPassword: blindedPassword,
					brainKeyId: brainKeyId,
					token: accessToken.toString()
				});
			}).then(function (seed) {
				var deblindedPassword = _this.virgilPythiaCrypto.deblind({
					transformedPassword: seed,
					blindingSecret: blindingSecret
				});
				return _this.virgilCrypto.generateKeysFromKeyMaterial(deblindedPassword, _this.keyPairType);
			});
		}
	}]);
	return BrainKey;
}();

function makeTokenContext$1() {
	return {
		service: 'pythia',
		operation: 'seed',
		forceReload: false
	};
}

/**
 * Factory function to create instances of {@link BrainKey} class.
 *
 * @param {Object} params - Dependencies needed for `BrainKey`.
 * @param {VirgilCrypto} params.virgilCrypto - Instance of `VirgilCrypto`
 * class from `virgil-crypto` module.
 * @param {VirgilPythiaCrypto} params.virgilPythiaCrypto - Instance of `VirgilPythiaCrypto`
 * class from `virgil-crypto` module.
 * @param {IAccessTokenProvider} params.accessTokenProvider - Object implementing
 * the `IAccessTokenProvider` interface from `virgil-sdk` module.
 * @param {string} [params.keyPairType] - Type of keys to generate. For available
 * options see `KeyPairType` enum in `virgil-crypto` module. Optional. The
 * recommended type is used by default.
 *
 * @returns {BrainKey}
 */
function createBrainKey(params) {
	var virgilCrypto = params.virgilCrypto,
	    virgilPythiaCrypto = params.virgilPythiaCrypto,
	    accessTokenProvider = params.accessTokenProvider,
	    keyPairType = params.keyPairType,
	    apiUrl = params.apiUrl;


	requiredArg$1(virgilCrypto, 'virgilCrypto');
	requiredArg$1(virgilPythiaCrypto, 'virgilPythiaCrypto');
	requiredArg$1(accessTokenProvider, 'accessTokenProvider');

	return new BrainKey({
		keyPairType: keyPairType,
		accessTokenProvider: accessTokenProvider,
		client: new PythiaClient(apiUrl),
		virgilCrypto: virgilCrypto,
		virgilPythiaCrypto: virgilPythiaCrypto
	});
}

function requiredArg$1(arg, argName) {
	if (arg == null) {
		throw new Error('Invalid BrainKey parameters. "' + argName + '" is required.');
	}
}

exports.createPythia = createPythia;
exports.createBrainKey = createBrainKey;
exports.BreachProofPassword = BreachProofPassword;
exports.PythiaClientError = PythiaClientError;
exports.ProofVerificationFailedError = ProofVerificationFailedError;
exports.UnexpectedBreachProofPasswordVersionError = UnexpectedBreachProofPasswordVersionError;
