(function (global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
            typeof define === 'function' && define.amd ? define(['exports'], factory) :
            (factory((global.Virgil = {})));
}(this, (function (exports) { 'use strict';

            var global$1 = (typeof global !== "undefined" ? global :
                        typeof self !== "undefined" ? self :
                        typeof window !== "undefined" ? window : {});

            var lookup = [];
            var revLookup = [];
            var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
            var inited = false;
            function init () {
              inited = true;
              var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
              for (var i = 0, len = code.length; i < len; ++i) {
                lookup[i] = code[i];
                revLookup[code.charCodeAt(i)] = i;
              }

              revLookup['-'.charCodeAt(0)] = 62;
              revLookup['_'.charCodeAt(0)] = 63;
            }

            function toByteArray (b64) {
              if (!inited) {
                init();
              }
              var i, j, l, tmp, placeHolders, arr;
              var len = b64.length;

              if (len % 4 > 0) {
                throw new Error('Invalid string. Length must be a multiple of 4')
              }

              // the number of equal signs (place holders)
              // if there are two placeholders, than the two characters before it
              // represent one byte
              // if there is only one, then the three characters before it represent 2 bytes
              // this is just a cheap hack to not do indexOf twice
              placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

              // base64 is 4/3 + up to two characters of the original data
              arr = new Arr(len * 3 / 4 - placeHolders);

              // if there are placeholders, only get up to the last complete 4 chars
              l = placeHolders > 0 ? len - 4 : len;

              var L = 0;

              for (i = 0, j = 0; i < l; i += 4, j += 3) {
                tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
                arr[L++] = (tmp >> 16) & 0xFF;
                arr[L++] = (tmp >> 8) & 0xFF;
                arr[L++] = tmp & 0xFF;
              }

              if (placeHolders === 2) {
                tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
                arr[L++] = tmp & 0xFF;
              } else if (placeHolders === 1) {
                tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
                arr[L++] = (tmp >> 8) & 0xFF;
                arr[L++] = tmp & 0xFF;
              }

              return arr
            }

            function tripletToBase64 (num) {
              return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
            }

            function encodeChunk (uint8, start, end) {
              var tmp;
              var output = [];
              for (var i = start; i < end; i += 3) {
                tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
                output.push(tripletToBase64(tmp));
              }
              return output.join('')
            }

            function fromByteArray (uint8) {
              if (!inited) {
                init();
              }
              var tmp;
              var len = uint8.length;
              var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
              var output = '';
              var parts = [];
              var maxChunkLength = 16383; // must be multiple of 3

              // go through the array every three bytes, we'll deal with trailing stuff later
              for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
              }

              // pad the end with zeros, but make sure to not forget the extra bytes
              if (extraBytes === 1) {
                tmp = uint8[len - 1];
                output += lookup[tmp >> 2];
                output += lookup[(tmp << 4) & 0x3F];
                output += '==';
              } else if (extraBytes === 2) {
                tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
                output += lookup[tmp >> 10];
                output += lookup[(tmp >> 4) & 0x3F];
                output += lookup[(tmp << 2) & 0x3F];
                output += '=';
              }

              parts.push(output);

              return parts.join('')
            }

            function read (buffer, offset, isLE, mLen, nBytes) {
              var e, m;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var nBits = -7;
              var i = isLE ? (nBytes - 1) : 0;
              var d = isLE ? -1 : 1;
              var s = buffer[offset + i];

              i += d;

              e = s & ((1 << (-nBits)) - 1);
              s >>= (-nBits);
              nBits += eLen;
              for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

              m = e & ((1 << (-nBits)) - 1);
              e >>= (-nBits);
              nBits += mLen;
              for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

              if (e === 0) {
                e = 1 - eBias;
              } else if (e === eMax) {
                return m ? NaN : ((s ? -1 : 1) * Infinity)
              } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
              }
              return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
            }

            function write (buffer, value, offset, isLE, mLen, nBytes) {
              var e, m, c;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
              var i = isLE ? 0 : (nBytes - 1);
              var d = isLE ? 1 : -1;
              var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

              value = Math.abs(value);

              if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
              } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                  e--;
                  c *= 2;
                }
                if (e + eBias >= 1) {
                  value += rt / c;
                } else {
                  value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                  e++;
                  c /= 2;
                }

                if (e + eBias >= eMax) {
                  m = 0;
                  e = eMax;
                } else if (e + eBias >= 1) {
                  m = (value * c - 1) * Math.pow(2, mLen);
                  e = e + eBias;
                } else {
                  m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                  e = 0;
                }
              }

              for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

              e = (e << mLen) | m;
              eLen += mLen;
              for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

              buffer[offset + i - d] |= s * 128;
            }

            var toString = {}.toString;

            var isArray = Array.isArray || function (arr) {
              return toString.call(arr) == '[object Array]';
            };

            var INSPECT_MAX_BYTES = 50;

            /**
             * If `Buffer.TYPED_ARRAY_SUPPORT`:
             *   === true    Use Uint8Array implementation (fastest)
             *   === false   Use Object implementation (most compatible, even IE6)
             *
             * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
             * Opera 11.6+, iOS 4.2+.
             *
             * Due to various browser bugs, sometimes the Object implementation will be used even
             * when the browser supports typed arrays.
             *
             * Note:
             *
             *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
             *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
             *
             *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
             *
             *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
             *     incorrect length in some situations.

             * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
             * get the Object implementation, which is slower but behaves correctly.
             */
            Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
              ? global$1.TYPED_ARRAY_SUPPORT
              : true;

            function kMaxLength () {
              return Buffer.TYPED_ARRAY_SUPPORT
                ? 0x7fffffff
                : 0x3fffffff
            }

            function createBuffer (that, length) {
              if (kMaxLength() < length) {
                throw new RangeError('Invalid typed array length')
              }
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                // Return an augmented `Uint8Array` instance, for best performance
                that = new Uint8Array(length);
                that.__proto__ = Buffer.prototype;
              } else {
                // Fallback: Return an object instance of the Buffer class
                if (that === null) {
                  that = new Buffer(length);
                }
                that.length = length;
              }

              return that
            }

            /**
             * The Buffer constructor returns instances of `Uint8Array` that have their
             * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
             * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
             * and the `Uint8Array` methods. Square bracket notation works as expected -- it
             * returns a single octet.
             *
             * The `Uint8Array` prototype remains unmodified.
             */

            function Buffer (arg, encodingOrOffset, length) {
              if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
                return new Buffer(arg, encodingOrOffset, length)
              }

              // Common case.
              if (typeof arg === 'number') {
                if (typeof encodingOrOffset === 'string') {
                  throw new Error(
                    'If encoding is specified then the first argument must be a string'
                  )
                }
                return allocUnsafe(this, arg)
              }
              return from(this, arg, encodingOrOffset, length)
            }

            Buffer.poolSize = 8192; // not used by this implementation

            // TODO: Legacy, not needed anymore. Remove in next major version.
            Buffer._augment = function (arr) {
              arr.__proto__ = Buffer.prototype;
              return arr
            };

            function from (that, value, encodingOrOffset, length) {
              if (typeof value === 'number') {
                throw new TypeError('"value" argument must not be a number')
              }

              if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
                return fromArrayBuffer(that, value, encodingOrOffset, length)
              }

              if (typeof value === 'string') {
                return fromString(that, value, encodingOrOffset)
              }

              return fromObject(that, value)
            }

            /**
             * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
             * if value is a number.
             * Buffer.from(str[, encoding])
             * Buffer.from(array)
             * Buffer.from(buffer)
             * Buffer.from(arrayBuffer[, byteOffset[, length]])
             **/
            Buffer.from = function (value, encodingOrOffset, length) {
              return from(null, value, encodingOrOffset, length)
            };

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              Buffer.prototype.__proto__ = Uint8Array.prototype;
              Buffer.__proto__ = Uint8Array;
            }

            function assertSize (size) {
              if (typeof size !== 'number') {
                throw new TypeError('"size" argument must be a number')
              } else if (size < 0) {
                throw new RangeError('"size" argument must not be negative')
              }
            }

            function alloc (that, size, fill, encoding) {
              assertSize(size);
              if (size <= 0) {
                return createBuffer(that, size)
              }
              if (fill !== undefined) {
                // Only pay attention to encoding if it's a string. This
                // prevents accidentally sending in a number that would
                // be interpretted as a start offset.
                return typeof encoding === 'string'
                  ? createBuffer(that, size).fill(fill, encoding)
                  : createBuffer(that, size).fill(fill)
              }
              return createBuffer(that, size)
            }

            /**
             * Creates a new filled Buffer instance.
             * alloc(size[, fill[, encoding]])
             **/
            Buffer.alloc = function (size, fill, encoding) {
              return alloc(null, size, fill, encoding)
            };

            function allocUnsafe (that, size) {
              assertSize(size);
              that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
              if (!Buffer.TYPED_ARRAY_SUPPORT) {
                for (var i = 0; i < size; ++i) {
                  that[i] = 0;
                }
              }
              return that
            }

            /**
             * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
             * */
            Buffer.allocUnsafe = function (size) {
              return allocUnsafe(null, size)
            };
            /**
             * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
             */
            Buffer.allocUnsafeSlow = function (size) {
              return allocUnsafe(null, size)
            };

            function fromString (that, string, encoding) {
              if (typeof encoding !== 'string' || encoding === '') {
                encoding = 'utf8';
              }

              if (!Buffer.isEncoding(encoding)) {
                throw new TypeError('"encoding" must be a valid string encoding')
              }

              var length = byteLength(string, encoding) | 0;
              that = createBuffer(that, length);

              var actual = that.write(string, encoding);

              if (actual !== length) {
                // Writing a hex string, for example, that contains invalid characters will
                // cause everything after the first invalid character to be ignored. (e.g.
                // 'abxxcd' will be treated as 'ab')
                that = that.slice(0, actual);
              }

              return that
            }

            function fromArrayLike (that, array) {
              var length = array.length < 0 ? 0 : checked(array.length) | 0;
              that = createBuffer(that, length);
              for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255;
              }
              return that
            }

            function fromArrayBuffer (that, array, byteOffset, length) {
              array.byteLength; // this throws if `array` is not a valid ArrayBuffer

              if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError('\'offset\' is out of bounds')
              }

              if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError('\'length\' is out of bounds')
              }

              if (byteOffset === undefined && length === undefined) {
                array = new Uint8Array(array);
              } else if (length === undefined) {
                array = new Uint8Array(array, byteOffset);
              } else {
                array = new Uint8Array(array, byteOffset, length);
              }

              if (Buffer.TYPED_ARRAY_SUPPORT) {
                // Return an augmented `Uint8Array` instance, for best performance
                that = array;
                that.__proto__ = Buffer.prototype;
              } else {
                // Fallback: Return an object instance of the Buffer class
                that = fromArrayLike(that, array);
              }
              return that
            }

            function fromObject (that, obj) {
              if (internalIsBuffer(obj)) {
                var len = checked(obj.length) | 0;
                that = createBuffer(that, len);

                if (that.length === 0) {
                  return that
                }

                obj.copy(that, 0, 0, len);
                return that
              }

              if (obj) {
                if ((typeof ArrayBuffer !== 'undefined' &&
                    obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
                  if (typeof obj.length !== 'number' || isnan(obj.length)) {
                    return createBuffer(that, 0)
                  }
                  return fromArrayLike(that, obj)
                }

                if (obj.type === 'Buffer' && isArray(obj.data)) {
                  return fromArrayLike(that, obj.data)
                }
              }

              throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
            }

            function checked (length) {
              // Note: cannot use `length < kMaxLength()` here because that fails when
              // length is NaN (which is otherwise coerced to zero.)
              if (length >= kMaxLength()) {
                throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                                     'size: 0x' + kMaxLength().toString(16) + ' bytes')
              }
              return length | 0
            }
            Buffer.isBuffer = isBuffer;
            function internalIsBuffer (b) {
              return !!(b != null && b._isBuffer)
            }

            Buffer.compare = function compare (a, b) {
              if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
                throw new TypeError('Arguments must be Buffers')
              }

              if (a === b) return 0

              var x = a.length;
              var y = b.length;

              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                  x = a[i];
                  y = b[i];
                  break
                }
              }

              if (x < y) return -1
              if (y < x) return 1
              return 0
            };

            Buffer.isEncoding = function isEncoding (encoding) {
              switch (String(encoding).toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'latin1':
                case 'binary':
                case 'base64':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return true
                default:
                  return false
              }
            };

            Buffer.concat = function concat (list, length) {
              if (!isArray(list)) {
                throw new TypeError('"list" argument must be an Array of Buffers')
              }

              if (list.length === 0) {
                return Buffer.alloc(0)
              }

              var i;
              if (length === undefined) {
                length = 0;
                for (i = 0; i < list.length; ++i) {
                  length += list[i].length;
                }
              }

              var buffer = Buffer.allocUnsafe(length);
              var pos = 0;
              for (i = 0; i < list.length; ++i) {
                var buf = list[i];
                if (!internalIsBuffer(buf)) {
                  throw new TypeError('"list" argument must be an Array of Buffers')
                }
                buf.copy(buffer, pos);
                pos += buf.length;
              }
              return buffer
            };

            function byteLength (string, encoding) {
              if (internalIsBuffer(string)) {
                return string.length
              }
              if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
                  (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                return string.byteLength
              }
              if (typeof string !== 'string') {
                string = '' + string;
              }

              var len = string.length;
              if (len === 0) return 0

              // Use a for loop to avoid recursion
              var loweredCase = false;
              for (;;) {
                switch (encoding) {
                  case 'ascii':
                  case 'latin1':
                  case 'binary':
                    return len
                  case 'utf8':
                  case 'utf-8':
                  case undefined:
                    return utf8ToBytes(string).length
                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return len * 2
                  case 'hex':
                    return len >>> 1
                  case 'base64':
                    return base64ToBytes(string).length
                  default:
                    if (loweredCase) return utf8ToBytes(string).length // assume utf8
                    encoding = ('' + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer.byteLength = byteLength;

            function slowToString (encoding, start, end) {
              var loweredCase = false;

              // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
              // property of a typed array.

              // This behaves neither like String nor Uint8Array in that we set start/end
              // to their upper/lower bounds if the value passed is out of range.
              // undefined is handled specially as per ECMA-262 6th Edition,
              // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
              if (start === undefined || start < 0) {
                start = 0;
              }
              // Return early if start > this.length. Done here to prevent potential uint32
              // coercion fail below.
              if (start > this.length) {
                return ''
              }

              if (end === undefined || end > this.length) {
                end = this.length;
              }

              if (end <= 0) {
                return ''
              }

              // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
              end >>>= 0;
              start >>>= 0;

              if (end <= start) {
                return ''
              }

              if (!encoding) encoding = 'utf8';

              while (true) {
                switch (encoding) {
                  case 'hex':
                    return hexSlice(this, start, end)

                  case 'utf8':
                  case 'utf-8':
                    return utf8Slice(this, start, end)

                  case 'ascii':
                    return asciiSlice(this, start, end)

                  case 'latin1':
                  case 'binary':
                    return latin1Slice(this, start, end)

                  case 'base64':
                    return base64Slice(this, start, end)

                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return utf16leSlice(this, start, end)

                  default:
                    if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                    encoding = (encoding + '').toLowerCase();
                    loweredCase = true;
                }
              }
            }

            // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
            // Buffer instances.
            Buffer.prototype._isBuffer = true;

            function swap (b, n, m) {
              var i = b[n];
              b[n] = b[m];
              b[m] = i;
            }

            Buffer.prototype.swap16 = function swap16 () {
              var len = this.length;
              if (len % 2 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 16-bits')
              }
              for (var i = 0; i < len; i += 2) {
                swap(this, i, i + 1);
              }
              return this
            };

            Buffer.prototype.swap32 = function swap32 () {
              var len = this.length;
              if (len % 4 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 32-bits')
              }
              for (var i = 0; i < len; i += 4) {
                swap(this, i, i + 3);
                swap(this, i + 1, i + 2);
              }
              return this
            };

            Buffer.prototype.swap64 = function swap64 () {
              var len = this.length;
              if (len % 8 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 64-bits')
              }
              for (var i = 0; i < len; i += 8) {
                swap(this, i, i + 7);
                swap(this, i + 1, i + 6);
                swap(this, i + 2, i + 5);
                swap(this, i + 3, i + 4);
              }
              return this
            };

            Buffer.prototype.toString = function toString () {
              var length = this.length | 0;
              if (length === 0) return ''
              if (arguments.length === 0) return utf8Slice(this, 0, length)
              return slowToString.apply(this, arguments)
            };

            Buffer.prototype.equals = function equals (b) {
              if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
              if (this === b) return true
              return Buffer.compare(this, b) === 0
            };

            Buffer.prototype.inspect = function inspect () {
              var str = '';
              var max = INSPECT_MAX_BYTES;
              if (this.length > 0) {
                str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
                if (this.length > max) str += ' ... ';
              }
              return '<Buffer ' + str + '>'
            };

            Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
              if (!internalIsBuffer(target)) {
                throw new TypeError('Argument must be a Buffer')
              }

              if (start === undefined) {
                start = 0;
              }
              if (end === undefined) {
                end = target ? target.length : 0;
              }
              if (thisStart === undefined) {
                thisStart = 0;
              }
              if (thisEnd === undefined) {
                thisEnd = this.length;
              }

              if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError('out of range index')
              }

              if (thisStart >= thisEnd && start >= end) {
                return 0
              }
              if (thisStart >= thisEnd) {
                return -1
              }
              if (start >= end) {
                return 1
              }

              start >>>= 0;
              end >>>= 0;
              thisStart >>>= 0;
              thisEnd >>>= 0;

              if (this === target) return 0

              var x = thisEnd - thisStart;
              var y = end - start;
              var len = Math.min(x, y);

              var thisCopy = this.slice(thisStart, thisEnd);
              var targetCopy = target.slice(start, end);

              for (var i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                  x = thisCopy[i];
                  y = targetCopy[i];
                  break
                }
              }

              if (x < y) return -1
              if (y < x) return 1
              return 0
            };

            // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
            // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
            //
            // Arguments:
            // - buffer - a Buffer to search
            // - val - a string, Buffer, or number
            // - byteOffset - an index into `buffer`; will be clamped to an int32
            // - encoding - an optional encoding, relevant is val is a string
            // - dir - true for indexOf, false for lastIndexOf
            function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
              // Empty buffer means no match
              if (buffer.length === 0) return -1

              // Normalize byteOffset
              if (typeof byteOffset === 'string') {
                encoding = byteOffset;
                byteOffset = 0;
              } else if (byteOffset > 0x7fffffff) {
                byteOffset = 0x7fffffff;
              } else if (byteOffset < -0x80000000) {
                byteOffset = -0x80000000;
              }
              byteOffset = +byteOffset;  // Coerce to Number.
              if (isNaN(byteOffset)) {
                // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                byteOffset = dir ? 0 : (buffer.length - 1);
              }

              // Normalize byteOffset: negative offsets start from the end of the buffer
              if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
              if (byteOffset >= buffer.length) {
                if (dir) return -1
                else byteOffset = buffer.length - 1;
              } else if (byteOffset < 0) {
                if (dir) byteOffset = 0;
                else return -1
              }

              // Normalize val
              if (typeof val === 'string') {
                val = Buffer.from(val, encoding);
              }

              // Finally, search either indexOf (if dir is true) or lastIndexOf
              if (internalIsBuffer(val)) {
                // Special case: looking for empty string/buffer always fails
                if (val.length === 0) {
                  return -1
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
              } else if (typeof val === 'number') {
                val = val & 0xFF; // Search for a byte value [0-255]
                if (Buffer.TYPED_ARRAY_SUPPORT &&
                    typeof Uint8Array.prototype.indexOf === 'function') {
                  if (dir) {
                    return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
                  } else {
                    return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
                  }
                }
                return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
              }

              throw new TypeError('val must be string, number or Buffer')
            }

            function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
              var indexSize = 1;
              var arrLength = arr.length;
              var valLength = val.length;

              if (encoding !== undefined) {
                encoding = String(encoding).toLowerCase();
                if (encoding === 'ucs2' || encoding === 'ucs-2' ||
                    encoding === 'utf16le' || encoding === 'utf-16le') {
                  if (arr.length < 2 || val.length < 2) {
                    return -1
                  }
                  indexSize = 2;
                  arrLength /= 2;
                  valLength /= 2;
                  byteOffset /= 2;
                }
              }

              function read$$1 (buf, i) {
                if (indexSize === 1) {
                  return buf[i]
                } else {
                  return buf.readUInt16BE(i * indexSize)
                }
              }

              var i;
              if (dir) {
                var foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) {
                  if (read$$1(arr, i) === read$$1(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                    if (foundIndex === -1) foundIndex = i;
                    if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
                  } else {
                    if (foundIndex !== -1) i -= i - foundIndex;
                    foundIndex = -1;
                  }
                }
              } else {
                if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                for (i = byteOffset; i >= 0; i--) {
                  var found = true;
                  for (var j = 0; j < valLength; j++) {
                    if (read$$1(arr, i + j) !== read$$1(val, j)) {
                      found = false;
                      break
                    }
                  }
                  if (found) return i
                }
              }

              return -1
            }

            Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
              return this.indexOf(val, byteOffset, encoding) !== -1
            };

            Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
            };

            Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
            };

            function hexWrite (buf, string, offset, length) {
              offset = Number(offset) || 0;
              var remaining = buf.length - offset;
              if (!length) {
                length = remaining;
              } else {
                length = Number(length);
                if (length > remaining) {
                  length = remaining;
                }
              }

              // must be an even number of digits
              var strLen = string.length;
              if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

              if (length > strLen / 2) {
                length = strLen / 2;
              }
              for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string.substr(i * 2, 2), 16);
                if (isNaN(parsed)) return i
                buf[offset + i] = parsed;
              }
              return i
            }

            function utf8Write (buf, string, offset, length) {
              return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
            }

            function asciiWrite (buf, string, offset, length) {
              return blitBuffer(asciiToBytes(string), buf, offset, length)
            }

            function latin1Write (buf, string, offset, length) {
              return asciiWrite(buf, string, offset, length)
            }

            function base64Write (buf, string, offset, length) {
              return blitBuffer(base64ToBytes(string), buf, offset, length)
            }

            function ucs2Write (buf, string, offset, length) {
              return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
            }

            Buffer.prototype.write = function write$$1 (string, offset, length, encoding) {
              // Buffer#write(string)
              if (offset === undefined) {
                encoding = 'utf8';
                length = this.length;
                offset = 0;
              // Buffer#write(string, encoding)
              } else if (length === undefined && typeof offset === 'string') {
                encoding = offset;
                length = this.length;
                offset = 0;
              // Buffer#write(string, offset[, length][, encoding])
              } else if (isFinite(offset)) {
                offset = offset | 0;
                if (isFinite(length)) {
                  length = length | 0;
                  if (encoding === undefined) encoding = 'utf8';
                } else {
                  encoding = length;
                  length = undefined;
                }
              // legacy write(string, encoding, offset, length) - remove in v0.13
              } else {
                throw new Error(
                  'Buffer.write(string, encoding, offset[, length]) is no longer supported'
                )
              }

              var remaining = this.length - offset;
              if (length === undefined || length > remaining) length = remaining;

              if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                throw new RangeError('Attempt to write outside buffer bounds')
              }

              if (!encoding) encoding = 'utf8';

              var loweredCase = false;
              for (;;) {
                switch (encoding) {
                  case 'hex':
                    return hexWrite(this, string, offset, length)

                  case 'utf8':
                  case 'utf-8':
                    return utf8Write(this, string, offset, length)

                  case 'ascii':
                    return asciiWrite(this, string, offset, length)

                  case 'latin1':
                  case 'binary':
                    return latin1Write(this, string, offset, length)

                  case 'base64':
                    // Warning: maxLength not taken into account in base64Write
                    return base64Write(this, string, offset, length)

                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return ucs2Write(this, string, offset, length)

                  default:
                    if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                    encoding = ('' + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            };

            Buffer.prototype.toJSON = function toJSON () {
              return {
                type: 'Buffer',
                data: Array.prototype.slice.call(this._arr || this, 0)
              }
            };

            function base64Slice (buf, start, end) {
              if (start === 0 && end === buf.length) {
                return fromByteArray(buf)
              } else {
                return fromByteArray(buf.slice(start, end))
              }
            }

            function utf8Slice (buf, start, end) {
              end = Math.min(buf.length, end);
              var res = [];

              var i = start;
              while (i < end) {
                var firstByte = buf[i];
                var codePoint = null;
                var bytesPerSequence = (firstByte > 0xEF) ? 4
                  : (firstByte > 0xDF) ? 3
                  : (firstByte > 0xBF) ? 2
                  : 1;

                if (i + bytesPerSequence <= end) {
                  var secondByte, thirdByte, fourthByte, tempCodePoint;

                  switch (bytesPerSequence) {
                    case 1:
                      if (firstByte < 0x80) {
                        codePoint = firstByte;
                      }
                      break
                    case 2:
                      secondByte = buf[i + 1];
                      if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                        if (tempCodePoint > 0x7F) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break
                    case 3:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break
                    case 4:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      fourthByte = buf[i + 3];
                      if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                          codePoint = tempCodePoint;
                        }
                      }
                  }
                }

                if (codePoint === null) {
                  // we did not generate a valid codePoint so insert a
                  // replacement char (U+FFFD) and advance only 1 byte
                  codePoint = 0xFFFD;
                  bytesPerSequence = 1;
                } else if (codePoint > 0xFFFF) {
                  // encode to utf16 (surrogate pair dance)
                  codePoint -= 0x10000;
                  res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                  codePoint = 0xDC00 | codePoint & 0x3FF;
                }

                res.push(codePoint);
                i += bytesPerSequence;
              }

              return decodeCodePointsArray(res)
            }

            // Based on http://stackoverflow.com/a/22747272/680742, the browser with
            // the lowest limit is Chrome, with 0x10000 args.
            // We go 1 magnitude less, for safety
            var MAX_ARGUMENTS_LENGTH = 0x1000;

            function decodeCodePointsArray (codePoints) {
              var len = codePoints.length;
              if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
              }

              // Decode in chunks to avoid "call stack size exceeded".
              var res = '';
              var i = 0;
              while (i < len) {
                res += String.fromCharCode.apply(
                  String,
                  codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                );
              }
              return res
            }

            function asciiSlice (buf, start, end) {
              var ret = '';
              end = Math.min(buf.length, end);

              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 0x7F);
              }
              return ret
            }

            function latin1Slice (buf, start, end) {
              var ret = '';
              end = Math.min(buf.length, end);

              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i]);
              }
              return ret
            }

            function hexSlice (buf, start, end) {
              var len = buf.length;

              if (!start || start < 0) start = 0;
              if (!end || end < 0 || end > len) end = len;

              var out = '';
              for (var i = start; i < end; ++i) {
                out += toHex(buf[i]);
              }
              return out
            }

            function utf16leSlice (buf, start, end) {
              var bytes = buf.slice(start, end);
              var res = '';
              for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
              }
              return res
            }

            Buffer.prototype.slice = function slice (start, end) {
              var len = this.length;
              start = ~~start;
              end = end === undefined ? len : ~~end;

              if (start < 0) {
                start += len;
                if (start < 0) start = 0;
              } else if (start > len) {
                start = len;
              }

              if (end < 0) {
                end += len;
                if (end < 0) end = 0;
              } else if (end > len) {
                end = len;
              }

              if (end < start) end = start;

              var newBuf;
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                newBuf = this.subarray(start, end);
                newBuf.__proto__ = Buffer.prototype;
              } else {
                var sliceLen = end - start;
                newBuf = new Buffer(sliceLen, undefined);
                for (var i = 0; i < sliceLen; ++i) {
                  newBuf[i] = this[i + start];
                }
              }

              return newBuf
            };

            /*
             * Need to make sure that buffer isn't trying to write out of bounds.
             */
            function checkOffset (offset, ext, length) {
              if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
              if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
            }

            Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul;
              }

              return val
            };

            Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                checkOffset(offset, byteLength, this.length);
              }

              var val = this[offset + --byteLength];
              var mul = 1;
              while (byteLength > 0 && (mul *= 0x100)) {
                val += this[offset + --byteLength] * mul;
              }

              return val
            };

            Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 1, this.length);
              return this[offset]
            };

            Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              return this[offset] | (this[offset + 1] << 8)
            };

            Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              return (this[offset] << 8) | this[offset + 1]
            };

            Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);

              return ((this[offset]) |
                  (this[offset + 1] << 8) |
                  (this[offset + 2] << 16)) +
                  (this[offset + 3] * 0x1000000)
            };

            Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (this[offset] * 0x1000000) +
                ((this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                this[offset + 3])
            };

            Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul;
              }
              mul *= 0x80;

              if (val >= mul) val -= Math.pow(2, 8 * byteLength);

              return val
            };

            Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var i = byteLength;
              var mul = 1;
              var val = this[offset + --i];
              while (i > 0 && (mul *= 0x100)) {
                val += this[offset + --i] * mul;
              }
              mul *= 0x80;

              if (val >= mul) val -= Math.pow(2, 8 * byteLength);

              return val
            };

            Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 1, this.length);
              if (!(this[offset] & 0x80)) return (this[offset])
              return ((0xff - this[offset] + 1) * -1)
            };

            Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              var val = this[offset] | (this[offset + 1] << 8);
              return (val & 0x8000) ? val | 0xFFFF0000 : val
            };

            Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              var val = this[offset + 1] | (this[offset] << 8);
              return (val & 0x8000) ? val | 0xFFFF0000 : val
            };

            Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (this[offset]) |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16) |
                (this[offset + 3] << 24)
            };

            Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (this[offset] << 24) |
                (this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                (this[offset + 3])
            };

            Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return read(this, offset, true, 23, 4)
            };

            Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return read(this, offset, false, 23, 4)
            };

            Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 8, this.length);
              return read(this, offset, true, 52, 8)
            };

            Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 8, this.length);
              return read(this, offset, false, 52, 8)
            };

            function checkInt (buf, value, offset, ext, max, min) {
              if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
              if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
              if (offset + ext > buf.length) throw new RangeError('Index out of range')
            }

            Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
              }

              var mul = 1;
              var i = 0;
              this[offset] = value & 0xFF;
              while (++i < byteLength && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xFF;
              }

              return offset + byteLength
            };

            Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
              }

              var i = byteLength - 1;
              var mul = 1;
              this[offset + i] = value & 0xFF;
              while (--i >= 0 && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xFF;
              }

              return offset + byteLength
            };

            Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
              if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
              this[offset] = (value & 0xff);
              return offset + 1
            };

            function objectWriteUInt16 (buf, value, offset, littleEndian) {
              if (value < 0) value = 0xffff + value + 1;
              for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
                buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                  (littleEndian ? i : 1 - i) * 8;
              }
            }

            Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
              } else {
                objectWriteUInt16(this, value, offset, true);
              }
              return offset + 2
            };

            Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 8);
                this[offset + 1] = (value & 0xff);
              } else {
                objectWriteUInt16(this, value, offset, false);
              }
              return offset + 2
            };

            function objectWriteUInt32 (buf, value, offset, littleEndian) {
              if (value < 0) value = 0xffffffff + value + 1;
              for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
                buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
              }
            }

            Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset + 3] = (value >>> 24);
                this[offset + 2] = (value >>> 16);
                this[offset + 1] = (value >>> 8);
                this[offset] = (value & 0xff);
              } else {
                objectWriteUInt32(this, value, offset, true);
              }
              return offset + 4
            };

            Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 24);
                this[offset + 1] = (value >>> 16);
                this[offset + 2] = (value >>> 8);
                this[offset + 3] = (value & 0xff);
              } else {
                objectWriteUInt32(this, value, offset, false);
              }
              return offset + 4
            };

            Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);

                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }

              var i = 0;
              var mul = 1;
              var sub = 0;
              this[offset] = value & 0xFF;
              while (++i < byteLength && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
              }

              return offset + byteLength
            };

            Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);

                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }

              var i = byteLength - 1;
              var mul = 1;
              var sub = 0;
              this[offset + i] = value & 0xFF;
              while (--i >= 0 && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
              }

              return offset + byteLength
            };

            Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
              if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
              if (value < 0) value = 0xff + value + 1;
              this[offset] = (value & 0xff);
              return offset + 1
            };

            Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
              } else {
                objectWriteUInt16(this, value, offset, true);
              }
              return offset + 2
            };

            Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 8);
                this[offset + 1] = (value & 0xff);
              } else {
                objectWriteUInt16(this, value, offset, false);
              }
              return offset + 2
            };

            Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
                this[offset + 2] = (value >>> 16);
                this[offset + 3] = (value >>> 24);
              } else {
                objectWriteUInt32(this, value, offset, true);
              }
              return offset + 4
            };

            Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
              if (value < 0) value = 0xffffffff + value + 1;
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 24);
                this[offset + 1] = (value >>> 16);
                this[offset + 2] = (value >>> 8);
                this[offset + 3] = (value & 0xff);
              } else {
                objectWriteUInt32(this, value, offset, false);
              }
              return offset + 4
            };

            function checkIEEE754 (buf, value, offset, ext, max, min) {
              if (offset + ext > buf.length) throw new RangeError('Index out of range')
              if (offset < 0) throw new RangeError('Index out of range')
            }

            function writeFloat (buf, value, offset, littleEndian, noAssert) {
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
              }
              write(buf, value, offset, littleEndian, 23, 4);
              return offset + 4
            }

            Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
              return writeFloat(this, value, offset, true, noAssert)
            };

            Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
              return writeFloat(this, value, offset, false, noAssert)
            };

            function writeDouble (buf, value, offset, littleEndian, noAssert) {
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
              }
              write(buf, value, offset, littleEndian, 52, 8);
              return offset + 8
            }

            Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
              return writeDouble(this, value, offset, true, noAssert)
            };

            Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
              return writeDouble(this, value, offset, false, noAssert)
            };

            // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
            Buffer.prototype.copy = function copy (target, targetStart, start, end) {
              if (!start) start = 0;
              if (!end && end !== 0) end = this.length;
              if (targetStart >= target.length) targetStart = target.length;
              if (!targetStart) targetStart = 0;
              if (end > 0 && end < start) end = start;

              // Copy 0 bytes; we're done
              if (end === start) return 0
              if (target.length === 0 || this.length === 0) return 0

              // Fatal error conditions
              if (targetStart < 0) {
                throw new RangeError('targetStart out of bounds')
              }
              if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
              if (end < 0) throw new RangeError('sourceEnd out of bounds')

              // Are we oob?
              if (end > this.length) end = this.length;
              if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
              }

              var len = end - start;
              var i;

              if (this === target && start < targetStart && targetStart < end) {
                // descending copy from end
                for (i = len - 1; i >= 0; --i) {
                  target[i + targetStart] = this[i + start];
                }
              } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                // ascending copy from start
                for (i = 0; i < len; ++i) {
                  target[i + targetStart] = this[i + start];
                }
              } else {
                Uint8Array.prototype.set.call(
                  target,
                  this.subarray(start, start + len),
                  targetStart
                );
              }

              return len
            };

            // Usage:
            //    buffer.fill(number[, offset[, end]])
            //    buffer.fill(buffer[, offset[, end]])
            //    buffer.fill(string[, offset[, end]][, encoding])
            Buffer.prototype.fill = function fill (val, start, end, encoding) {
              // Handle string cases:
              if (typeof val === 'string') {
                if (typeof start === 'string') {
                  encoding = start;
                  start = 0;
                  end = this.length;
                } else if (typeof end === 'string') {
                  encoding = end;
                  end = this.length;
                }
                if (val.length === 1) {
                  var code = val.charCodeAt(0);
                  if (code < 256) {
                    val = code;
                  }
                }
                if (encoding !== undefined && typeof encoding !== 'string') {
                  throw new TypeError('encoding must be a string')
                }
                if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                  throw new TypeError('Unknown encoding: ' + encoding)
                }
              } else if (typeof val === 'number') {
                val = val & 255;
              }

              // Invalid ranges are not set to a default, so can range check early.
              if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError('Out of range index')
              }

              if (end <= start) {
                return this
              }

              start = start >>> 0;
              end = end === undefined ? this.length : end >>> 0;

              if (!val) val = 0;

              var i;
              if (typeof val === 'number') {
                for (i = start; i < end; ++i) {
                  this[i] = val;
                }
              } else {
                var bytes = internalIsBuffer(val)
                  ? val
                  : utf8ToBytes(new Buffer(val, encoding).toString());
                var len = bytes.length;
                for (i = 0; i < end - start; ++i) {
                  this[i + start] = bytes[i % len];
                }
              }

              return this
            };

            // HELPER FUNCTIONS
            // ================

            var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

            function base64clean (str) {
              // Node strips out invalid characters like \n and \t from the string, base64-js does not
              str = stringtrim(str).replace(INVALID_BASE64_RE, '');
              // Node converts strings with length < 2 to ''
              if (str.length < 2) return ''
              // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
              while (str.length % 4 !== 0) {
                str = str + '=';
              }
              return str
            }

            function stringtrim (str) {
              if (str.trim) return str.trim()
              return str.replace(/^\s+|\s+$/g, '')
            }

            function toHex (n) {
              if (n < 16) return '0' + n.toString(16)
              return n.toString(16)
            }

            function utf8ToBytes (string, units) {
              units = units || Infinity;
              var codePoint;
              var length = string.length;
              var leadSurrogate = null;
              var bytes = [];

              for (var i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i);

                // is surrogate component
                if (codePoint > 0xD7FF && codePoint < 0xE000) {
                  // last char was a lead
                  if (!leadSurrogate) {
                    // no lead yet
                    if (codePoint > 0xDBFF) {
                      // unexpected trail
                      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                      continue
                    } else if (i + 1 === length) {
                      // unpaired lead
                      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                      continue
                    }

                    // valid lead
                    leadSurrogate = codePoint;

                    continue
                  }

                  // 2 leads in a row
                  if (codePoint < 0xDC00) {
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    leadSurrogate = codePoint;
                    continue
                  }

                  // valid surrogate pair
                  codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
                } else if (leadSurrogate) {
                  // valid bmp char, but last char was a lead
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                }

                leadSurrogate = null;

                // encode utf8
                if (codePoint < 0x80) {
                  if ((units -= 1) < 0) break
                  bytes.push(codePoint);
                } else if (codePoint < 0x800) {
                  if ((units -= 2) < 0) break
                  bytes.push(
                    codePoint >> 0x6 | 0xC0,
                    codePoint & 0x3F | 0x80
                  );
                } else if (codePoint < 0x10000) {
                  if ((units -= 3) < 0) break
                  bytes.push(
                    codePoint >> 0xC | 0xE0,
                    codePoint >> 0x6 & 0x3F | 0x80,
                    codePoint & 0x3F | 0x80
                  );
                } else if (codePoint < 0x110000) {
                  if ((units -= 4) < 0) break
                  bytes.push(
                    codePoint >> 0x12 | 0xF0,
                    codePoint >> 0xC & 0x3F | 0x80,
                    codePoint >> 0x6 & 0x3F | 0x80,
                    codePoint & 0x3F | 0x80
                  );
                } else {
                  throw new Error('Invalid code point')
                }
              }

              return bytes
            }

            function asciiToBytes (str) {
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                // Node's code seems to be doing this and not & 0x7F..
                byteArray.push(str.charCodeAt(i) & 0xFF);
              }
              return byteArray
            }

            function utf16leToBytes (str, units) {
              var c, hi, lo;
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0) break

                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
              }

              return byteArray
            }


            function base64ToBytes (str) {
              return toByteArray(base64clean(str))
            }

            function blitBuffer (src, dst, offset, length) {
              for (var i = 0; i < length; ++i) {
                if ((i + offset >= dst.length) || (i >= src.length)) break
                dst[i + offset] = src[i];
              }
              return i
            }

            function isnan (val) {
              return val !== val // eslint-disable-line no-self-compare
            }


            // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
            // The _isBuffer check is for Safari 5-7 support, because it's missing
            // Object.prototype.constructor. Remove this eventually
            function isBuffer(obj) {
              return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
            }

            function isFastBuffer (obj) {
              return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
            }

            // For Node v0.10 support. Remove this eventually.
            function isSlowBuffer (obj) {
              return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
            }

            var BASE_64 = 'base64';
            /**
             * Decodes the base64 encoded string into a `Buffer` or `string` depending on
             * the presence of `outputEncoding` parameter.
             * @hidden
             * @param {string} input
             * @param {string} [outputEncoding] - If provided, specifies the output string
             * encoding.
             * @returns {Buffer|string}
             */
            function base64Decode(input, outputEncoding) {
                if (outputEncoding) {
                    return Buffer.from(input, BASE_64).toString(outputEncoding);
                }
                return Buffer.from(input, BASE_64);
            }
            /**
             * Encodes the `input` bytes into a string using base64 encoding.
             * If `input` is a string, it is first converted to byte array by decoding
             * it using `inputEncoding`.
             * @hidden
             * @param {Buffer | string} input
             * @param {string} inputEncoding
             * @returns {string}
             */
            function base64Encode(input, inputEncoding) {
                var buffer;
                if (Buffer.isBuffer(input)) {
                    buffer = input;
                }
                else if (inputEncoding && Buffer.isEncoding(inputEncoding)) {
                    buffer = Buffer.from(input, inputEncoding);
                }
                else {
                    buffer = Buffer.from(input);
                }
                return buffer.toString(BASE_64);
            }
            /**
             * Converts regular base64 encoded string to URL-safe base64 encoded string.
             * @hidden
             * @param {string} input - Regular base64 encoded string.
             * @returns {string} - URL-safe base64 encoded string.
             */
            function base64UrlFromBase64(input) {
                input = input.split('=')[0];
                input = input.replace(/\+/g, '-').replace(/\//g, '_');
                return input;
            }
            /**
             * Converts URL-safe base64 encoded string to regular base64 encoded string.
             * @hidden
             * @param {string} input - URL-safe base64 encoded string.
             * @returns {string} - Regular base64 encoded string.
             */
            function base64UrlToBase64(input) {
                input = input.replace(/-/g, '+').replace(/_/g, '/');
                switch (input.length % 4) {
                    case 0: break; // no padding needed
                    case 2:
                        input = input + '==';
                        break;
                    case 3:
                        input = input + '=';
                        break;
                    default:
                        throw new Error('Invalid base64 string');
                }
                return input;
            }
            /**
             * * Encodes the `input` bytes into a string using URL-safe base64 encoding.
             * If `input` is a string, it is first converted to byte array by decoding
             * it using `inputEncoding`.
             *
             * @hidden
             *
             * @param {string | Buffer} input - The input.
             * @param {string} inputEncoding - If `input` is a string, this parameter
             * specifies the encoding of the input string. If `input` is a `Buffer`, this
             * parameter is ignored.
             * @returns {string}
             */
            function base64UrlEncode(input, inputEncoding) {
                var output = base64Encode(input, inputEncoding);
                return base64UrlFromBase64(output);
            }
            /**
             * Decodes the URL-safe base64-encoded `input` string into a `Buffer` or
             * `string` depending on the presence of `outputEncoding` parameter.
             *
             * @hidden
             *
             * @param {string} input
             * @param {string} [outputEncoding] - If provided, specifies the output string
             * encoding.
             * @returns {Buffer|string}
             */
            function base64UrlDecode(input, outputEncoding) {
                input = base64UrlToBase64(input);
                if (outputEncoding) {
                    return base64Decode(input, outputEncoding);
                }
                return base64Decode(input);
            }

            /**
             * Converts javascript date object or timestamp in milliseconds
             * to Unix timestamp.
             *
             * @hidden
             *
             * @param {Date | number} date - The date or timestamp to convert.
             * @returns {number}
             */
            function getUnixTimestamp(date) {
                var time;
                if (typeof date === 'number') {
                    time = date;
                }
                else {
                    time = date.getTime();
                }
                return Math.floor(time / 1000);
            }
            /**
             * Adds the given number of seconds to the given date.
             *
             * @hidden
             *
             * @param {Date | number} date - The date to add seconds to.
             * If `date` is a `number` it is treated as a timestamp in milliseconds.
             * @param {number} seconds - The number of seconds to add.
             * @returns {Date} - The new date.
             */
            function addSeconds(date, seconds) {
                if (typeof date === 'number') {
                    return new Date(date + seconds * 1000);
                }
                return new Date(date.getTime() + seconds * 1000);
            }

            /**
             * JWT Subject.
             * @hidden
             */
            var SubjectPrefix = "identity-";
            /**
             * JWT Issuer.
             * @hidden
             */
            var IssuerPrefix = "virgil-";
            /**
             * Content type of the token. Used to convey structural information
             * about the JWT.
             * @hidden
             */
            var VirgilContentType = "virgil-jwt;v=1";
            /**
             * Media type of the JWT.
             * @hidden
             */
            var JwtContentType = "JWT";

            /**
             * Class representing the JWT providing access to the
             * Virgil Security APIs.
             * Implements {@link IAccessToken} interface.
             */
            var Jwt = /** @class */ (function () {
                function Jwt(header, body, signature) {
                    if (typeof header === 'string') {
                        var stringRepresentation = header;
                        var parts = stringRepresentation.split('.');
                        if (parts.length !== 3)
                            throw new Error('Wrong JWT format');
                        try {
                            this.header = JSON.parse(base64UrlDecode(parts[0], 'utf8'));
                            this.body = JSON.parse(base64UrlDecode(parts[1], 'utf8'));
                            this.signature = base64UrlToBase64(parts[2]);
                        }
                        catch (e) {
                            throw new Error('Wrong JWT format');
                        }
                        this.unsignedData = parts[0] + '.' + parts[1];
                        this.stringRepresentation = stringRepresentation;
                    }
                    else if (typeof header === 'object' && typeof body === 'object') {
                        this.header = header;
                        this.body = body;
                        this.signature = signature;
                        this.unsignedData = this.headerBase64() + '.' + this.bodyBase64();
                        this.stringRepresentation = this.signature == null
                            ? this.unsignedData
                            : this.unsignedData + '.' + this.signatureBase64();
                    }
                    else {
                        throw new TypeError('Invalid arguments for function Jwt. ' +
                            'Expected a string representation of a token, or header and body as objects');
                    }
                }
                /**
                 * Parses the string representation of the JWT into
                 * an object representation.
                 *
                 * @param {string} jwtStr - The JWT string. Must have the following format:
                 *
                 * `base64UrlEncode(Header) + "." + base64UrlEncode(Body) + "." + base64UrlEncode(Signature)`
                 *
                 * See the {@link https://jwt.io/introduction/ | Introduction to JWT} for more details.
                 *
                 * @returns {Jwt}
                 */
                Jwt.fromString = function (jwtStr) {
                    return new Jwt(jwtStr);
                };
                /**
                 * Returns the string representation of this JWT.
                 * @returns {string}
                 */
                Jwt.prototype.toString = function () {
                    return this.stringRepresentation;
                };
                /**
                 * Retrieves the identity that is the subject of this JWT.
                 * @returns {string}
                 */
                Jwt.prototype.identity = function () {
                    if (this.body.sub.indexOf(SubjectPrefix) !== 0) {
                        throw new Error('wrong sub format');
                    }
                    return this.body.sub.substr(SubjectPrefix.length);
                };
                /**
                 * Retrieves the application ID that is the issuer of this JWT.
                 * @returns {string}
                 */
                Jwt.prototype.appId = function () {
                    if (this.body.iss.indexOf(IssuerPrefix) !== 0) {
                        throw new Error('wrong iss format');
                    }
                    return this.body.iss.substr(IssuerPrefix.length);
                };
                /**
                 * Returns a boolean indicating whether this JWT is (or will be)
                 * expired at the given date or not.
                 *
                 * @param {Date} at - The date to check. Defaults to `new Date()`.
                 * @returns {boolean} - `true` if token is expired, otherwise `false`.
                 */
                Jwt.prototype.isExpired = function (at) {
                    if (at === void 0) { at = new Date; }
                    var now = getUnixTimestamp(at);
                    return this.body.exp < now;
                };
                Jwt.prototype.headerBase64 = function () {
                    return base64UrlEncode(JSON.stringify(this.header));
                };
                Jwt.prototype.bodyBase64 = function () {
                    return base64UrlEncode(JSON.stringify(this.body));
                };
                Jwt.prototype.signatureBase64 = function () {
                    return base64UrlFromBase64(this.signature);
                };
                return Jwt;
            }());

            /**
             * Test if `condition` is truthy. If it is not, an `Error` is thrown with a
             * `message` property equal to `message` parameter.
             * @hidden
             * @param {boolean} condition
             * @param {string} message
             */
            function assert(condition, message) {
                if (!condition) {
                    throw new Error(message);
                }
            }

            var DEFAULT_TOKEN_TTL = 20 * 60 * 1000; // 20 minutes
            /**
             * Class responsible for JWT generation.
             */
            var JwtGenerator = /** @class */ (function () {
                function JwtGenerator(options) {
                    validateOptions(options);
                    this.appId = options.appId;
                    this.apiKey = options.apiKey;
                    this.apiKeyId = options.apiKeyId;
                    this.accessTokenSigner = options.accessTokenSigner;
                    this.millisecondsToLive = options.millisecondsToLive !== undefined
                        ? Number(options.millisecondsToLive)
                        : DEFAULT_TOKEN_TTL;
                }
                /**
                 * Generates a token with the given identity as the subject and optional
                 * additional data.
                 * @param {string} identity - Identity to be associated with JWT (i.e.
                 * the Subject).
                 * @param {IExtraData} ada - Additional data to be encoded in the JWT.
                 * @returns {Jwt}
                 */
                JwtGenerator.prototype.generateToken = function (identity, ada) {
                    if (!identity) {
                        throw new TypeError('Illegal arguments for function `generateToken`. Argument `identity` is required.');
                    }
                    var iat = getUnixTimestamp(new Date());
                    var exp = getUnixTimestamp(new Date().getTime() + this.millisecondsToLive);
                    var body = {
                        iss: IssuerPrefix + this.appId,
                        sub: SubjectPrefix + identity,
                        iat: iat,
                        exp: exp,
                        ada: ada
                    };
                    var header = {
                        alg: this.accessTokenSigner.getAlgorithm(),
                        kid: this.apiKeyId,
                        typ: JwtContentType,
                        cty: VirgilContentType
                    };
                    var unsignedJwt = new Jwt(header, body);
                    var signature = this.accessTokenSigner.generateTokenSignature(unsignedJwt.unsignedData, this.apiKey);
                    return new Jwt(header, body, signature.toString('base64'));
                };
                return JwtGenerator;
            }());
            function validateOptions(opts) {
                var invalidOptionMessage = function (name) {
                    return "Invalid JwtGenerator options. `" + name + "` is required";
                };
                assert(opts != null, 'JwtGenerator options must be provided');
                assert(opts.apiKey != null, invalidOptionMessage('apiKey'));
                assert(opts.apiKeyId != null, invalidOptionMessage('apiKeyId'));
                assert(opts.appId != null, invalidOptionMessage('appId'));
                assert(opts.accessTokenSigner != null, invalidOptionMessage('accessTokenSigner'));
            }

            /**
             * Class responsible for verification of JWTs.
             */
            var JwtVerifier = /** @class */ (function () {
                function JwtVerifier(options) {
                    validateOptions$1(options);
                    this.accessTokenSigner = options.accessTokenSigner;
                    this.apiPublicKey = options.apiPublicKey;
                    this.apiKeyId = options.apiKeyId;
                }
                /**
                 * Verifies the validity of the given JWT.
                 * @param {Jwt} token - The JWT to verify.
                 * @returns {boolean}
                 */
                JwtVerifier.prototype.verifyToken = function (token) {
                    if (token == null) {
                        throw new Error('Token is empty');
                    }
                    if (!this.allFieldsAreCorrect(token)) {
                        return false;
                    }
                    return this.accessTokenSigner.verifyTokenSignature(token.unsignedData, token.signature, this.apiPublicKey);
                };
                JwtVerifier.prototype.allFieldsAreCorrect = function (token) {
                    return token.header.kid == this.apiKeyId
                        && token.header.alg == this.accessTokenSigner.getAlgorithm()
                        && token.header.cty == VirgilContentType
                        && token.header.typ == JwtContentType;
                };
                return JwtVerifier;
            }());
            function validateOptions$1(opts) {
                var invalidOptionMessage = function (name) {
                    return "Invalid JwtVerifier options. `" + name + "` is required";
                };
                assert(opts != null, 'JwtVerifier options must be provided');
                assert(opts.apiPublicKey != null, invalidOptionMessage('apiPublicKey'));
                assert(opts.apiKeyId != null, invalidOptionMessage('apiKeyId'));
                assert(opts.accessTokenSigner != null, invalidOptionMessage('accessTokenSigner'));
            }

            var TOKEN_EXPIRATION_MARGIN = 5;
            /**
             * Implementation of {@link IAccessTokenProvider} that caches the JWT
             * in memory while it's fresh (i.e. not expired) and uses the user-provided
             * callback function to get the JWT when requested by the clients.
             */
            var CachingJwtProvider = /** @class */ (function () {
                /**
                 * Creates a new instance of `CachingJwtProvider`.
                 * @param {GetJwtCallback} renewJwtFn - The function that will be called
                 * whenever the fresh JWT is needed. If the `renewJwtFn` returns the JWT
                 * as a string, it will be converted to {@link Jwt} instance automatically.
                 * @param {Jwt|string} [initialToken] - Optional initial JWT.
                 */
                function CachingJwtProvider(renewJwtFn, initialToken) {
                    var _this = this;
                    if (typeof renewJwtFn !== 'function') {
                        throw new TypeError('`renewJwtFn` must be a function');
                    }
                    if (initialToken) {
                        var jwt = void 0;
                        if (typeof initialToken === 'string') {
                            jwt = Jwt.fromString(initialToken);
                        }
                        else if (initialToken instanceof Jwt) {
                            jwt = initialToken;
                        }
                        else {
                            throw new Error("Expected \"initialToken\" to be a string or an instance of Jwt, got " + typeof initialToken);
                        }
                        this.cachedJwt = jwt;
                    }
                    this.getJwt = function (context) {
                        if (_this.cachedJwt && !_this.cachedJwt.isExpired(addSeconds(new Date, TOKEN_EXPIRATION_MARGIN))) {
                            return Promise.resolve(_this.cachedJwt);
                        }
                        if (_this.jwtPromise) {
                            return _this.jwtPromise;
                        }
                        _this.jwtPromise = Promise.resolve(renewJwtFn(context))
                            .then(function (token) {
                            var jwt = typeof token === 'string' ? Jwt.fromString(token) : token;
                            _this.cachedJwt = jwt;
                            _this.jwtPromise = undefined;
                            return jwt;
                        }).catch(function (err) {
                            _this.jwtPromise = undefined;
                            throw err;
                        });
                        return _this.jwtPromise;
                    };
                }
                /**
                 * Returns a `Promise` resolved with the cached token if it's fresh, or the
                 * token obtained by the call to the `renewJwtCallback` otherwise. The token
                 * obtained from the `renewJwtCallback` is then cached. If the `renewJwtCallback`
                 * returns the JWT as a string, it is converted to {@link Jwt} instance before returning.
                 * @param {ITokenContext} context
                 * @returns {Promise<IAccessToken>}
                 */
                CachingJwtProvider.prototype.getToken = function (context) {
                    return this.getJwt(context);
                };
                return CachingJwtProvider;
            }());

            /**
             * Implementation of {@link IAccessToken} that calls the user-provided
             * callback function to get the JWT when requested by the clients.
             */
            var CallbackJwtProvider = /** @class */ (function () {
                /**
                 * Creates a new instance of `CallbackJwtProvider`.
                 *
                 * @param {GetJwtCallback} getJwtFn - The function that will be called
                 * whenever the JWT is needed. If the `getJwtFn` returns the JWT as a
                 * string, it will be converted to {@link Jwt} instance automatically.
                 */
                function CallbackJwtProvider(getJwtFn) {
                    if (typeof getJwtFn !== 'function') {
                        throw new TypeError('`getJwtFn` must be a function');
                    }
                    this.getJwt = function (context) {
                        return Promise.resolve(getJwtFn(context))
                            .then(function (token) { return typeof token === 'string' ? Jwt.fromString(token) : token; });
                    };
                }
                /**
                 * Returns a `Promise` resolved with the {@link Jwt} instance obtained
                 * by the call to the {@link CallbackJwtProvider.getJwt}. If the
                 * `getJwtFn` returns the JWT as a string, it is converted to
                 * {@link Jwt} instance before returning.
                 *
                 * @param {ITokenContext} context
                 * @returns {Promise<IAccessToken>}
                 */
                CallbackJwtProvider.prototype.getToken = function (context) {
                    return this.getJwt(context);
                };
                return CallbackJwtProvider;
            }());

            /**
             * Implementation of {@link IAccessTokenProvider} that returns a
             * user-provided constant access token whenever it is requested by the clients.
             */
            var ConstAccessTokenProvider = /** @class */ (function () {
                /**
                 * Creates a new instance of `ConstAccessTokenProvider`
                 * @param {IAccessToken} accessToken - The access token to be returned
                 * whenever it is requested.
                 */
                function ConstAccessTokenProvider(accessToken) {
                    this.accessToken = accessToken;
                    if (accessToken == null) {
                        throw new TypeError('`accessToken` is required');
                    }
                }
                /**
                 * Returns a `Promise` fulfilled with the
                 * {@link ConstAccessTokenProvider.accessToken} provided to the constructor
                 * of this instance.
                 *
                 * @param {ITokenContext} context
                 * @returns {Promise<IAccessToken>}
                 */
                ConstAccessTokenProvider.prototype.getToken = function (context) {
                    return Promise.resolve(this.accessToken);
                };
                return ConstAccessTokenProvider;
            }());

            /**
             * Implementation of {@link IAccessTokenProvider} that generates a
             * new JWT whenever it is requested by the clients.
             *
             * This class is meant to be used on the server side only.
             */
            var GeneratorJwtProvider = /** @class */ (function () {
                /**
                 * Creates a new instance of `GeneratorJwtProvider` with the given
                 * {@link JwtGenerator}, additional data and default identity.
                 *
                 * @param {JwtGenerator} jwtGenerator - Object to delegate the JWT generation to.
                 * @param {IExtraData} additionalData - Additional data to include with the JWT.
                 * @param {string} defaultIdentity - Identity of the user to include in the token
                 * when none is provided explicitly by the client.
                 */
                function GeneratorJwtProvider(jwtGenerator, additionalData, defaultIdentity) {
                    this.jwtGenerator = jwtGenerator;
                    this.additionalData = additionalData;
                    this.defaultIdentity = defaultIdentity;
                    if (jwtGenerator == null) {
                        throw new TypeError('`jwtGenerator` is required');
                    }
                }
                /**
                 * Returns a `Promise` fulfilled with the JWT obtained from the call
                 * to {@link GeneratorJwtProvider.jwtGenerator} {@link JwtGenerator.generateToken}
                 * method, passing it the {@link GeneratorJwtProvider.additionalData} and
                 * {@link GeneratorJwtProvider.defaultIdentity}
                 *
                 * @param {ITokenContext} context
                 * @returns {Promise<IAccessToken>}
                 */
                GeneratorJwtProvider.prototype.getToken = function (context) {
                    var _this = this;
                    return Promise.resolve().then(function () {
                        var jwt = _this.jwtGenerator.generateToken(context.identity || _this.defaultIdentity || '', _this.additionalData);
                        return jwt;
                    });
                };
                return GeneratorJwtProvider;
            }());

            /*! *****************************************************************************
            Copyright (c) Microsoft Corporation. All rights reserved.
            Licensed under the Apache License, Version 2.0 (the "License"); you may not use
            this file except in compliance with the License. You may obtain a copy of the
            License at http://www.apache.org/licenses/LICENSE-2.0

            THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
            WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
            MERCHANTABLITY OR NON-INFRINGEMENT.

            See the Apache Version 2.0 License for specific language governing permissions
            and limitations under the License.
            ***************************************************************************** */
            /* global Reflect, Promise */

            var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf ||
                    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                return extendStatics(d, b);
            };

            function __extends(d, b) {
                extendStatics(d, b);
                function __() { this.constructor = d; }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            }

            var __assign = function() {
                __assign = Object.assign || function __assign(t) {
                    for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                    }
                    return t;
                };
                return __assign.apply(this, arguments);
            };

            function __rest(s, e) {
                var t = {};
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                    t[p] = s[p];
                if (s != null && typeof Object.getOwnPropertySymbols === "function")
                    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                        t[p[i]] = s[p[i]];
                return t;
            }

            function __awaiter(thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
                    function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
                    function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            }

            function __generator(thisArg, body) {
                var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
                return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
                function verb(n) { return function (v) { return step([n, v]); }; }
                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [op[0] & 2, t.value];
                        switch (op[0]) {
                            case 0: case 1: t = op; break;
                            case 4: _.label++; return { value: op[1], done: false };
                            case 5: _.label++; y = op[1]; op = [0]; continue;
                            case 7: op = _.ops.pop(); _.trys.pop(); continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                                if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                                if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                                if (t[2]) _.ops.pop();
                                _.trys.pop(); continue;
                        }
                        op = body.call(thisArg, _);
                    } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
                    if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
                }
            }

            /**
             * Intermediate representation of the Virgil Card with `contentSnapshot`
             * and `snapshot`s of the signatures in UTF-8.
             */
            var RawSignedModel = /** @class */ (function () {
                /**
                 * Initializes a new instance of `RawSignedModel`.
                 * @param {string} contentSnapshot - The content snapshot in UTF-8.
                 * @param {IRawSignature[]} signatures - The signatures. If signatures
                 * themselves have snapshots, those must also be in UTF-8.
                 */
                function RawSignedModel(contentSnapshot, signatures) {
                    this.contentSnapshot = contentSnapshot;
                    this.signatures = signatures;
                }
                /**
                 * Converts the `str` in base64 encoding into a `RawSignedModel` object.
                 *
                 * @param {string} str - Base64 string representation of the card as
                 * returned by {@RawSignedModel.toString} method.
                 *
                 * @returns {RawSignedModel}
                 */
                RawSignedModel.fromString = function (str) {
                    var jsonStr = base64Decode(str, 'utf8');
                    var obj;
                    try {
                        obj = JSON.parse(jsonStr);
                    }
                    catch (error) {
                        throw new Error('The string to be parsed is in invalid format');
                    }
                    return RawSignedModel.fromJson(obj);
                };
                /**
                 * Converts the `json` serializable object into a `RawSignedModel` object.
                 * @param {IRawSignedModelJson} json - JSON-serializable object returned by
                 * {@link RawSignedModel.toJson} method.
                 * @returns {RawSignedModel}
                 */
                RawSignedModel.fromJson = function (json) {
                    var contentSnapshotUtf8 = base64Decode(json.content_snapshot, 'utf8');
                    var signaturesWithUtf8Snapshots = (json.signatures || []).map(function (_a) {
                        var signer = _a.signer, signature = _a.signature, snapshot = _a.snapshot;
                        if (snapshot) {
                            return {
                                signer: signer,
                                signature: signature,
                                snapshot: base64Decode(snapshot, 'utf8')
                            };
                        }
                        return { signer: signer, signature: signature };
                    });
                    return new RawSignedModel(contentSnapshotUtf8, signaturesWithUtf8Snapshots);
                };
                /**
                 * This is to make it work with `JSON.stringify`, calls
                 * {@link RawSignedModel.toJson} under the hood.
                 * @returns {IRawSignedModelJson}
                 */
                RawSignedModel.prototype.toJSON = function () {
                    return this.toJson();
                };
                /**
                 * Returns a JSON-serializable representation of this model in the
                 * format it is stored in the Virgil Cards Service. (i.e. with
                 * `contentSnapshot` and `snapshot`s of the signatures as base64 encoded
                 * strings.
                 * @returns {IRawSignedModelJson}
                 */
                RawSignedModel.prototype.toJson = function () {
                    return {
                        content_snapshot: base64Encode(this.contentSnapshot, 'utf8'),
                        signatures: this.signatures.map(function (_a) {
                            var signer = _a.signer, signature = _a.signature, snapshot = _a.snapshot;
                            if (snapshot) {
                                return {
                                    signer: signer,
                                    signature: signature,
                                    snapshot: base64Encode(snapshot, 'utf8')
                                };
                            }
                            return { signer: signer, signature: signature };
                        })
                    };
                };
                /**
                 * Serializes this model to string in base64 encoding.
                 * @returns {string}
                 */
                RawSignedModel.prototype.toString = function () {
                    return base64Encode(JSON.stringify(this), 'utf8');
                };
                /**
                 * Same as {@link RawSignedModel.toJson}. Please use that instead.
                 * @returns {IRawSignedModelJson}
                 */
                RawSignedModel.prototype.exportAsJson = function () {
                    return this.toJson();
                };
                /**
                 * Same as {@link RawSignedModel.toString}. Please use that instead.
                 * @returns {string}
                 */
                RawSignedModel.prototype.exportAsString = function () {
                    return this.toString();
                };
                return RawSignedModel;
            }());

            var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

            function createCommonjsModule(fn, module) {
            	return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            var fetchBrowser = createCommonjsModule(function (module, exports) {
            (function (self) {

              function fetchPonyfill(options) {
                var Promise = options && options.Promise || self.Promise;
                var XMLHttpRequest = options && options.XMLHttpRequest || self.XMLHttpRequest;
                var global = self;

                return (function () {
                  var self = Object.create(global, {
                    fetch: {
                      value: undefined,
                      writable: true
                    }
                  });

                  (function(self) {

                    if (self.fetch) {
                      return
                    }

                    var support = {
                      searchParams: 'URLSearchParams' in self,
                      iterable: 'Symbol' in self && 'iterator' in Symbol,
                      blob: 'FileReader' in self && 'Blob' in self && (function() {
                        try {
                          new Blob();
                          return true
                        } catch(e) {
                          return false
                        }
                      })(),
                      formData: 'FormData' in self,
                      arrayBuffer: 'ArrayBuffer' in self
                    };

                    if (support.arrayBuffer) {
                      var viewClasses = [
                        '[object Int8Array]',
                        '[object Uint8Array]',
                        '[object Uint8ClampedArray]',
                        '[object Int16Array]',
                        '[object Uint16Array]',
                        '[object Int32Array]',
                        '[object Uint32Array]',
                        '[object Float32Array]',
                        '[object Float64Array]'
                      ];

                      var isDataView = function(obj) {
                        return obj && DataView.prototype.isPrototypeOf(obj)
                      };

                      var isArrayBufferView = ArrayBuffer.isView || function(obj) {
                        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
                      };
                    }

                    function normalizeName(name) {
                      if (typeof name !== 'string') {
                        name = String(name);
                      }
                      if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
                        throw new TypeError('Invalid character in header field name')
                      }
                      return name.toLowerCase()
                    }

                    function normalizeValue(value) {
                      if (typeof value !== 'string') {
                        value = String(value);
                      }
                      return value
                    }

                    // Build a destructive iterator for the value list
                    function iteratorFor(items) {
                      var iterator = {
                        next: function() {
                          var value = items.shift();
                          return {done: value === undefined, value: value}
                        }
                      };

                      if (support.iterable) {
                        iterator[Symbol.iterator] = function() {
                          return iterator
                        };
                      }

                      return iterator
                    }

                    function Headers(headers) {
                      this.map = {};

                      if (headers instanceof Headers) {
                        headers.forEach(function(value, name) {
                          this.append(name, value);
                        }, this);
                      } else if (Array.isArray(headers)) {
                        headers.forEach(function(header) {
                          this.append(header[0], header[1]);
                        }, this);
                      } else if (headers) {
                        Object.getOwnPropertyNames(headers).forEach(function(name) {
                          this.append(name, headers[name]);
                        }, this);
                      }
                    }

                    Headers.prototype.append = function(name, value) {
                      name = normalizeName(name);
                      value = normalizeValue(value);
                      var oldValue = this.map[name];
                      this.map[name] = oldValue ? oldValue+','+value : value;
                    };

                    Headers.prototype['delete'] = function(name) {
                      delete this.map[normalizeName(name)];
                    };

                    Headers.prototype.get = function(name) {
                      name = normalizeName(name);
                      return this.has(name) ? this.map[name] : null
                    };

                    Headers.prototype.has = function(name) {
                      return this.map.hasOwnProperty(normalizeName(name))
                    };

                    Headers.prototype.set = function(name, value) {
                      this.map[normalizeName(name)] = normalizeValue(value);
                    };

                    Headers.prototype.forEach = function(callback, thisArg) {
                      for (var name in this.map) {
                        if (this.map.hasOwnProperty(name)) {
                          callback.call(thisArg, this.map[name], name, this);
                        }
                      }
                    };

                    Headers.prototype.keys = function() {
                      var items = [];
                      this.forEach(function(value, name) { items.push(name); });
                      return iteratorFor(items)
                    };

                    Headers.prototype.values = function() {
                      var items = [];
                      this.forEach(function(value) { items.push(value); });
                      return iteratorFor(items)
                    };

                    Headers.prototype.entries = function() {
                      var items = [];
                      this.forEach(function(value, name) { items.push([name, value]); });
                      return iteratorFor(items)
                    };

                    if (support.iterable) {
                      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
                    }

                    function consumed(body) {
                      if (body.bodyUsed) {
                        return Promise.reject(new TypeError('Already read'))
                      }
                      body.bodyUsed = true;
                    }

                    function fileReaderReady(reader) {
                      return new Promise(function(resolve, reject) {
                        reader.onload = function() {
                          resolve(reader.result);
                        };
                        reader.onerror = function() {
                          reject(reader.error);
                        };
                      })
                    }

                    function readBlobAsArrayBuffer(blob) {
                      var reader = new FileReader();
                      var promise = fileReaderReady(reader);
                      reader.readAsArrayBuffer(blob);
                      return promise
                    }

                    function readBlobAsText(blob) {
                      var reader = new FileReader();
                      var promise = fileReaderReady(reader);
                      reader.readAsText(blob);
                      return promise
                    }

                    function readArrayBufferAsText(buf) {
                      var view = new Uint8Array(buf);
                      var chars = new Array(view.length);

                      for (var i = 0; i < view.length; i++) {
                        chars[i] = String.fromCharCode(view[i]);
                      }
                      return chars.join('')
                    }

                    function bufferClone(buf) {
                      if (buf.slice) {
                        return buf.slice(0)
                      } else {
                        var view = new Uint8Array(buf.byteLength);
                        view.set(new Uint8Array(buf));
                        return view.buffer
                      }
                    }

                    function Body() {
                      this.bodyUsed = false;

                      this._initBody = function(body) {
                        this._bodyInit = body;
                        if (!body) {
                          this._bodyText = '';
                        } else if (typeof body === 'string') {
                          this._bodyText = body;
                        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                          this._bodyBlob = body;
                        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                          this._bodyFormData = body;
                        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                          this._bodyText = body.toString();
                        } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                          this._bodyArrayBuffer = bufferClone(body.buffer);
                          // IE 10-11 can't handle a DataView body.
                          this._bodyInit = new Blob([this._bodyArrayBuffer]);
                        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                          this._bodyArrayBuffer = bufferClone(body);
                        } else {
                          throw new Error('unsupported BodyInit type')
                        }

                        if (!this.headers.get('content-type')) {
                          if (typeof body === 'string') {
                            this.headers.set('content-type', 'text/plain;charset=UTF-8');
                          } else if (this._bodyBlob && this._bodyBlob.type) {
                            this.headers.set('content-type', this._bodyBlob.type);
                          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                            this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                          }
                        }
                      };

                      if (support.blob) {
                        this.blob = function() {
                          var rejected = consumed(this);
                          if (rejected) {
                            return rejected
                          }

                          if (this._bodyBlob) {
                            return Promise.resolve(this._bodyBlob)
                          } else if (this._bodyArrayBuffer) {
                            return Promise.resolve(new Blob([this._bodyArrayBuffer]))
                          } else if (this._bodyFormData) {
                            throw new Error('could not read FormData body as blob')
                          } else {
                            return Promise.resolve(new Blob([this._bodyText]))
                          }
                        };

                        this.arrayBuffer = function() {
                          if (this._bodyArrayBuffer) {
                            return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
                          } else {
                            return this.blob().then(readBlobAsArrayBuffer)
                          }
                        };
                      }

                      this.text = function() {
                        var rejected = consumed(this);
                        if (rejected) {
                          return rejected
                        }

                        if (this._bodyBlob) {
                          return readBlobAsText(this._bodyBlob)
                        } else if (this._bodyArrayBuffer) {
                          return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
                        } else if (this._bodyFormData) {
                          throw new Error('could not read FormData body as text')
                        } else {
                          return Promise.resolve(this._bodyText)
                        }
                      };

                      if (support.formData) {
                        this.formData = function() {
                          return this.text().then(decode)
                        };
                      }

                      this.json = function() {
                        return this.text().then(JSON.parse)
                      };

                      return this
                    }

                    // HTTP methods whose capitalization should be normalized
                    var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

                    function normalizeMethod(method) {
                      var upcased = method.toUpperCase();
                      return (methods.indexOf(upcased) > -1) ? upcased : method
                    }

                    function Request(input, options) {
                      options = options || {};
                      var body = options.body;

                      if (input instanceof Request) {
                        if (input.bodyUsed) {
                          throw new TypeError('Already read')
                        }
                        this.url = input.url;
                        this.credentials = input.credentials;
                        if (!options.headers) {
                          this.headers = new Headers(input.headers);
                        }
                        this.method = input.method;
                        this.mode = input.mode;
                        if (!body && input._bodyInit != null) {
                          body = input._bodyInit;
                          input.bodyUsed = true;
                        }
                      } else {
                        this.url = String(input);
                      }

                      this.credentials = options.credentials || this.credentials || 'omit';
                      if (options.headers || !this.headers) {
                        this.headers = new Headers(options.headers);
                      }
                      this.method = normalizeMethod(options.method || this.method || 'GET');
                      this.mode = options.mode || this.mode || null;
                      this.referrer = null;

                      if ((this.method === 'GET' || this.method === 'HEAD') && body) {
                        throw new TypeError('Body not allowed for GET or HEAD requests')
                      }
                      this._initBody(body);
                    }

                    Request.prototype.clone = function() {
                      return new Request(this, { body: this._bodyInit })
                    };

                    function decode(body) {
                      var form = new FormData();
                      body.trim().split('&').forEach(function(bytes) {
                        if (bytes) {
                          var split = bytes.split('=');
                          var name = split.shift().replace(/\+/g, ' ');
                          var value = split.join('=').replace(/\+/g, ' ');
                          form.append(decodeURIComponent(name), decodeURIComponent(value));
                        }
                      });
                      return form
                    }

                    function parseHeaders(rawHeaders) {
                      var headers = new Headers();
                      rawHeaders.split(/\r?\n/).forEach(function(line) {
                        var parts = line.split(':');
                        var key = parts.shift().trim();
                        if (key) {
                          var value = parts.join(':').trim();
                          headers.append(key, value);
                        }
                      });
                      return headers
                    }

                    Body.call(Request.prototype);

                    function Response(bodyInit, options) {
                      if (!options) {
                        options = {};
                      }

                      this.type = 'default';
                      this.status = 'status' in options ? options.status : 200;
                      this.ok = this.status >= 200 && this.status < 300;
                      this.statusText = 'statusText' in options ? options.statusText : 'OK';
                      this.headers = new Headers(options.headers);
                      this.url = options.url || '';
                      this._initBody(bodyInit);
                    }

                    Body.call(Response.prototype);

                    Response.prototype.clone = function() {
                      return new Response(this._bodyInit, {
                        status: this.status,
                        statusText: this.statusText,
                        headers: new Headers(this.headers),
                        url: this.url
                      })
                    };

                    Response.error = function() {
                      var response = new Response(null, {status: 0, statusText: ''});
                      response.type = 'error';
                      return response
                    };

                    var redirectStatuses = [301, 302, 303, 307, 308];

                    Response.redirect = function(url, status) {
                      if (redirectStatuses.indexOf(status) === -1) {
                        throw new RangeError('Invalid status code')
                      }

                      return new Response(null, {status: status, headers: {location: url}})
                    };

                    self.Headers = Headers;
                    self.Request = Request;
                    self.Response = Response;

                    self.fetch = function(input, init) {
                      return new Promise(function(resolve, reject) {
                        var request = new Request(input, init);
                        var xhr = new XMLHttpRequest();

                        xhr.onload = function() {
                          var options = {
                            status: xhr.status,
                            statusText: xhr.statusText,
                            headers: parseHeaders(xhr.getAllResponseHeaders() || '')
                          };
                          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
                          var body = 'response' in xhr ? xhr.response : xhr.responseText;
                          resolve(new Response(body, options));
                        };

                        xhr.onerror = function() {
                          reject(new TypeError('Network request failed'));
                        };

                        xhr.ontimeout = function() {
                          reject(new TypeError('Network request failed'));
                        };

                        xhr.open(request.method, request.url, true);

                        if (request.credentials === 'include') {
                          xhr.withCredentials = true;
                        }

                        if ('responseType' in xhr && support.blob) {
                          xhr.responseType = 'blob';
                        }

                        request.headers.forEach(function(value, name) {
                          xhr.setRequestHeader(name, value);
                        });

                        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
                      })
                    };
                    self.fetch.polyfill = true;
                  })(typeof self !== 'undefined' ? self : this);


                  return {
                    fetch: self.fetch,
                    Headers: self.Headers,
                    Request: self.Request,
                    Response: self.Response
                  };
                }());
              }

              {
                module.exports = fetchPonyfill;
              }
            }(typeof self !== 'undefined' ? self : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : commonjsGlobal));
            });

            var _a = fetchBrowser(), fetch = _a.fetch, Request = _a.Request, Response = _a.Response, Headers = _a.Headers;

            /**
             * Class responsible for making HTTP requests.
             * @hidden
             */
            var Connection = /** @class */ (function () {
                /**
                 * Initializes a new instance of `Connection`.
                 * @param {string} prefix - `prefix` will be prepended to the `endpoint`
                 * argument of request methods.
                 */
                function Connection(prefix) {
                    this.prefix = prefix;
                }
                /**
                 * Issues a GET request against the `endpoint`.
                 * @param {string} endpoint - Endpoint URL relative to the `prefix`.
                 * @param {string} accessToken - Token to authenticate the request.
                 * @returns {Promise<Response>}
                 */
                Connection.prototype.get = function (endpoint, accessToken) {
                    var headers = this.createHeaders(accessToken);
                    return this.send(endpoint, 'GET', { headers: headers });
                };
                /**
                 * Issues a POST request against the `endpoint` sending the `data` as JSON.
                 * @param {string} endpoint - Endpoint URL relative to the `prefix`.
                 * @param {string} accessToken - Token to authenticate the request.
                 * @param {object} data - Response body.
                 * @returns {Promise<Response>}
                 */
                Connection.prototype.post = function (endpoint, accessToken, data) {
                    if (data === void 0) { data = {}; }
                    var headers = this.createHeaders(accessToken);
                    headers.set('Content-Type', 'application/json');
                    return this.send(endpoint, 'POST', {
                        headers: headers,
                        body: JSON.stringify(data)
                    });
                };
                Connection.prototype.send = function (endpoint, method, params) {
                    return fetch(this.prefix + endpoint, __assign({ method: method }, params));
                };
                Connection.prototype.createHeaders = function (accessToken) {
                    var headers = new Headers();
                    headers.set('Authorization', "Virgil " + accessToken);
                    return headers;
                };
                return Connection;
            }());

            /**
             * Custom error class for errors specific to Virgil SDK.
             */
            var VirgilError = /** @class */ (function (_super) {
                __extends(VirgilError, _super);
                function VirgilError(m, name) {
                    var _newTarget = this.constructor;
                    if (name === void 0) { name = 'VirgilError'; }
                    var _this = _super.call(this, m) || this;
                    Object.setPrototypeOf(_this, _newTarget.prototype);
                    _this.name = name;
                    return _this;
                }
                return VirgilError;
            }(Error));

            var ErrorCode;
            (function (ErrorCode) {
                ErrorCode[ErrorCode["AccessTokenExpired"] = 20304] = "AccessTokenExpired";
                ErrorCode[ErrorCode["Unknown"] = 0] = "Unknown";
            })(ErrorCode || (ErrorCode = {}));
            /**
             * Error thrown by {@link CardManager} when request to the Virgil Cards Service
             * fails.
             */
            var VirgilHttpError = /** @class */ (function (_super) {
                __extends(VirgilHttpError, _super);
                function VirgilHttpError(message, status, errorCode) {
                    var _this = _super.call(this, message, 'VirgilHttpError') || this;
                    _this.httpStatus = status;
                    _this.errorCode = errorCode;
                    return _this;
                }
                return VirgilHttpError;
            }(VirgilError));
            /**
             * Generates error object from response object with HTTP status >= 400
             *
             * @hidden
             *
             * @param {Response} response
             * @returns {Promise<VirgilHttpError>}
             */
            function generateErrorFromResponse(response) {
                return __awaiter(this, void 0, void 0, function () {
                    var reason;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!(response.status >= 400 && response.status < 500)) return [3 /*break*/, 2];
                                return [4 /*yield*/, response.json()];
                            case 1:
                                reason = _a.sent();
                                return [2 /*return*/, new VirgilHttpError(reason.message, response.status, reason.code)];
                            case 2: return [2 /*return*/, new VirgilHttpError(response.statusText, response.status, 0)];
                        }
                    });
                });
            }

            var PublishEndpoint = '/card/v5';
            var SearchEndpoint = '/card/v5/actions/search';
            var GetCardEndpoint = function (cardId) { return "/card/v5/" + cardId; };
            /**
             * Class responsible for sending requests to the Virgil Cards Service.
             *
             * @hidden
             */
            var CardClient = /** @class */ (function () {
                /**
                 * Initializes new instance of `CardClient`.
                 * @param {IConnection | string} connection - Object implementing the
                 * {@link IConnection} interface.
                 */
                function CardClient(connection) {
                    if (typeof connection === 'string') {
                        this.connection = new Connection(connection);
                    }
                    else if (connection) {
                        this.connection = connection;
                    }
                    else {
                        this.connection = new Connection('https://api.virgilsecurity.com');
                    }
                }
                /**
                 * Issues a request to search cards by the `identity`.
                 * @param {string[]} identities - Array of identities to search for.
                 * @param {string} jwtToken - A token to authenticate the request.
                 * @returns {Promise<RawSignedModel[]>}
                 */
                CardClient.prototype.searchCards = function (identities, jwtToken) {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, cardsJson;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.connection.post(SearchEndpoint, jwtToken, { identities: identities })];
                                case 1:
                                    response = _a.sent();
                                    if (!!response.ok) return [3 /*break*/, 3];
                                    return [4 /*yield*/, generateErrorFromResponse(response)];
                                case 2: throw _a.sent();
                                case 3: return [4 /*yield*/, response.json()];
                                case 4:
                                    cardsJson = _a.sent();
                                    if (cardsJson === null)
                                        return [2 /*return*/, []];
                                    return [2 /*return*/, cardsJson.map(RawSignedModel.fromJson)];
                            }
                        });
                    });
                };
                /**
                 * Issues a request to get the card by id.
                 * @param {string} cardId - Id of the card to fetch.
                 * @param {string} jwtToken - A token to authenticate the request.
                 * @returns {Promise<ICardResult>}
                 */
                CardClient.prototype.getCard = function (cardId, jwtToken) {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, isOutdated, cardJson, cardRaw;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!cardId)
                                        throw new TypeError('`cardId` should not be empty');
                                    if (!jwtToken)
                                        throw new TypeError('`jwtToken` should not be empty');
                                    return [4 /*yield*/, this.connection.get(GetCardEndpoint(cardId), jwtToken)];
                                case 1:
                                    response = _a.sent();
                                    if (!!response.ok) return [3 /*break*/, 3];
                                    return [4 /*yield*/, generateErrorFromResponse(response)];
                                case 2: throw _a.sent();
                                case 3:
                                    isOutdated = response.headers.get('X-Virgil-Is-Superseeded') === 'true';
                                    return [4 /*yield*/, response.json()];
                                case 4:
                                    cardJson = _a.sent();
                                    cardRaw = RawSignedModel.fromJson(cardJson);
                                    return [2 /*return*/, { cardRaw: cardRaw, isOutdated: isOutdated }];
                            }
                        });
                    });
                };
                /**
                 * Issues a request to publish the card.
                 * @param {RawSignedModel} model - Card to publish.
                 * @param {string} jwtToken - A token to authenticate the request.
                 * @returns {Promise<RawSignedModel>}
                 */
                CardClient.prototype.publishCard = function (model, jwtToken) {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, cardJson;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!model)
                                        throw new TypeError('`model` should not be empty');
                                    if (!jwtToken)
                                        throw new TypeError('`jwtToken` should not be empty');
                                    return [4 /*yield*/, this.connection.post(PublishEndpoint, jwtToken, model)];
                                case 1:
                                    response = _a.sent();
                                    if (!!response.ok) return [3 /*break*/, 3];
                                    return [4 /*yield*/, generateErrorFromResponse(response)];
                                case 2: throw _a.sent();
                                case 3: return [4 /*yield*/, response.json()];
                                case 4:
                                    cardJson = _a.sent();
                                    return [2 /*return*/, RawSignedModel.fromJson(cardJson)];
                            }
                        });
                    });
                };
                return CardClient;
            }());

            /**
             * @hidden
             */
            var SelfSigner = "self";
            /**
             * @hidden
             */
            var VirgilSigner = "virgil";
            /**
             * @hidden
             */
            var CardVersion = '5.0';
            /**
             * @hidden
             */
            var CardIdByteLength = 32;

            /**
             * Class responsible for generating signatures of the cards.
             */
            var ModelSigner = /** @class */ (function () {
                /**
                 * Initializes a new instance of `ModelSigner`.
                 * @param {ICardCrypto} crypto - Object implementing the
                 * {@link ICardCrypto} interface.
                 */
                function ModelSigner(crypto) {
                    this.crypto = crypto;
                }
                /**
                 * Generates a new signature based on `rawParams`.
                 * @param {IRawSignParams} rawParams
                 */
                ModelSigner.prototype.sign = function (rawParams) {
                    var _a = this.prepareParams(rawParams), model = _a.model, signerPrivateKey = _a.signerPrivateKey, signer = _a.signer, extraSnapshot = _a.extraSnapshot;
                    var signedSnapshot = extraSnapshot != null
                        ? model.contentSnapshot + extraSnapshot
                        : model.contentSnapshot;
                    var signature = this.crypto.generateSignature(signedSnapshot, signerPrivateKey);
                    model.signatures.push({
                        signer: signer,
                        signature: signature.toString('base64'),
                        snapshot: extraSnapshot
                    });
                };
                ModelSigner.prototype.prepareParams = function (_a) {
                    var model = _a.model, signerPrivateKey = _a.signerPrivateKey, extraFields = _a.extraFields, signer = _a.signer;
                    signer = signer || SelfSigner;
                    var extraSnapshot;
                    if (extraFields != null) {
                        extraSnapshot = JSON.stringify(extraFields);
                    }
                    var final = { model: model, signerPrivateKey: signerPrivateKey, signer: signer, extraSnapshot: extraSnapshot };
                    this.validate(final);
                    return final;
                };
                ModelSigner.prototype.validate = function (_a) {
                    var model = _a.model, signerPrivateKey = _a.signerPrivateKey, signer = _a.signer;
                    if (model == null) {
                        throw new Error("Model is empty");
                    }
                    if (signerPrivateKey == null) {
                        throw new Error("`signerPrivateKey` property is mandatory");
                    }
                    if (model.signatures != null && model.signatures.some(function (s) { return s.signer == signer; })) {
                        throw new Error("The model already has this signature.");
                    }
                };
                return ModelSigner;
            }());

            /**
             * Converts an {@link ICard} to a {@link RawSignedModel}.
             *
             * @hidden
             *
             * @param {ICard} card - The {@link ICard} to convert.
             * @returns {RawSignedModel}
             */
            function cardToRawSignedModel(card) {
                return new RawSignedModel(card.contentSnapshot, card.signatures.slice());
            }
            /**
             * Generates a {@link RawSignedModel} from the given `params`.
             *
             * @hidden
             *
             * @param {ICardCrypto} crypto - Object implementing the {@link ICardCrypto}
             * interface.
             * @param {INewCardParams} params - New card parameters.
             * @returns {RawSignedModel}
             */
            function generateRawSigned(crypto, params) {
                var identity = params.identity, publicKey = params.publicKey, previousCardId = params.previousCardId;
                var now = getUnixTimestamp(new Date);
                var details = {
                    identity: identity,
                    previous_card_id: previousCardId,
                    created_at: now,
                    version: CardVersion,
                    public_key: base64Encode(crypto.exportPublicKey(publicKey))
                };
                return new RawSignedModel(JSON.stringify(details), []);
            }
            /**
             * Converts the {@link RawSignedModel} into the {@link ICard}.
             *
             * @hidden
             *
             * @param {ICardCrypto} crypto - Object implementing the {@link ICardCrypto}
             * interface.
             * @param {RawSignedModel} model - The model to convert.
             * @param {boolean} isOutdated - Boolean indicating whether there is a newer
             * Virgil Card replacing the one that `model` represents.
             *
             * @returns {ICard}
             */
            function parseRawSignedModel(crypto, model, isOutdated) {
                if (isOutdated === void 0) { isOutdated = false; }
                var content = JSON.parse(model.contentSnapshot);
                var signatures = model.signatures.map(rawSignToCardSign);
                return {
                    id: generateCardId(crypto, model.contentSnapshot),
                    publicKey: crypto.importPublicKey(content.public_key),
                    contentSnapshot: model.contentSnapshot,
                    identity: content.identity,
                    version: content.version,
                    createdAt: new Date(content.created_at * 1000),
                    previousCardId: content.previous_card_id,
                    signatures: signatures,
                    isOutdated: isOutdated
                };
            }
            /**
             * Given the array of `cards`, returns another array with outdated cards
             * filtered out and the `previousCard` properties of the cards that replace
             * the outdated ones being populated with appropriate outdated cards.
             * i.e. turns this (A is for Actual, O is for Outdated):
             * ```
             * A -> O -> A -> A -> O
             * ```
             * into this
             * ```
             * A -> A -> A
             * |         |
             * O         O
             * ```
             *
             * @hidden
             *
             * @param {ICard[]} cards - The cards array to transform.
             * @returns {ICard[]} - Transformed array.
             */
            function linkedCardList(cards) {
                var unsorted = Object.create(null);
                for (var _i = 0, cards_1 = cards; _i < cards_1.length; _i++) {
                    var card = cards_1[_i];
                    unsorted[card.id] = card;
                }
                for (var _a = 0, cards_2 = cards; _a < cards_2.length; _a++) {
                    var card = cards_2[_a];
                    if (card.previousCardId == null)
                        continue;
                    if (unsorted[card.previousCardId] == null)
                        continue;
                    unsorted[card.previousCardId].isOutdated = true;
                    card.previousCard = unsorted[card.previousCardId];
                    delete unsorted[card.previousCardId];
                }
                return Object.keys(unsorted).map(function (key) { return unsorted[key]; });
            }
            /**
             * Calculates ID for the VirgilCard from the `snapshot` of its contents.
             *
             * @hidden
             *
             * @param {ICardCrypto} crypto - Object implementing the {@link ICardCrypto}
             * interface.
             * @param {string} snapshot - The VirgilCard's contents snapshot.
             * @returns {string} - VirgilCard's ID encoded in HEX.
             */
            function generateCardId(crypto, snapshot) {
                var fingerprint = crypto.generateSha512(snapshot).slice(0, CardIdByteLength);
                return fingerprint.toString('hex');
            }
            function rawSignToCardSign(_a) {
                var snapshot = _a.snapshot, signature = _a.signature, signer = _a.signer;
                return {
                    signer: signer,
                    signature: signature,
                    snapshot: snapshot,
                    extraFields: tryParseExtraFields(snapshot)
                };
            }
            function tryParseExtraFields(snapshot) {
                if (snapshot) {
                    try {
                        return JSON.parse(snapshot);
                    }
                    catch (ignored) { }
                }
                return {};
            }

            /**
             * Error thrown by {@link CardManager} instances when the card received from
             * the network (or imported from string\json) fails verification.
             */
            var VirgilCardVerificationError = /** @class */ (function (_super) {
                __extends(VirgilCardVerificationError, _super);
                function VirgilCardVerificationError(m) {
                    return _super.call(this, m, 'CardVerificationError') || this;
                }
                return VirgilCardVerificationError;
            }(VirgilError));

            /**
             * @hidden
             */
            var throwingAccessTokenProvider = {
                getToken: function () {
                    throw new Error('Please set `CardManager.accessTokenProvider` to be able to make requests.');
                }
            };
            /**
             * Class responsible for creating, publishing and retrieving Virgil Cards.
             */
            var CardManager = /** @class */ (function () {
                function CardManager(params) {
                    this.crypto = params.cardCrypto;
                    this.client = new CardClient(params.apiUrl);
                    this.modelSigner = new ModelSigner(params.cardCrypto);
                    this.signCallback = params.signCallback;
                    this.retryOnUnauthorized = params.retryOnUnauthorized;
                    this.cardVerifier = params.cardVerifier;
                    this.accessTokenProvider = params.accessTokenProvider || throwingAccessTokenProvider;
                }
                /**
                 * Generates a {@link RawSignedModel} that represents a card from
                 * `cardParams`.
                 * Use this method if you don't need to publish the card right away, for
                 * example if you need to first send it to your backend server to apply
                 * additional signature.
                 *
                 * @param {INewCardParams} cardParams - New card parameters.
                 * @returns {RawSignedModel}
                 */
                CardManager.prototype.generateRawCard = function (cardParams) {
                    var model = generateRawSigned(this.crypto, cardParams);
                    this.modelSigner.sign({
                        model: model,
                        signerPrivateKey: cardParams.privateKey,
                        signer: SelfSigner,
                        extraFields: cardParams.extraFields
                    });
                    return model;
                };
                /**
                 * Generates a card from `cardParams` and publishes it in the Virgil Cards
                 * Service.
                 * @param {INewCardParams} cardParams - New card parameters.
                 * @returns {Promise<ICard>}
                 */
                CardManager.prototype.publishCard = function (cardParams) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tokenContext, token, rawSignedModel;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    validateCardParams(cardParams);
                                    tokenContext = { identity: cardParams.identity, operation: 'publish' };
                                    return [4 /*yield*/, this.accessTokenProvider.getToken(tokenContext)];
                                case 1:
                                    token = _a.sent();
                                    rawSignedModel = this.generateRawCard(Object.assign({}, cardParams, { identity: token.identity() }));
                                    return [4 /*yield*/, this.publishRawSignedModel(rawSignedModel, tokenContext, token)];
                                case 2: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Publishes a previously generated card in the form of
                 * {@link RawSignedModel} object.
                 *
                 * @param {RawSignedModel} rawCard - The card to publish.
                 * @returns {Promise<ICard>}
                 */
                CardManager.prototype.publishRawCard = function (rawCard) {
                    return __awaiter(this, void 0, void 0, function () {
                        var cardDetails, tokenContext, token;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    assert(rawCard != null && rawCard.contentSnapshot != null, '`rawCard` should not be empty');
                                    cardDetails = JSON.parse(rawCard.contentSnapshot);
                                    tokenContext = { identity: cardDetails.identity, operation: 'publish' };
                                    return [4 /*yield*/, this.accessTokenProvider.getToken(tokenContext)];
                                case 1:
                                    token = _a.sent();
                                    return [2 /*return*/, this.publishRawSignedModel(rawCard, tokenContext, token)];
                            }
                        });
                    });
                };
                /**
                 * Fetches the card by `cardId` from the Virgil Card Service.
                 * @param {string} cardId - Id of the card to fetch.
                 * @returns {Promise<ICard>}
                 */
                CardManager.prototype.getCard = function (cardId) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tokenContext, accessToken, cardWithStatus, card;
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tokenContext = { operation: 'get' };
                                    return [4 /*yield*/, this.accessTokenProvider.getToken(tokenContext)];
                                case 1:
                                    accessToken = _a.sent();
                                    return [4 /*yield*/, this.tryDo(tokenContext, accessToken, function (token) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0: return [4 /*yield*/, this.client.getCard(cardId, token.toString())];
                                                case 1: return [2 /*return*/, _a.sent()];
                                            }
                                        }); }); })];
                                case 2:
                                    cardWithStatus = _a.sent();
                                    card = parseRawSignedModel(this.crypto, cardWithStatus.cardRaw, cardWithStatus.isOutdated);
                                    if (card.id !== cardId) {
                                        throw new VirgilCardVerificationError('Received invalid card');
                                    }
                                    this.validateCards([card]);
                                    return [2 /*return*/, card];
                            }
                        });
                    });
                };
                /**
                 * Fetches collection of cards with the given `identity` from the Virgil
                 * Cards Service.
                 * @param {string|string[]} identities - Identity or an array of identities of the cards to fetch.
                 * @returns {Promise<ICard[]>}
                 */
                CardManager.prototype.searchCards = function (identities) {
                    return __awaiter(this, void 0, void 0, function () {
                        var identitiesArr, tokenContext, accessToken, rawCards, cards, identitiesSet;
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!identities)
                                        throw new TypeError('Argument `identities` is required');
                                    identitiesArr = Array.isArray(identities) ? identities : [identities];
                                    if (identitiesArr.length === 0)
                                        throw new TypeError('Identities array must not be empty');
                                    tokenContext = { operation: 'search' };
                                    return [4 /*yield*/, this.accessTokenProvider.getToken(tokenContext)];
                                case 1:
                                    accessToken = _a.sent();
                                    return [4 /*yield*/, this.tryDo(tokenContext, accessToken, function (token) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0: return [4 /*yield*/, this.client.searchCards(identitiesArr, token.toString())];
                                                case 1: return [2 /*return*/, _a.sent()];
                                            }
                                        }); }); })];
                                case 2:
                                    rawCards = _a.sent();
                                    cards = rawCards.map(function (raw) { return parseRawSignedModel(_this.crypto, raw, false); });
                                    identitiesSet = new Set(identitiesArr);
                                    if (cards.some(function (c) { return !identitiesSet.has(c.identity); })) {
                                        throw new VirgilCardVerificationError('Received invalid cards');
                                    }
                                    this.validateCards(cards);
                                    return [2 /*return*/, linkedCardList(cards)];
                            }
                        });
                    });
                };
                /**
                 * Converts the card in the form of {@link RawSignedModel} object to the
                 * {@link ICard} object.
                 *
                 * @see {@link CardManager.exportCard}
                 *
                 * @param {RawSignedModel} rawCard - The card to convert.
                 * @returns {ICard}
                 */
                CardManager.prototype.importCard = function (rawCard) {
                    var card = parseRawSignedModel(this.crypto, rawCard);
                    this.validateCards([card]);
                    return card;
                };
                /**
                 * Converts the card in the base64 string form to the {@link ICard} object.
                 *
                 * @see {@link CardManager.exportCardAsString}
                 *
                 * @param {string} str - The string in base64.
                 * @returns {ICard}
                 */
                CardManager.prototype.importCardFromString = function (str) {
                    assert(Boolean(str), '`str` should not be empty');
                    return this.importCard(RawSignedModel.fromString(str));
                };
                /**
                 * Converts the card in the JSON-serializable object form to the
                 * {@link ICard} object.
                 *
                 * @see {@link CardManager.exportCardAsJson}
                 *
                 * @param {IRawSignedModelJson} json
                 * @returns {ICard}
                 */
                CardManager.prototype.importCardFromJson = function (json) {
                    assert(Boolean(json), '`json` should not be empty');
                    return this.importCard(RawSignedModel.fromJson(json));
                };
                /**
                 * Converts the card in the form of {@link ICard} object to the
                 * {@link RawSignedModel} object.
                 *
                 * @see {@link CardManager.importCard}
                 *
                 * @param {ICard} card
                 * @returns {RawSignedModel}
                 */
                CardManager.prototype.exportCard = function (card) {
                    return cardToRawSignedModel(card);
                };
                /**
                 * Converts the card in the form of {@link ICard} object to the string
                 * in base64 encoding.
                 *
                 * @see {@link CardManager.importCardFromString}
                 *
                 * @param {ICard} card
                 * @returns {string}
                 */
                CardManager.prototype.exportCardAsString = function (card) {
                    return this.exportCard(card).toString();
                };
                /**
                 * Converts the card in the form of {@link ICard} object to the
                 * JSON-serializable object form.
                 *
                 * @see {@link CardManager.importCardFromJson}
                 *
                 * @param {ICard} card
                 * @returns {IRawSignedModelJson}
                 */
                CardManager.prototype.exportCardAsJson = function (card) {
                    return this.exportCard(card).toJson();
                };
                /**
                 * @hidden
                 */
                CardManager.prototype.publishRawSignedModel = function (rawCard, context, accessToken) {
                    return __awaiter(this, void 0, void 0, function () {
                        var publishedModel, card;
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(this.signCallback != null)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.signCallback(rawCard)];
                                case 1:
                                    rawCard = _a.sent();
                                    _a.label = 2;
                                case 2: return [4 /*yield*/, this.tryDo(context, accessToken, function (token) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, this.client.publishCard(rawCard, token.toString())];
                                            case 1: return [2 /*return*/, _a.sent()];
                                        }
                                    }); }); })];
                                case 3:
                                    publishedModel = _a.sent();
                                    if (rawCard.contentSnapshot !== publishedModel.contentSnapshot) {
                                        throw new VirgilCardVerificationError('Received invalid card');
                                    }
                                    card = parseRawSignedModel(this.crypto, publishedModel);
                                    this.validateCards([card]);
                                    return [2 /*return*/, card];
                            }
                        });
                    });
                };
                /**
                 * @hidden
                 */
                CardManager.prototype.tryDo = function (context, token, func) {
                    return __awaiter(this, void 0, void 0, function () {
                        var e_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 2, , 6]);
                                    return [4 /*yield*/, func(token)];
                                case 1: return [2 /*return*/, _a.sent()];
                                case 2:
                                    e_1 = _a.sent();
                                    if (!(e_1 instanceof VirgilHttpError &&
                                        e_1.httpStatus === 401 &&
                                        e_1.errorCode === ErrorCode.AccessTokenExpired &&
                                        this.retryOnUnauthorized)) return [3 /*break*/, 5];
                                    return [4 /*yield*/, this.accessTokenProvider.getToken({
                                            identity: context.identity,
                                            operation: context.operation,
                                            forceReload: true
                                        })];
                                case 3:
                                    token = _a.sent();
                                    return [4 /*yield*/, func(token)];
                                case 4: return [2 /*return*/, _a.sent()];
                                case 5: throw e_1;
                                case 6: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Delegates to the {@link CardManager.cardVerifier} to verify the validity
                 * of the `cards`.
                 *
                 * @throws {@link VirgilCardVerificationError} if any of the cards is not
                 * valid.
                 *
                 * @param {ICard[]} cards
                 */
                CardManager.prototype.validateCards = function (cards) {
                    if (this.cardVerifier == null)
                        return;
                    for (var _i = 0, cards_1 = cards; _i < cards_1.length; _i++) {
                        var card = cards_1[_i];
                        if (!this.cardVerifier.verifyCard(card)) {
                            throw new VirgilCardVerificationError('Validation errors have been detected');
                        }
                    }
                };
                return CardManager;
            }());
            /**
             * @hidden
             */
            function validateCardParams(params, validateIdentity) {
                if (validateIdentity === void 0) { validateIdentity = false; }
                assert(params != null, 'Card parameters must be provided');
                assert(params.privateKey != null, 'Card\'s private key is required');
                assert(params.publicKey != null, 'Card\'s public key is required');
                if (validateIdentity) {
                    assert(typeof params.identity === 'string' && params.identity !== '', 'Card\'s identity is required');
                }
            }

            var DEFAULTS = {
                verifySelfSignature: true,
                verifyVirgilSignature: true,
                whitelists: []
            };
            var VIRGIL_CARDS_PUBKEY_BASE64 = 'MCowBQYDK2VwAyEAljOYGANYiVq1WbvVvoYIKtvZi2ji9bAhxyu6iV/LF8M=';
            /**
             * Class responsible for validating cards by verifying their digital
             * signatures.
             */
            var VirgilCardVerifier = /** @class */ (function () {
                /**
                 * Initializes a new instance of `VirgilCardVerifier`.
                 * @param {ICardCrypto} crypto - Object implementing the
                 * {@link ICardCrypto} interface.
                 * @param {IVirgilCardVerifierParams} options - Initialization options.
                 */
                function VirgilCardVerifier(crypto, options) {
                    this.crypto = crypto;
                    var params = __assign({}, DEFAULTS, (options || {}));
                    this.verifySelfSignature = params.verifySelfSignature;
                    this.verifyVirgilSignature = params.verifyVirgilSignature;
                    this.whitelists = params.whitelists;
                    this.virgilCardsPublicKey = crypto.importPublicKey(VIRGIL_CARDS_PUBKEY_BASE64);
                }
                /**
                 * Verifies the signatures of the `card`.
                 * @param {ICard} card
                 * @returns {boolean} `true` if the signatures to be verified are present
                 * and valid, otherwise `false`.
                 */
                VirgilCardVerifier.prototype.verifyCard = function (card) {
                    var _this = this;
                    if (this.selfValidationFailed(card)) {
                        return false;
                    }
                    if (this.virgilValidationFailed(card)) {
                        return false;
                    }
                    if (!this.whitelists || this.whitelists.length === 0) {
                        return true;
                    }
                    var signers = card.signatures.map(function (s) { return s.signer; });
                    for (var _i = 0, _a = this.whitelists; _i < _a.length; _i++) {
                        var whitelist = _a[_i];
                        if (whitelist == null || whitelist.length === 0) {
                            return false;
                        }
                        var intersectedCreds = whitelist.filter(function (x) { return signers.indexOf(x.signer) !== -1; });
                        if (intersectedCreds.length === 0) {
                            return false;
                        }
                        var isValidForSome = intersectedCreds.some(function (cred) {
                            return _this.validateSignerSignature(card, _this.getPublicKey(cred.publicKeyBase64), cred.signer);
                        });
                        if (!isValidForSome) {
                            return false;
                        }
                    }
                    return true;
                };
                VirgilCardVerifier.prototype.selfValidationFailed = function (card) {
                    return this.verifySelfSignature
                        && !this.validateSignerSignature(card, card.publicKey, SelfSigner);
                };
                VirgilCardVerifier.prototype.virgilValidationFailed = function (card) {
                    return this.verifyVirgilSignature
                        && !this.validateSignerSignature(card, this.virgilCardsPublicKey, VirgilSigner);
                };
                VirgilCardVerifier.prototype.getPublicKey = function (signerPublicKeyBase64) {
                    return this.crypto.importPublicKey(signerPublicKeyBase64);
                };
                VirgilCardVerifier.prototype.validateSignerSignature = function (card, signerPublicKey, signer) {
                    var signature = card.signatures.find(function (s) { return s.signer === signer; });
                    if (signature == null)
                        return false;
                    var extendedSnapshot = signature.snapshot == null
                        ? card.contentSnapshot
                        : card.contentSnapshot + signature.snapshot;
                    return this.crypto.verifySignature(extendedSnapshot, signature.signature, signerPublicKey);
                };
                return VirgilCardVerifier;
            }());

            // Some code originally from localForage
            // See: https://github.com/localForage/localForage/blob/master/src/utils/isIndexedDBValid.js
            /**
             * @hidden
             * @returns {boolean}
             */
            function isIndexedDbValid() {
                // We mimic PouchDB here
                // Following #7085 (see https://github.com/pouchdb/pouchdb/issues/7085)
                // buggy idb versions (typically Safari < 10.1) are considered valid.
                // On Firefox SecurityError is thrown while referencing indexedDB if cookies
                // are not allowed. `typeof indexedDB` also triggers the error.
                try {
                    // some outdated implementations of IDB that appear on Samsung
                    // and HTC Android devices <4.4 are missing IDBKeyRange
                    return typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined';
                }
                catch (e) {
                    return false;
                }
            }

            /**
             * Error thrown by {@link IStorageAdapter.store} method when saving a value
             * with a key that already exists in store.
             */
            var StorageEntryAlreadyExistsError = /** @class */ (function (_super) {
                __extends(StorageEntryAlreadyExistsError, _super);
                function StorageEntryAlreadyExistsError(key) {
                    return _super.call(this, "Storage entry " + (key ? 'with key ' + name : 'with the given key') + "already exists", 'StorageEntryAlreadyExistsError') || this;
                }
                return StorageEntryAlreadyExistsError;
            }(VirgilError));

            // Some code originally from localForage in
            // [localForage](https://github.com/localForage/localForage).
            // Transaction Modes
            var READ_ONLY = 'readonly';
            var READ_WRITE = 'readwrite';
            var dbContexts = {};
            /**
             * Implementation of {@link IStorageAdapter} that uses IndexedDB for
             * persistence. For use in browsers.
             */
            var IndexedDbStorageAdapter = /** @class */ (function () {
                /**
                 * Initializes an instance of `IndexedDbStorageAdapter`.
                 * @param {IStorageAdapterConfig} config - Configuration options.
                 * Currently only `name` is supported and must be the name of the
                 * IndexedDB database where the data will be stored.
                 */
                function IndexedDbStorageAdapter(config) {
                    var _this = this;
                    // Open the IndexedDB database (automatically creates one if one didn't
                    // previously exist), using any options set in the config.
                    this._initStorage = function () {
                        var dbInfo = {
                            db: null,
                            name: _this._defaultConfig.name,
                            storeName: _this._defaultConfig.storeName,
                            version: _this._defaultConfig.version
                        };
                        // Get the current context of the database;
                        var dbContext = dbContexts[dbInfo.name];
                        // ...or create a new context.
                        if (!dbContext) {
                            dbContext = createDbContext();
                            // Register the new context in the global container.
                            dbContexts[dbInfo.name] = dbContext;
                        }
                        // Initialize the connection process only when
                        // all the related storages aren't pending.
                        return Promise.resolve()
                            .then(function () {
                            dbInfo.db = dbContext.db;
                            // Get the connection or open a new one without upgrade.
                            return _getOriginalConnection(dbInfo);
                        })
                            .then(function (db) {
                            dbInfo.db = db;
                            if (_isUpgradeNeeded(dbInfo, _this._defaultConfig.version)) {
                                // Reopen the database for upgrading.
                                return _getUpgradedConnection(dbInfo);
                            }
                            return db;
                        })
                            .then(function (db) {
                            dbInfo.db = dbContext.db = db;
                            _this._dbInfo = dbInfo;
                        });
                    };
                    // Specialize the default `ready()` function by making it dependent
                    // on the current database operations. Thus, the driver will be actually
                    // ready when it's been initialized (default) *and* there are no pending
                    // operations on the database (initiated by some other instances).
                    this.ready = function () {
                        var promise = _this._ready.then(function () {
                            var dbContext = dbContexts[_this._dbInfo.name];
                            if (dbContext && dbContext.dbReady) {
                                return dbContext.dbReady;
                            }
                        });
                        return promise;
                    };
                    if (!isIndexedDbValid()) {
                        throw new Error('Cannot use IndexedDbStorageAdapter. indexedDb is not supported');
                    }
                    this._defaultConfig = {
                        name: config.name,
                        version: 1,
                        storeName: 'keyvaluepairs'
                    };
                    this._ready = this._initStorage();
                }
                /**
                 * @inheritDoc
                 */
                IndexedDbStorageAdapter.prototype.store = function (key, data) {
                    var _this = this;
                    key = normalizeKey(key);
                    return new Promise(function (resolve, reject) {
                        _this.ready().then(function () {
                            createTransaction(_this._dbInfo, READ_WRITE, function (err, transaction) {
                                if (err) {
                                    return reject(err);
                                }
                                try {
                                    var store = transaction.objectStore(_this._dbInfo.storeName);
                                    var req_1 = store.add(toArrayBuffer(data), key);
                                    transaction.oncomplete = function () {
                                        resolve();
                                    };
                                    transaction.onabort = transaction.onerror = function () {
                                        var error = req_1.error
                                            ? req_1.error
                                            : req_1.transaction.error;
                                        if (error && error.name === 'ConstraintError') {
                                            reject(new StorageEntryAlreadyExistsError(key));
                                        }
                                        reject(error);
                                    };
                                }
                                catch (error) {
                                    reject(error);
                                }
                            });
                        }).catch(reject);
                    });
                };
                /**
                 * @inheritDoc
                 */
                IndexedDbStorageAdapter.prototype.load = function (key) {
                    var _this = this;
                    key = normalizeKey(key);
                    return new Promise(function (resolve, reject) {
                        _this.ready().then(function () {
                            createTransaction(_this._dbInfo, READ_ONLY, function (err, transaction) {
                                if (err) {
                                    return reject(err);
                                }
                                try {
                                    var store = transaction.objectStore(_this._dbInfo.storeName);
                                    var req_2 = store.get(key);
                                    req_2.onsuccess = function () {
                                        if (req_2.result == null) {
                                            return resolve(null);
                                        }
                                        var arrayBuffer = req_2.result;
                                        var buffer = Buffer.from(arrayBuffer);
                                        resolve(buffer);
                                    };
                                    req_2.onerror = function () {
                                        reject(req_2.error);
                                    };
                                }
                                catch (e) {
                                    reject(e);
                                }
                            });
                        }).catch(reject);
                    });
                };
                /**
                 * @inheritDoc
                 */
                IndexedDbStorageAdapter.prototype.exists = function (key) {
                    var _this = this;
                    key = normalizeKey(key);
                    return new Promise(function (resolve, reject) {
                        _this.ready().then(function () {
                            createTransaction(_this._dbInfo, READ_ONLY, function (err, transaction) {
                                if (err) {
                                    return reject(err);
                                }
                                try {
                                    var store = transaction.objectStore(_this._dbInfo.storeName);
                                    var req_3 = store.openCursor(key);
                                    req_3.onsuccess = function () {
                                        var cursor = req_3.result;
                                        resolve(cursor !== null);
                                    };
                                    req_3.onerror = function () {
                                        reject(req_3.error);
                                    };
                                }
                                catch (e) {
                                    reject(e);
                                }
                            });
                        }).catch(reject);
                    });
                };
                /**
                 * @inheritDoc
                 */
                IndexedDbStorageAdapter.prototype.remove = function (key) {
                    var _this = this;
                    key = normalizeKey(key);
                    return new Promise(function (resolve, reject) {
                        _this.ready().then(function () {
                            createTransaction(_this._dbInfo, READ_WRITE, function (err, transaction) {
                                if (err) {
                                    return reject(err);
                                }
                                try {
                                    var store_1 = transaction.objectStore(_this._dbInfo.storeName);
                                    var countReq_1 = store_1.count(key);
                                    var delReq_1;
                                    countReq_1.onsuccess = function () {
                                        var count = countReq_1.result;
                                        if (count === 0) {
                                            return resolve(false);
                                        }
                                        // safe for IE and some versions of Android
                                        // (including those used by Cordova).
                                        // Normally IE won't like `.delete()` and will insist on
                                        // using `['delete']()`
                                        delReq_1 = store_1['delete'](key);
                                        delReq_1.onsuccess = function () { return resolve(true); };
                                    };
                                    // The request will be also be aborted if we've exceeded our storage
                                    // space.
                                    transaction.onabort = transaction.onerror = function () {
                                        var req = delReq_1 || countReq_1;
                                        var err = req.error
                                            ? req.error
                                            : req.transaction.error;
                                        reject(err);
                                    };
                                }
                                catch (e) {
                                    reject(e);
                                }
                            });
                        }).catch(reject);
                    });
                };
                /**
                 * @inheritDoc
                 */
                IndexedDbStorageAdapter.prototype.update = function (key, data) {
                    var _this = this;
                    key = normalizeKey(key);
                    return new Promise(function (resolve, reject) {
                        _this.ready().then(function () {
                            createTransaction(_this._dbInfo, READ_WRITE, function (err, transaction) {
                                if (err) {
                                    return reject(err);
                                }
                                try {
                                    var store = transaction.objectStore(_this._dbInfo.storeName);
                                    var req_4 = store.put(toArrayBuffer(data), key);
                                    req_4.onsuccess = function () {
                                        resolve();
                                    };
                                    req_4.onerror = function () {
                                        reject(req_4.error);
                                    };
                                }
                                catch (error) {
                                    reject(error);
                                }
                            });
                        }).catch(reject);
                    });
                };
                /**
                 * @inheritDoc
                 */
                IndexedDbStorageAdapter.prototype.clear = function () {
                    var _this = this;
                    return new Promise(function (resolve, reject) {
                        _this.ready().then(function () {
                            createTransaction(_this._dbInfo, READ_WRITE, function (err, transaction) {
                                if (err) {
                                    return reject(err);
                                }
                                try {
                                    var store = transaction.objectStore(_this._dbInfo.storeName);
                                    var req_5 = store.clear();
                                    transaction.oncomplete = function () { return resolve(); };
                                    transaction.onabort = transaction.onerror = function () {
                                        var err = req_5.error
                                            ? req_5.error
                                            : req_5.transaction.error;
                                        reject(err);
                                    };
                                }
                                catch (e) {
                                    reject(e);
                                }
                            });
                        }).catch(reject);
                    });
                };
                /**
                 * @inheritDoc
                 */
                IndexedDbStorageAdapter.prototype.list = function () {
                    var _this = this;
                    return new Promise(function (resolve, reject) {
                        _this.ready().then(function () {
                            createTransaction(_this._dbInfo, READ_ONLY, function (err, transaction) {
                                if (err) {
                                    return reject(err);
                                }
                                try {
                                    var store = transaction.objectStore(_this._dbInfo.storeName);
                                    var req_6 = store.openCursor();
                                    var entries_1 = [];
                                    req_6.onsuccess = function () {
                                        var cursor = req_6.result;
                                        if (!cursor) {
                                            resolve(entries_1);
                                        }
                                        else {
                                            entries_1.push(Buffer.from(cursor.value));
                                            cursor.continue();
                                        }
                                    };
                                    req_6.onerror = function () {
                                        reject(req_6.error);
                                    };
                                }
                                catch (e) {
                                    reject(e);
                                }
                            });
                        }).catch(reject);
                    });
                };
                return IndexedDbStorageAdapter;
            }());
            function createDbContext() {
                return {
                    // Database.
                    db: null,
                    // Database readiness (promise).
                    dbReady: null,
                    // Deferred operations on the database.
                    deferredOperations: []
                };
            }
            function _deferReadiness(dbInfo) {
                var dbContext = dbContexts[dbInfo.name];
                // Create a deferred object representing the current database operation.
                var deferredOperation = {};
                deferredOperation.promise = new Promise(function (resolve, reject) {
                    deferredOperation.resolve = resolve;
                    deferredOperation.reject = reject;
                });
                // Enqueue the deferred operation.
                dbContext.deferredOperations.push(deferredOperation);
                // Chain its promise to the database readiness.
                if (!dbContext.dbReady) {
                    dbContext.dbReady = deferredOperation.promise;
                }
                else {
                    dbContext.dbReady = dbContext.dbReady.then(function () { return deferredOperation.promise; });
                }
            }
            function _advanceReadiness(dbInfo) {
                var dbContext = dbContexts[dbInfo.name];
                // Dequeue a deferred operation.
                var deferredOperation = dbContext.deferredOperations.pop();
                // Resolve its promise (which is part of the database readiness
                // chain of promises).
                if (deferredOperation) {
                    deferredOperation.resolve();
                    return deferredOperation.promise;
                }
            }
            function _rejectReadiness(dbInfo, err) {
                var dbContext = dbContexts[dbInfo.name];
                // Dequeue a deferred operation.
                var deferredOperation = dbContext.deferredOperations.pop();
                // Reject its promise (which is part of the database readiness
                // chain of promises).
                if (deferredOperation) {
                    deferredOperation.reject(err);
                    return deferredOperation.promise;
                }
            }
            function _getConnection(dbInfo, upgradeNeeded) {
                return new Promise(function (resolve, reject) {
                    dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
                    if (dbInfo.db) {
                        if (upgradeNeeded) {
                            _deferReadiness(dbInfo);
                            dbInfo.db.close();
                        }
                        else {
                            return resolve(dbInfo.db);
                        }
                    }
                    var dbArgs = [dbInfo.name];
                    if (upgradeNeeded) {
                        dbArgs.push(String(dbInfo.version));
                    }
                    var openReq = indexedDB.open.apply(indexedDB, dbArgs);
                    if (upgradeNeeded) {
                        openReq.onupgradeneeded = function (e) {
                            var db = openReq.result;
                            try {
                                db.createObjectStore(dbInfo.storeName);
                            }
                            catch (ex) {
                                if (ex.name === 'ConstraintError') {
                                    console.warn('The database "' +
                                        dbInfo.name +
                                        '"' +
                                        ' has been upgraded from version ' +
                                        e.oldVersion +
                                        ' to version ' +
                                        e.newVersion +
                                        ', but the storage "' +
                                        dbInfo.storeName +
                                        '" already exists.');
                                }
                                else {
                                    throw ex;
                                }
                            }
                        };
                    }
                    openReq.onerror = function (e) {
                        e.preventDefault();
                        reject(openReq.error);
                    };
                    openReq.onsuccess = function () {
                        resolve(openReq.result);
                        _advanceReadiness(dbInfo);
                    };
                });
            }
            function _getOriginalConnection(dbInfo) {
                return _getConnection(dbInfo, false);
            }
            function _getUpgradedConnection(dbInfo) {
                return _getConnection(dbInfo, true);
            }
            function _isUpgradeNeeded(dbInfo, defaultVersion) {
                if (!dbInfo.db) {
                    return true;
                }
                var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
                var isDowngrade = dbInfo.version < dbInfo.db.version;
                var isUpgrade = dbInfo.version > dbInfo.db.version;
                if (isDowngrade) {
                    // If the version is not the default one
                    // then warn for impossible downgrade.
                    if (dbInfo.version !== defaultVersion) {
                        console.warn('The database "' +
                            dbInfo.name +
                            '"' +
                            " can't be downgraded from version " +
                            dbInfo.db.version +
                            ' to version ' +
                            dbInfo.version +
                            '.');
                    }
                    // Align the versions to prevent errors.
                    dbInfo.version = dbInfo.db.version;
                }
                if (isUpgrade || isNewStore) {
                    // If the store is new then increment the version (if needed).
                    // This will trigger an "upgradeneeded" event which is required
                    // for creating a store.
                    if (isNewStore) {
                        var incVersion = dbInfo.db.version + 1;
                        if (incVersion > dbInfo.version) {
                            dbInfo.version = incVersion;
                        }
                    }
                    return true;
                }
                return false;
            }
            // Try to establish a new db connection to replace the
            // current one which is broken (i.e. experiencing
            // InvalidStateError while creating a transaction).
            function _tryReconnect(dbInfo) {
                _deferReadiness(dbInfo);
                var dbContext = dbContexts[dbInfo.name];
                dbInfo.db = null;
                return _getOriginalConnection(dbInfo)
                    .then(function (db) {
                    dbInfo.db = db;
                    if (_isUpgradeNeeded(dbInfo)) {
                        // Reopen the database for upgrading.
                        return _getUpgradedConnection(dbInfo);
                    }
                    return db;
                })
                    .then(function (db) {
                    // store the latest db reference
                    // in case the db was upgraded
                    dbInfo.db = dbContext.db = db;
                })
                    .catch(function (err) {
                    _rejectReadiness(dbInfo, err);
                    throw err;
                });
            }
            // FF doesn't like Promises (micro-tasks) and IDDB store operations,
            // so we have to do it with callbacks
            function createTransaction(dbInfo, mode, callback, retries) {
                if (retries === undefined) {
                    retries = 1;
                }
                try {
                    var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
                    callback(null, tx);
                }
                catch (err) {
                    if (retries > 0 &&
                        (!dbInfo.db ||
                            err.name === 'InvalidStateError' ||
                            err.name === 'NotFoundError')) {
                        Promise.resolve()
                            .then(function () {
                            if (!dbInfo.db ||
                                (err.name === 'NotFoundError' &&
                                    !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) &&
                                    dbInfo.version <= dbInfo.db.version)) {
                                // increase the db version, to create the new ObjectStore
                                if (dbInfo.db) {
                                    dbInfo.version = dbInfo.db.version + 1;
                                }
                                // Reopen the database for upgrading.
                                return _getUpgradedConnection(dbInfo);
                            }
                        })
                            .then(function () {
                            return _tryReconnect(dbInfo).then(function () {
                                createTransaction(dbInfo, mode, callback, retries - 1);
                            });
                        })
                            .catch(callback);
                    }
                    callback(err);
                }
            }
            function normalizeKey(key) {
                // Cast the key to a string, as that's all we can set as a key.
                if (typeof key !== 'string') {
                    console.warn(key + " used as a key, but it is not a string.");
                    key = String(key);
                }
                return key;
            }
            // taken from here https://github.com/jhiesey/to-arraybuffer
            function toArrayBuffer(buf) {
                // If the buffer is backed by a Uint8Array, a faster version will work
                if (buf instanceof Uint8Array) {
                    // If the buffer isn't a subarray, return the underlying ArrayBuffer
                    if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
                        return buf.buffer;
                    }
                    else if (typeof buf.buffer.slice === 'function') {
                        // Otherwise we need to get a proper copy
                        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
                    }
                }
                if (Buffer.isBuffer(buf)) {
                    // This is the slow version that will work with any Buffer
                    // implementation (even in old browsers)
                    var arrayCopy = new Uint8Array(buf.length);
                    var len = buf.length;
                    for (var i = 0; i < len; i++) {
                        arrayCopy[i] = buf[i];
                    }
                    return arrayCopy.buffer;
                }
                else {
                    throw new Error('Argument must be a Buffer');
                }
            }

            /**
             * {@link FileSystemStorageAdapter} or {@link IndexedDbStorageAdapter}
             * depending on the target platform (node or browser).
             */

            /**
             * Error thrown from {@link PrivateKeyStorage.save} method when saving
             * a private key with a name that already exists in store.
             */
            var PrivateKeyExistsError = /** @class */ (function (_super) {
                __extends(PrivateKeyExistsError, _super);
                function PrivateKeyExistsError(message) {
                    if (message === void 0) { message = 'Private key with same name already exists'; }
                    return _super.call(this, message, 'PrivateKeyExistsError') || this;
                }
                return PrivateKeyExistsError;
            }(VirgilError));

            var DEFAULTS$1 = {
                dir: '.virgil_keys',
                name: 'VirgilKeys'
            };
            /**
             * Class representing a storage container for private key data.
             * Use this class if you need to load the keys stored with
             * version 4.x of this library. For new code, use the
             * {@link PrivateKeyStorage} instead.
             *
             * @deprecated since version 5.0
             */
            var KeyStorage = /** @class */ (function () {
                function KeyStorage(config) {
                    if (config === void 0) { config = {}; }
                    console.log('Warning! `KeyStorage` is deprecated. Use `PrivateKeyStorage` instead.');
                    this.adapter = resolveAdapter(config);
                }
                /**
                 * Checks whether a private key data with the given name exist in persistent storage.
                 * @param {string} name - Name to check.
                 * @returns {Promise<boolean>} - True if key data exist, otherwise false.
                 */
                KeyStorage.prototype.exists = function (name) {
                    validateName(name);
                    return this.adapter.exists(name);
                };
                /**
                 * Loads the private key data by the given name.
                 * @param {string} name - Name of key data to load.
                 * @returns {Promise<Buffer | null>} - Private key data as Buffer,
                 * or null if there is no data for the given name.
                 */
                KeyStorage.prototype.load = function (name) {
                    validateName(name);
                    return this.adapter.load(name);
                };
                /**
                 * Removes the private key data stored under the given name from persistent storage.
                 * @param {string} name - Name of the key data to remove.
                 * @returns {Promise<boolean>} - True if the key has been removed, otherwise false.
                 */
                KeyStorage.prototype.remove = function (name) {
                    validateName(name);
                    return this.adapter.remove(name);
                };
                /**
                 * Persists the private key data under the given name.
                 * @param {string} name - Name of the key data.
                 * @param {Buffer} data - The key data.
                 * @returns {Promise<void>}
                 */
                KeyStorage.prototype.save = function (name, data) {
                    validateName(name);
                    validateData(data);
                    return this.adapter.store(name, data)
                        .catch(function (error) {
                        if (error && error.code === 'EEXIST') {
                            return Promise.reject(new PrivateKeyExistsError());
                        }
                        return Promise.reject(error);
                    });
                };
                return KeyStorage;
            }());
            function resolveAdapter(config) {
                if (typeof config === 'string') {
                    return new IndexedDbStorageAdapter({ dir: config, name: config });
                }
                var adapter = config.adapter, rest = __rest(config, ["adapter"]);
                if (adapter != null) {
                    return adapter;
                }
                return new IndexedDbStorageAdapter(__assign({}, DEFAULTS$1, rest));
            }
            function validateName(name) {
                if (!name)
                    throw new TypeError('Argument `name` is required.');
            }
            function validateData(data) {
                if (!data)
                    throw new TypeError('Argument `data` is required.');
            }

            /**
             * Error thrown when the value loaded from persistent storage cannot be
             * parsed as a {@link IKeyEntry} object.
             */
            var InvalidKeyEntryError = /** @class */ (function (_super) {
                __extends(InvalidKeyEntryError, _super);
                function InvalidKeyEntryError(message) {
                    if (message === void 0) { message = 'Loaded key entry was in invalid format.'; }
                    return _super.call(this, message, 'InvalidKeyEntryError') || this;
                }
                return InvalidKeyEntryError;
            }(VirgilError));
            /**
             * Error thrown from {@link KeyEntryStorage.save} method when saving a
             * a key entry with the name that already exists in store.
             */
            var KeyEntryAlreadyExistsError = /** @class */ (function (_super) {
                __extends(KeyEntryAlreadyExistsError, _super);
                function KeyEntryAlreadyExistsError(name) {
                    return _super.call(this, "Key entry " + (name ? 'named ' + name : 'with same name') + "already exists", 'KeyEntryAlreadyExistsError') || this;
                }
                return KeyEntryAlreadyExistsError;
            }(VirgilError));
            /**
             * Error thrown from {@link KeyEntryStorage.update} method when updating
             * a key entry that doesn't exist in store.
             */
            var KeyEntryDoesNotExistError = /** @class */ (function (_super) {
                __extends(KeyEntryDoesNotExistError, _super);
                function KeyEntryDoesNotExistError(name) {
                    return _super.call(this, "Key entry " + (name ? 'named ' + name : 'with the given name') + " does not exist.", 'KeyEntryDoesNotExistError') || this;
                }
                return KeyEntryDoesNotExistError;
            }(VirgilError));

            var DEFAULTS$2 = {
                dir: '.virgil_key_entries',
                name: 'VirgilKeyEntries'
            };
            var VALUE_KEY = 'value';
            var CREATION_DATE_KEY = 'creationDate';
            var MODIFICATION_DATE_KEY = 'modificationDate';
            /**
             * Class responsible for persisting private key bytes with optional
             * user-defined metadata.
             */
            var KeyEntryStorage = /** @class */ (function () {
                /**
                 * Initializes a new instance of `KeyEntryStorage`.
                 *
                 * @param {IKeyEntryStorageConfig} config - Instance configuration.
                 */
                function KeyEntryStorage(config) {
                    if (config === void 0) { config = {}; }
                    this.adapter = resolveAdapter$1(config);
                }
                /**
                 * @inheritDoc
                 */
                KeyEntryStorage.prototype.exists = function (name) {
                    validateName$1(name);
                    return this.adapter.exists(name);
                };
                /**
                 * @inheritDoc
                 */
                KeyEntryStorage.prototype.load = function (name) {
                    validateName$1(name);
                    return this.adapter.load(name).then(function (data) {
                        if (data == null) {
                            return null;
                        }
                        return deserializeKeyEntry(data);
                    });
                };
                /**
                 * @inheritDoc
                 */
                KeyEntryStorage.prototype.remove = function (name) {
                    validateName$1(name);
                    return this.adapter.remove(name);
                };
                /**
                 * @inheritDoc
                 */
                KeyEntryStorage.prototype.save = function (_a) {
                    var name = _a.name, value = _a.value, meta = _a.meta;
                    validateNameProperty(name);
                    validateValueProperty(value);
                    var keyEntry = {
                        name: name,
                        value: value,
                        meta: meta,
                        creationDate: new Date(),
                        modificationDate: new Date()
                    };
                    return this.adapter.store(name, serializeKeyEntry(keyEntry))
                        .then(function () { return keyEntry; })
                        .catch(function (error) {
                        if (error && error.name === 'StorageEntryAlreadyExistsError') {
                            throw new KeyEntryAlreadyExistsError(name);
                        }
                        throw error;
                    });
                };
                /**
                 * @inheritDoc
                 */
                KeyEntryStorage.prototype.list = function () {
                    return this.adapter.list()
                        .then(function (entries) { return entries.map(function (entry) { return deserializeKeyEntry(entry); }); });
                };
                /**
                 * @inheritDoc
                 */
                KeyEntryStorage.prototype.update = function (_a) {
                    var _this = this;
                    var name = _a.name, value = _a.value, meta = _a.meta;
                    validateNameProperty(name);
                    if (!(value || meta)) {
                        throw new TypeError('Invalid argument. Either `value` or `meta` property is required.');
                    }
                    return this.adapter.load(name)
                        .then(function (data) {
                        if (data === null) {
                            throw new KeyEntryDoesNotExistError(name);
                        }
                        var entry = deserializeKeyEntry(data);
                        var updatedEntry = Object.assign(entry, {
                            value: value || entry.value,
                            meta: meta || entry.meta,
                            modificationDate: new Date()
                        });
                        return _this.adapter.update(name, serializeKeyEntry(updatedEntry))
                            .then(function () { return updatedEntry; });
                    });
                };
                /**
                 * @inheritDoc
                 */
                KeyEntryStorage.prototype.clear = function () {
                    return this.adapter.clear();
                };
                return KeyEntryStorage;
            }());
            function serializeKeyEntry(keyEntry) {
                var value = keyEntry.value, rest = __rest(keyEntry, ["value"]);
                var serializableEntry = __assign({}, rest, { value: value.toString('base64') });
                return Buffer.from(JSON.stringify(serializableEntry), 'utf8');
            }
            function deserializeKeyEntry(data) {
                var dataStr = data.toString('utf8');
                try {
                    return JSON.parse(dataStr, function (key, value) {
                        if (key === VALUE_KEY) {
                            return Buffer.from(value, 'base64');
                        }
                        if (key === CREATION_DATE_KEY || key === MODIFICATION_DATE_KEY) {
                            return new Date(value);
                        }
                        return value;
                    });
                }
                catch (error) {
                    throw new InvalidKeyEntryError();
                }
            }
            function resolveAdapter$1(config) {
                if (typeof config === 'string') {
                    return new IndexedDbStorageAdapter({ dir: config, name: config });
                }
                var adapter = config.adapter, rest = __rest(config, ["adapter"]);
                if (adapter != null) {
                    return adapter;
                }
                return new IndexedDbStorageAdapter(__assign({}, DEFAULTS$2, rest));
            }
            var requiredArg = function (name) { return function (value) {
                if (!value)
                    throw new TypeError("Argument '" + name + "' is required.");
            }; };
            var requiredProp = function (name) { return function (value) {
                if (!value)
                    throw new TypeError("Invalid argument. Property " + name + " is required");
            }; };
            var validateName$1 = requiredArg('name');
            var validateNameProperty = requiredProp('name');
            var validateValueProperty = requiredProp('value');

            /**
             * Class responsible for storage of private keys.
             */
            var PrivateKeyStorage = /** @class */ (function () {
                /**
                 * Initializes a new instance of `PrivateKeyStorage`.
                 * @param {IPrivateKeyExporter} privateKeyExporter - Object responsible for
                 * exporting private key bytes from `IPrivateKey` objects and importing
                 * private key bytes into `IPrivateKey` objects.
                 * @param {IKeyEntryStorage} keyEntryStorage - Object responsible for
                 * persistence of private keys data.
                 */
                function PrivateKeyStorage(privateKeyExporter, keyEntryStorage) {
                    if (keyEntryStorage === void 0) { keyEntryStorage = new KeyEntryStorage(); }
                    this.privateKeyExporter = privateKeyExporter;
                    this.keyEntryStorage = keyEntryStorage;
                }
                /**
                 * Persists the given `privateKey` and `meta` under the given `name`.
                 * If an entry with the same name already exists rejects the returned
                 * Promise with {@link PrivateKeyExistsError} error.
                 *
                 * @param {string} name - Name of the private key.
                 * @param {IPrivateKey} privateKey - The private key object.
                 * @param {Object<string, string>} [meta] - Optional metadata to store with the key.
                 *
                 * @returns {Promise<void>}
                 */
                PrivateKeyStorage.prototype.store = function (name, privateKey, meta) {
                    return __awaiter(this, void 0, void 0, function () {
                        var privateKeyData, error_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    privateKeyData = this.privateKeyExporter.exportPrivateKey(privateKey);
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, 3, , 4]);
                                    return [4 /*yield*/, this.keyEntryStorage.save({ name: name, value: privateKeyData, meta: meta })];
                                case 2:
                                    _a.sent();
                                    return [3 /*break*/, 4];
                                case 3:
                                    error_1 = _a.sent();
                                    if (error_1 && error_1.name === 'KeyEntryAlreadyExistsError') {
                                        throw new PrivateKeyExistsError("Private key with the name " + name + " already exists.");
                                    }
                                    throw error_1;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Retrieves the private key with the given `name` from persistent storage.
                 * If private with the given name does not exist, resolves the returned
                 * Promise with `null`.
                 *
                 * @param {string} name - Name of the private key to load.
                 * @returns {Promise<IPrivateKeyEntry|null>}
                 */
                PrivateKeyStorage.prototype.load = function (name) {
                    return __awaiter(this, void 0, void 0, function () {
                        var keyEntry, privateKey;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.keyEntryStorage.load(name)];
                                case 1:
                                    keyEntry = _a.sent();
                                    if (keyEntry === null) {
                                        return [2 /*return*/, null];
                                    }
                                    privateKey = this.privateKeyExporter.importPrivateKey(keyEntry.value);
                                    return [2 /*return*/, {
                                            privateKey: privateKey,
                                            meta: keyEntry.meta
                                        }];
                            }
                        });
                    });
                };
                /**
                 * Removes the private key entry with the given `name` from persistent
                 * storage.
                 *
                 * @param {string} name - Name of the private key to remove.
                 * @returns {Promise<void>}
                 */
                PrivateKeyStorage.prototype.delete = function (name) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.keyEntryStorage.remove(name)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                return PrivateKeyStorage;
            }());

            exports.JwtGenerator = JwtGenerator;
            exports.JwtVerifier = JwtVerifier;
            exports.Jwt = Jwt;
            exports.CachingJwtProvider = CachingJwtProvider;
            exports.CallbackJwtProvider = CallbackJwtProvider;
            exports.ConstAccessTokenProvider = ConstAccessTokenProvider;
            exports.GeneratorJwtProvider = GeneratorJwtProvider;
            exports.CardManager = CardManager;
            exports.VirgilCardVerifier = VirgilCardVerifier;
            exports.RawSignedModel = RawSignedModel;
            exports.ModelSigner = ModelSigner;
            exports.DefaultStorageAdapter = IndexedDbStorageAdapter;
            exports.StorageEntryAlreadyExistsError = StorageEntryAlreadyExistsError;
            exports.KeyStorage = KeyStorage;
            exports.KeyEntryStorage = KeyEntryStorage;
            exports.InvalidKeyEntryError = InvalidKeyEntryError;
            exports.KeyEntryAlreadyExistsError = KeyEntryAlreadyExistsError;
            exports.KeyEntryDoesNotExistError = KeyEntryDoesNotExistError;
            exports.PrivateKeyStorage = PrivateKeyStorage;

            Object.defineProperty(exports, '__esModule', { value: true });

})));
